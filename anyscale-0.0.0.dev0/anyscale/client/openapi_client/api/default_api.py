# coding: utf-8

"""
    Managed Ray API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)  # noqa: E501

    The version of the OpenAPI document: 0.1.0
    Generated by: https://openapi-generator.tech
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from openapi_client.api_client import ApiClient
from openapi_client.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class DefaultApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def add_to_waitlist_api_v2_aioa_cloud_waitlist_post(self, create_aioa_cloud_waitlist, **kwargs):  # noqa: E501
        """Add To Waitlist  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_to_waitlist_api_v2_aioa_cloud_waitlist_post(create_aioa_cloud_waitlist, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateAioaCloudWaitlist create_aioa_cloud_waitlist: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AioacloudwaitlistrecordResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.add_to_waitlist_api_v2_aioa_cloud_waitlist_post_with_http_info(create_aioa_cloud_waitlist, **kwargs)  # noqa: E501

    def add_to_waitlist_api_v2_aioa_cloud_waitlist_post_with_http_info(self, create_aioa_cloud_waitlist, **kwargs):  # noqa: E501
        """Add To Waitlist  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_to_waitlist_api_v2_aioa_cloud_waitlist_post_with_http_info(create_aioa_cloud_waitlist, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateAioaCloudWaitlist create_aioa_cloud_waitlist: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AioacloudwaitlistrecordResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'create_aioa_cloud_waitlist'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_to_waitlist_api_v2_aioa_cloud_waitlist_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'create_aioa_cloud_waitlist' is set
        if self.api_client.client_side_validation and ('create_aioa_cloud_waitlist' not in local_var_params or  # noqa: E501
                                                        local_var_params['create_aioa_cloud_waitlist'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `create_aioa_cloud_waitlist` when calling `add_to_waitlist_api_v2_aioa_cloud_waitlist_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_aioa_cloud_waitlist' in local_var_params:
            body_params = local_var_params['create_aioa_cloud_waitlist']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/aioa_cloud_waitlist/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AioacloudwaitlistrecordResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def alter_organization_collaborator_api_v2_organization_collaborators_identity_id_put(self, identity_id, update_organization_collaborator, **kwargs):  # noqa: E501
        """Alter Organization Collaborator  # noqa: E501

        Updates a collaborator's permission level  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.alter_organization_collaborator_api_v2_organization_collaborators_identity_id_put(identity_id, update_organization_collaborator, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str identity_id: (required)
        :param UpdateOrganizationCollaborator update_organization_collaborator: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.alter_organization_collaborator_api_v2_organization_collaborators_identity_id_put_with_http_info(identity_id, update_organization_collaborator, **kwargs)  # noqa: E501

    def alter_organization_collaborator_api_v2_organization_collaborators_identity_id_put_with_http_info(self, identity_id, update_organization_collaborator, **kwargs):  # noqa: E501
        """Alter Organization Collaborator  # noqa: E501

        Updates a collaborator's permission level  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.alter_organization_collaborator_api_v2_organization_collaborators_identity_id_put_with_http_info(identity_id, update_organization_collaborator, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str identity_id: (required)
        :param UpdateOrganizationCollaborator update_organization_collaborator: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'identity_id',
            'update_organization_collaborator'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method alter_organization_collaborator_api_v2_organization_collaborators_identity_id_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'identity_id' is set
        if self.api_client.client_side_validation and ('identity_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['identity_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `identity_id` when calling `alter_organization_collaborator_api_v2_organization_collaborators_identity_id_put`")  # noqa: E501
        # verify the required parameter 'update_organization_collaborator' is set
        if self.api_client.client_side_validation and ('update_organization_collaborator' not in local_var_params or  # noqa: E501
                                                        local_var_params['update_organization_collaborator'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `update_organization_collaborator` when calling `alter_organization_collaborator_api_v2_organization_collaborators_identity_id_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'identity_id' in local_var_params:
            path_params['identity_id'] = local_var_params['identity_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'update_organization_collaborator' in local_var_params:
            body_params = local_var_params['update_organization_collaborator']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organization_collaborators/{identity_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def alter_project_collaborator_api_v2_projects_project_id_collaborators_role_or_identity_id_put(self, project_id, role_or_identity_id, update_project_collaborator, **kwargs):  # noqa: E501
        """Alter Project Collaborator  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.alter_project_collaborator_api_v2_projects_project_id_collaborators_role_or_identity_id_put(project_id, role_or_identity_id, update_project_collaborator, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: (required)
        :param str role_or_identity_id: (required)
        :param UpdateProjectCollaborator update_project_collaborator: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.alter_project_collaborator_api_v2_projects_project_id_collaborators_role_or_identity_id_put_with_http_info(project_id, role_or_identity_id, update_project_collaborator, **kwargs)  # noqa: E501

    def alter_project_collaborator_api_v2_projects_project_id_collaborators_role_or_identity_id_put_with_http_info(self, project_id, role_or_identity_id, update_project_collaborator, **kwargs):  # noqa: E501
        """Alter Project Collaborator  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.alter_project_collaborator_api_v2_projects_project_id_collaborators_role_or_identity_id_put_with_http_info(project_id, role_or_identity_id, update_project_collaborator, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: (required)
        :param str role_or_identity_id: (required)
        :param UpdateProjectCollaborator update_project_collaborator: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project_id',
            'role_or_identity_id',
            'update_project_collaborator'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method alter_project_collaborator_api_v2_projects_project_id_collaborators_role_or_identity_id_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `alter_project_collaborator_api_v2_projects_project_id_collaborators_role_or_identity_id_put`")  # noqa: E501
        # verify the required parameter 'role_or_identity_id' is set
        if self.api_client.client_side_validation and ('role_or_identity_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['role_or_identity_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `role_or_identity_id` when calling `alter_project_collaborator_api_v2_projects_project_id_collaborators_role_or_identity_id_put`")  # noqa: E501
        # verify the required parameter 'update_project_collaborator' is set
        if self.api_client.client_side_validation and ('update_project_collaborator' not in local_var_params or  # noqa: E501
                                                        local_var_params['update_project_collaborator'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `update_project_collaborator` when calling `alter_project_collaborator_api_v2_projects_project_id_collaborators_role_or_identity_id_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in local_var_params:
            path_params['project_id'] = local_var_params['project_id']  # noqa: E501
        if 'role_or_identity_id' in local_var_params:
            path_params['role_or_identity_id'] = local_var_params['role_or_identity_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'update_project_collaborator' in local_var_params:
            body_params = local_var_params['update_project_collaborator']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/projects/{project_id}/collaborators/{role_or_identity_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def apply_service_api_v2_services_v2_apply_put(self, apply_production_service_v2_model, **kwargs):  # noqa: E501
        """Apply Service  # noqa: E501

        Apply a Service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.apply_service_api_v2_services_v2_apply_put(apply_production_service_v2_model, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ApplyProductionServiceV2Model apply_production_service_v2_model: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Decoratedproductionservicev2ApimodelResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.apply_service_api_v2_services_v2_apply_put_with_http_info(apply_production_service_v2_model, **kwargs)  # noqa: E501

    def apply_service_api_v2_services_v2_apply_put_with_http_info(self, apply_production_service_v2_model, **kwargs):  # noqa: E501
        """Apply Service  # noqa: E501

        Apply a Service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.apply_service_api_v2_services_v2_apply_put_with_http_info(apply_production_service_v2_model, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ApplyProductionServiceV2Model apply_production_service_v2_model: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Decoratedproductionservicev2ApimodelResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'apply_production_service_v2_model'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method apply_service_api_v2_services_v2_apply_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'apply_production_service_v2_model' is set
        if self.api_client.client_side_validation and ('apply_production_service_v2_model' not in local_var_params or  # noqa: E501
                                                        local_var_params['apply_production_service_v2_model'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `apply_production_service_v2_model` when calling `apply_service_api_v2_services_v2_apply_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'apply_production_service_v2_model' in local_var_params:
            body_params = local_var_params['apply_production_service_v2_model']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/services-v2/apply', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Decoratedproductionservicev2ApimodelResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def archive_aica_endpoint_api_v2_aica_endpoints_endpoint_id_delete(self, endpoint_id, **kwargs):  # noqa: E501
        """Archive Aica Endpoint  # noqa: E501

        archives an AICA endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.archive_aica_endpoint_api_v2_aica_endpoints_endpoint_id_delete(endpoint_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str endpoint_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.archive_aica_endpoint_api_v2_aica_endpoints_endpoint_id_delete_with_http_info(endpoint_id, **kwargs)  # noqa: E501

    def archive_aica_endpoint_api_v2_aica_endpoints_endpoint_id_delete_with_http_info(self, endpoint_id, **kwargs):  # noqa: E501
        """Archive Aica Endpoint  # noqa: E501

        archives an AICA endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.archive_aica_endpoint_api_v2_aica_endpoints_endpoint_id_delete_with_http_info(endpoint_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str endpoint_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'endpoint_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method archive_aica_endpoint_api_v2_aica_endpoints_endpoint_id_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'endpoint_id' is set
        if self.api_client.client_side_validation and ('endpoint_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['endpoint_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `endpoint_id` when calling `archive_aica_endpoint_api_v2_aica_endpoints_endpoint_id_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'endpoint_id' in local_var_params:
            path_params['endpoint_id'] = local_var_params['endpoint_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/aica_endpoints/{endpoint_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def archive_cluster_api_v2_decorated_sessions_cluster_id_archive_post(self, cluster_id, **kwargs):  # noqa: E501
        """Archive Cluster  # noqa: E501

        Archives the cluster. It is a no-op if the cluster is already archived.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.archive_cluster_api_v2_decorated_sessions_cluster_id_archive_post(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.archive_cluster_api_v2_decorated_sessions_cluster_id_archive_post_with_http_info(cluster_id, **kwargs)  # noqa: E501

    def archive_cluster_api_v2_decorated_sessions_cluster_id_archive_post_with_http_info(self, cluster_id, **kwargs):  # noqa: E501
        """Archive Cluster  # noqa: E501

        Archives the cluster. It is a no-op if the cluster is already archived.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.archive_cluster_api_v2_decorated_sessions_cluster_id_archive_post_with_http_info(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cluster_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method archive_cluster_api_v2_decorated_sessions_cluster_id_archive_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and ('cluster_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cluster_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `archive_cluster_api_v2_decorated_sessions_cluster_id_archive_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in local_var_params:
            path_params['cluster_id'] = local_var_params['cluster_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/decorated_sessions/{cluster_id}/archive', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def archive_cluster_environment_api_v2_application_templates_application_template_id_archive_post(self, application_template_id, **kwargs):  # noqa: E501
        """Archive Cluster Environment  # noqa: E501

        Archives a cluster environment.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.archive_cluster_environment_api_v2_application_templates_application_template_id_archive_post(application_template_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str application_template_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.archive_cluster_environment_api_v2_application_templates_application_template_id_archive_post_with_http_info(application_template_id, **kwargs)  # noqa: E501

    def archive_cluster_environment_api_v2_application_templates_application_template_id_archive_post_with_http_info(self, application_template_id, **kwargs):  # noqa: E501
        """Archive Cluster Environment  # noqa: E501

        Archives a cluster environment.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.archive_cluster_environment_api_v2_application_templates_application_template_id_archive_post_with_http_info(application_template_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str application_template_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'application_template_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method archive_cluster_environment_api_v2_application_templates_application_template_id_archive_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_template_id' is set
        if self.api_client.client_side_validation and ('application_template_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_template_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_template_id` when calling `archive_cluster_environment_api_v2_application_templates_application_template_id_archive_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_template_id' in local_var_params:
            path_params['application_template_id'] = local_var_params['application_template_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/application_templates/{application_template_id}/archive', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def archive_compute_template_api_v2_compute_templates_compute_template_id_archive_post(self, compute_template_id, **kwargs):  # noqa: E501
        """Archive Compute Template  # noqa: E501

        Archives a compute template and all of its versions.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.archive_compute_template_api_v2_compute_templates_compute_template_id_archive_post(compute_template_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str compute_template_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.archive_compute_template_api_v2_compute_templates_compute_template_id_archive_post_with_http_info(compute_template_id, **kwargs)  # noqa: E501

    def archive_compute_template_api_v2_compute_templates_compute_template_id_archive_post_with_http_info(self, compute_template_id, **kwargs):  # noqa: E501
        """Archive Compute Template  # noqa: E501

        Archives a compute template and all of its versions.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.archive_compute_template_api_v2_compute_templates_compute_template_id_archive_post_with_http_info(compute_template_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str compute_template_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'compute_template_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method archive_compute_template_api_v2_compute_templates_compute_template_id_archive_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'compute_template_id' is set
        if self.api_client.client_side_validation and ('compute_template_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['compute_template_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `compute_template_id` when calling `archive_compute_template_api_v2_compute_templates_compute_template_id_archive_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'compute_template_id' in local_var_params:
            path_params['compute_template_id'] = local_var_params['compute_template_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/compute_templates/{compute_template_id}/archive', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def archive_job_api_v2_decorated_ha_jobs_production_job_id_archive_post(self, production_job_id, **kwargs):  # noqa: E501
        """Archive Job  # noqa: E501

        Archives the Job/Service. It is a no-op if the cluster is already archived.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.archive_job_api_v2_decorated_ha_jobs_production_job_id_archive_post(production_job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str production_job_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.archive_job_api_v2_decorated_ha_jobs_production_job_id_archive_post_with_http_info(production_job_id, **kwargs)  # noqa: E501

    def archive_job_api_v2_decorated_ha_jobs_production_job_id_archive_post_with_http_info(self, production_job_id, **kwargs):  # noqa: E501
        """Archive Job  # noqa: E501

        Archives the Job/Service. It is a no-op if the cluster is already archived.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.archive_job_api_v2_decorated_ha_jobs_production_job_id_archive_post_with_http_info(production_job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str production_job_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'production_job_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method archive_job_api_v2_decorated_ha_jobs_production_job_id_archive_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'production_job_id' is set
        if self.api_client.client_side_validation and ('production_job_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['production_job_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `production_job_id` when calling `archive_job_api_v2_decorated_ha_jobs_production_job_id_archive_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'production_job_id' in local_var_params:
            path_params['production_job_id'] = local_var_params['production_job_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/decorated_ha_jobs/{production_job_id}/archive', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def attach_machine_pool_to_cloud_api_v2_machine_pools_attach_post(self, attach_machine_pool_to_cloud_request, **kwargs):  # noqa: E501
        """Attach Machine Pool To Cloud  # noqa: E501

        Attach a machine pool to a cloud.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.attach_machine_pool_to_cloud_api_v2_machine_pools_attach_post(attach_machine_pool_to_cloud_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param AttachMachinePoolToCloudRequest attach_machine_pool_to_cloud_request: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AttachmachinepooltocloudresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.attach_machine_pool_to_cloud_api_v2_machine_pools_attach_post_with_http_info(attach_machine_pool_to_cloud_request, **kwargs)  # noqa: E501

    def attach_machine_pool_to_cloud_api_v2_machine_pools_attach_post_with_http_info(self, attach_machine_pool_to_cloud_request, **kwargs):  # noqa: E501
        """Attach Machine Pool To Cloud  # noqa: E501

        Attach a machine pool to a cloud.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.attach_machine_pool_to_cloud_api_v2_machine_pools_attach_post_with_http_info(attach_machine_pool_to_cloud_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param AttachMachinePoolToCloudRequest attach_machine_pool_to_cloud_request: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AttachmachinepooltocloudresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'attach_machine_pool_to_cloud_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method attach_machine_pool_to_cloud_api_v2_machine_pools_attach_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'attach_machine_pool_to_cloud_request' is set
        if self.api_client.client_side_validation and ('attach_machine_pool_to_cloud_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['attach_machine_pool_to_cloud_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `attach_machine_pool_to_cloud_request` when calling `attach_machine_pool_to_cloud_api_v2_machine_pools_attach_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'attach_machine_pool_to_cloud_request' in local_var_params:
            body_params = local_var_params['attach_machine_pool_to_cloud_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/machine_pools/attach', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AttachmachinepooltocloudresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ban_organization_api_v2_organizations_organization_id_ban_put(self, organization_id, **kwargs):  # noqa: E501
        """Ban Organization  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ban_organization_api_v2_organizations_organization_id_ban_put(organization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str organization_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.ban_organization_api_v2_organizations_organization_id_ban_put_with_http_info(organization_id, **kwargs)  # noqa: E501

    def ban_organization_api_v2_organizations_organization_id_ban_put_with_http_info(self, organization_id, **kwargs):  # noqa: E501
        """Ban Organization  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ban_organization_api_v2_organizations_organization_id_ban_put_with_http_info(organization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str organization_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'organization_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ban_organization_api_v2_organizations_organization_id_ban_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_id' is set
        if self.api_client.client_side_validation and ('organization_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['organization_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_id` when calling `ban_organization_api_v2_organizations_organization_id_ban_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_id' in local_var_params:
            path_params['organization_id'] = local_var_params['organization_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organizations/{organization_id}/ban', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def batch_create_invitations_api_v2_organization_invitations_batch_create_post(self, create_organization_invitation, **kwargs):  # noqa: E501
        """Batch Create Invitations  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.batch_create_invitations_api_v2_organization_invitations_batch_create_post(create_organization_invitation, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param list[CreateOrganizationInvitation] create_organization_invitation: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: BatchResponseBatchedResultOrganizationInvitationBase
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.batch_create_invitations_api_v2_organization_invitations_batch_create_post_with_http_info(create_organization_invitation, **kwargs)  # noqa: E501

    def batch_create_invitations_api_v2_organization_invitations_batch_create_post_with_http_info(self, create_organization_invitation, **kwargs):  # noqa: E501
        """Batch Create Invitations  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.batch_create_invitations_api_v2_organization_invitations_batch_create_post_with_http_info(create_organization_invitation, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param list[CreateOrganizationInvitation] create_organization_invitation: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(BatchResponseBatchedResultOrganizationInvitationBase, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'create_organization_invitation'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method batch_create_invitations_api_v2_organization_invitations_batch_create_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'create_organization_invitation' is set
        if self.api_client.client_side_validation and ('create_organization_invitation' not in local_var_params or  # noqa: E501
                                                        local_var_params['create_organization_invitation'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `create_organization_invitation` when calling `batch_create_invitations_api_v2_organization_invitations_batch_create_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_organization_invitation' in local_var_params:
            body_params = local_var_params['create_organization_invitation']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organization_invitations/batch_create', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BatchResponseBatchedResultOrganizationInvitationBase',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def batch_get_job_api_v2_decorated_ha_jobs_batch_get_post(self, request_body, **kwargs):  # noqa: E501
        """Batch Get Job  # noqa: E501

        Batch get HA Jobs  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.batch_get_job_api_v2_decorated_ha_jobs_batch_get_post(request_body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param list[str] request_body: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedproductionjobListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.batch_get_job_api_v2_decorated_ha_jobs_batch_get_post_with_http_info(request_body, **kwargs)  # noqa: E501

    def batch_get_job_api_v2_decorated_ha_jobs_batch_get_post_with_http_info(self, request_body, **kwargs):  # noqa: E501
        """Batch Get Job  # noqa: E501

        Batch get HA Jobs  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.batch_get_job_api_v2_decorated_ha_jobs_batch_get_post_with_http_info(request_body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param list[str] request_body: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedproductionjobListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'request_body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method batch_get_job_api_v2_decorated_ha_jobs_batch_get_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'request_body' is set
        if self.api_client.client_side_validation and ('request_body' not in local_var_params or  # noqa: E501
                                                        local_var_params['request_body'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `request_body` when calling `batch_get_job_api_v2_decorated_ha_jobs_batch_get_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'request_body' in local_var_params:
            body_params = local_var_params['request_body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/decorated_ha_jobs/batch_get', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedproductionjobListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def begin_cluster_startup_api_v2_cluster_startups_post(self, **kwargs):  # noqa: E501
        """Begin Cluster Startup  # noqa: E501

        Records a start time for a cluster startup.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.begin_cluster_startup_api_v2_cluster_startups_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ClusterStartup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.begin_cluster_startup_api_v2_cluster_startups_post_with_http_info(**kwargs)  # noqa: E501

    def begin_cluster_startup_api_v2_cluster_startups_post_with_http_info(self, **kwargs):  # noqa: E501
        """Begin Cluster Startup  # noqa: E501

        Records a start time for a cluster startup.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.begin_cluster_startup_api_v2_cluster_startups_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ClusterStartup, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method begin_cluster_startup_api_v2_cluster_startups_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/cluster_startups/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClusterStartup',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def change_password_api_v2_users_change_password_post(self, change_password_params, **kwargs):  # noqa: E501
        """Change Password  # noqa: E501

        Changes user's password if they provide their current password.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.change_password_api_v2_users_change_password_post(change_password_params, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ChangePasswordParams change_password_params: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.change_password_api_v2_users_change_password_post_with_http_info(change_password_params, **kwargs)  # noqa: E501

    def change_password_api_v2_users_change_password_post_with_http_info(self, change_password_params, **kwargs):  # noqa: E501
        """Change Password  # noqa: E501

        Changes user's password if they provide their current password.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.change_password_api_v2_users_change_password_post_with_http_info(change_password_params, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ChangePasswordParams change_password_params: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'change_password_params'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method change_password_api_v2_users_change_password_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'change_password_params' is set
        if self.api_client.client_side_validation and ('change_password_params' not in local_var_params or  # noqa: E501
                                                        local_var_params['change_password_params'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `change_password_params` when calling `change_password_api_v2_users_change_password_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'change_password_params' in local_var_params:
            body_params = local_var_params['change_password_params']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/users/change_password', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def check_availability_api_v2_organizations_check_availability_get(self, organization_name, **kwargs):  # noqa: E501
        """Check Availability  # noqa: E501

        Deprecated because this can leak information about our customers to any unauthenticated person.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.check_availability_api_v2_organizations_check_availability_get(organization_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str organization_name: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: OrganizationavailabilityResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.check_availability_api_v2_organizations_check_availability_get_with_http_info(organization_name, **kwargs)  # noqa: E501

    def check_availability_api_v2_organizations_check_availability_get_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """Check Availability  # noqa: E501

        Deprecated because this can leak information about our customers to any unauthenticated person.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.check_availability_api_v2_organizations_check_availability_get_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str organization_name: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(OrganizationavailabilityResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'organization_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method check_availability_api_v2_organizations_check_availability_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and ('organization_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['organization_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `check_availability_api_v2_organizations_check_availability_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'organization_name' in local_var_params and local_var_params['organization_name'] is not None:  # noqa: E501
            query_params.append(('organization_name', local_var_params['organization_name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organizations/check_availability', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OrganizationavailabilityResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def check_is_feature_flag_on_api_v2_userinfo_check_is_feature_flag_on_get(self, flag_key, **kwargs):  # noqa: E501
        """Check Is Feature Flag On  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.check_is_feature_flag_on_api_v2_userinfo_check_is_feature_flag_on_get(flag_key, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str flag_key: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: FeatureflagresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.check_is_feature_flag_on_api_v2_userinfo_check_is_feature_flag_on_get_with_http_info(flag_key, **kwargs)  # noqa: E501

    def check_is_feature_flag_on_api_v2_userinfo_check_is_feature_flag_on_get_with_http_info(self, flag_key, **kwargs):  # noqa: E501
        """Check Is Feature Flag On  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.check_is_feature_flag_on_api_v2_userinfo_check_is_feature_flag_on_get_with_http_info(flag_key, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str flag_key: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(FeatureflagresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'flag_key'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method check_is_feature_flag_on_api_v2_userinfo_check_is_feature_flag_on_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'flag_key' is set
        if self.api_client.client_side_validation and ('flag_key' not in local_var_params or  # noqa: E501
                                                        local_var_params['flag_key'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `flag_key` when calling `check_is_feature_flag_on_api_v2_userinfo_check_is_feature_flag_on_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'flag_key' in local_var_params and local_var_params['flag_key'] is not None:  # noqa: E501
            query_params.append(('flag_key', local_var_params['flag_key']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/userinfo/check_is_feature_flag_on', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FeatureflagresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def check_one_time_password_api_v2_users_request_otp_token_otp_get(self, otp, **kwargs):  # noqa: E501
        """Check One Time Password  # noqa: E501

        Check if a one time password is valid. Consume it if valid.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.check_one_time_password_api_v2_users_request_otp_token_otp_get(otp, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str otp: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: RequestotpreturnapimodelResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.check_one_time_password_api_v2_users_request_otp_token_otp_get_with_http_info(otp, **kwargs)  # noqa: E501

    def check_one_time_password_api_v2_users_request_otp_token_otp_get_with_http_info(self, otp, **kwargs):  # noqa: E501
        """Check One Time Password  # noqa: E501

        Check if a one time password is valid. Consume it if valid.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.check_one_time_password_api_v2_users_request_otp_token_otp_get_with_http_info(otp, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str otp: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(RequestotpreturnapimodelResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'otp'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method check_one_time_password_api_v2_users_request_otp_token_otp_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'otp' is set
        if self.api_client.client_side_validation and ('otp' not in local_var_params or  # noqa: E501
                                                        local_var_params['otp'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `otp` when calling `check_one_time_password_api_v2_users_request_otp_token_otp_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'otp' in local_var_params:
            path_params['otp'] = local_var_params['otp']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/users/request_otp_token/{otp}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RequestotpreturnapimodelResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cli_api_v2_machines_cli_get(self, **kwargs):  # noqa: E501
        """Cli  # noqa: E501

        Redirects to a URL that can be used to download and install the 'anyscalemachine' CLI.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cli_api_v2_machines_cli_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.cli_api_v2_machines_cli_get_with_http_info(**kwargs)  # noqa: E501

    def cli_api_v2_machines_cli_get_with_http_info(self, **kwargs):  # noqa: E501
        """Cli  # noqa: E501

        Redirects to a URL that can be used to download and install the 'anyscalemachine' CLI.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cli_api_v2_machines_cli_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cli_api_v2_machines_cli_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/machines/cli', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def clone_workspace_api_v2_experimental_workspaces_from_workspace_post(self, clone_experimental_workspace, **kwargs):  # noqa: E501
        """Clone Workspace  # noqa: E501

        Clone a workspace.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.clone_workspace_api_v2_experimental_workspaces_from_workspace_post(clone_experimental_workspace, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CloneExperimentalWorkspace clone_experimental_workspace: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ExperimentalworkspaceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.clone_workspace_api_v2_experimental_workspaces_from_workspace_post_with_http_info(clone_experimental_workspace, **kwargs)  # noqa: E501

    def clone_workspace_api_v2_experimental_workspaces_from_workspace_post_with_http_info(self, clone_experimental_workspace, **kwargs):  # noqa: E501
        """Clone Workspace  # noqa: E501

        Clone a workspace.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.clone_workspace_api_v2_experimental_workspaces_from_workspace_post_with_http_info(clone_experimental_workspace, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CloneExperimentalWorkspace clone_experimental_workspace: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ExperimentalworkspaceResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'clone_experimental_workspace'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method clone_workspace_api_v2_experimental_workspaces_from_workspace_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'clone_experimental_workspace' is set
        if self.api_client.client_side_validation and ('clone_experimental_workspace' not in local_var_params or  # noqa: E501
                                                        local_var_params['clone_experimental_workspace'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `clone_experimental_workspace` when calling `clone_workspace_api_v2_experimental_workspaces_from_workspace_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'clone_experimental_workspace' in local_var_params:
            body_params = local_var_params['clone_experimental_workspace']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/experimental_workspaces/from_workspace', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ExperimentalworkspaceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_aica_endpoint_api_v2_aica_endpoints_post(self, create_aica_endpoint, **kwargs):  # noqa: E501
        """Create Aica Endpoint  # noqa: E501

        Creates an AICA endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_aica_endpoint_api_v2_aica_endpoints_post(create_aica_endpoint, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateAicaEndpoint create_aica_endpoint: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AicaendpointResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_aica_endpoint_api_v2_aica_endpoints_post_with_http_info(create_aica_endpoint, **kwargs)  # noqa: E501

    def create_aica_endpoint_api_v2_aica_endpoints_post_with_http_info(self, create_aica_endpoint, **kwargs):  # noqa: E501
        """Create Aica Endpoint  # noqa: E501

        Creates an AICA endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_aica_endpoint_api_v2_aica_endpoints_post_with_http_info(create_aica_endpoint, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateAicaEndpoint create_aica_endpoint: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AicaendpointResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'create_aica_endpoint'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_aica_endpoint_api_v2_aica_endpoints_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'create_aica_endpoint' is set
        if self.api_client.client_side_validation and ('create_aica_endpoint' not in local_var_params or  # noqa: E501
                                                        local_var_params['create_aica_endpoint'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `create_aica_endpoint` when calling `create_aica_endpoint_api_v2_aica_endpoints_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_aica_endpoint' in local_var_params:
            body_params = local_var_params['create_aica_endpoint']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/aica_endpoints/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AicaendpointResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_api_key_api_v2_users_create_api_key_post(self, api_key_parameters, **kwargs):  # noqa: E501
        """Create Api Key  # noqa: E501

        Create an API Key for use outside of a web context.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_api_key_api_v2_users_create_api_key_post(api_key_parameters, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ApiKeyParameters api_key_parameters: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ServersessiontokenResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_api_key_api_v2_users_create_api_key_post_with_http_info(api_key_parameters, **kwargs)  # noqa: E501

    def create_api_key_api_v2_users_create_api_key_post_with_http_info(self, api_key_parameters, **kwargs):  # noqa: E501
        """Create Api Key  # noqa: E501

        Create an API Key for use outside of a web context.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_api_key_api_v2_users_create_api_key_post_with_http_info(api_key_parameters, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ApiKeyParameters api_key_parameters: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ServersessiontokenResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'api_key_parameters'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_api_key_api_v2_users_create_api_key_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'api_key_parameters' is set
        if self.api_client.client_side_validation and ('api_key_parameters' not in local_var_params or  # noqa: E501
                                                        local_var_params['api_key_parameters'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `api_key_parameters` when calling `create_api_key_api_v2_users_create_api_key_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'api_key_parameters' in local_var_params:
            body_params = local_var_params['api_key_parameters']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/users/create_api_key', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ServersessiontokenResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_application_template_api_v2_application_templates_post(self, create_app_config, **kwargs):  # noqa: E501
        """Create Application Template  # noqa: E501

        Creates a Cluster Environment. Note: cluster_environment is called app_config on the backend api.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_application_template_api_v2_application_templates_post(create_app_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateAppConfig create_app_config: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AppconfigResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_application_template_api_v2_application_templates_post_with_http_info(create_app_config, **kwargs)  # noqa: E501

    def create_application_template_api_v2_application_templates_post_with_http_info(self, create_app_config, **kwargs):  # noqa: E501
        """Create Application Template  # noqa: E501

        Creates a Cluster Environment. Note: cluster_environment is called app_config on the backend api.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_application_template_api_v2_application_templates_post_with_http_info(create_app_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateAppConfig create_app_config: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AppconfigResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'create_app_config'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_application_template_api_v2_application_templates_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'create_app_config' is set
        if self.api_client.client_side_validation and ('create_app_config' not in local_var_params or  # noqa: E501
                                                        local_var_params['create_app_config'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `create_app_config` when calling `create_application_template_api_v2_application_templates_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_app_config' in local_var_params:
            body_params = local_var_params['create_app_config']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/application_templates/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AppconfigResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_bug_report_api_v2_machines_create_bug_report_post(self, body, **kwargs):  # noqa: E501
        """Create Bug Report  # noqa: E501

        Create a machine bug report.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_bug_report_api_v2_machines_create_bug_report_post(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param object body: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CreatebugreportresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_bug_report_api_v2_machines_create_bug_report_post_with_http_info(body, **kwargs)  # noqa: E501

    def create_bug_report_api_v2_machines_create_bug_report_post_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create Bug Report  # noqa: E501

        Create a machine bug report.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_bug_report_api_v2_machines_create_bug_report_post_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param object body: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CreatebugreportresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_bug_report_api_v2_machines_create_bug_report_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in local_var_params or  # noqa: E501
                                                        local_var_params['body'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `create_bug_report_api_v2_machines_create_bug_report_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/machines/create_bug_report', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreatebugreportresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_build_api_v2_builds_post(self, create_build, **kwargs):  # noqa: E501
        """Create Build  # noqa: E501

        Creates and starts a Build. This is a long running operation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_build_api_v2_builds_post(create_build, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateBuild create_build: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: BuildResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_build_api_v2_builds_post_with_http_info(create_build, **kwargs)  # noqa: E501

    def create_build_api_v2_builds_post_with_http_info(self, create_build, **kwargs):  # noqa: E501
        """Create Build  # noqa: E501

        Creates and starts a Build. This is a long running operation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_build_api_v2_builds_post_with_http_info(create_build, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateBuild create_build: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(BuildResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'create_build'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_build_api_v2_builds_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'create_build' is set
        if self.api_client.client_side_validation and ('create_build' not in local_var_params or  # noqa: E501
                                                        local_var_params['create_build'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `create_build` when calling `create_build_api_v2_builds_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_build' in local_var_params:
            body_params = local_var_params['create_build']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/builds/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BuildResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_byod_build_api_v2_builds_byod_post(self, create_byod_build, **kwargs):  # noqa: E501
        """Create Byod Build  # noqa: E501

        Creates a BYOD Build.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_byod_build_api_v2_builds_byod_post(create_byod_build, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateBYODBuild create_byod_build: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: BuildResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_byod_build_api_v2_builds_byod_post_with_http_info(create_byod_build, **kwargs)  # noqa: E501

    def create_byod_build_api_v2_builds_byod_post_with_http_info(self, create_byod_build, **kwargs):  # noqa: E501
        """Create Byod Build  # noqa: E501

        Creates a BYOD Build.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_byod_build_api_v2_builds_byod_post_with_http_info(create_byod_build, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateBYODBuild create_byod_build: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(BuildResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'create_byod_build'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_byod_build_api_v2_builds_byod_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'create_byod_build' is set
        if self.api_client.client_side_validation and ('create_byod_build' not in local_var_params or  # noqa: E501
                                                        local_var_params['create_byod_build'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `create_byod_build` when calling `create_byod_build_api_v2_builds_byod_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_byod_build' in local_var_params:
            body_params = local_var_params['create_byod_build']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/builds/byod', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BuildResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_byod_cluster_environment_api_v2_application_templates_byod_post(self, create_byod_app_config, **kwargs):  # noqa: E501
        """Create Byod Cluster Environment  # noqa: E501

        Creates a BYOD Cluster Environment.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_byod_cluster_environment_api_v2_application_templates_byod_post(create_byod_app_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateBYODAppConfig create_byod_app_config: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AppconfigResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_byod_cluster_environment_api_v2_application_templates_byod_post_with_http_info(create_byod_app_config, **kwargs)  # noqa: E501

    def create_byod_cluster_environment_api_v2_application_templates_byod_post_with_http_info(self, create_byod_app_config, **kwargs):  # noqa: E501
        """Create Byod Cluster Environment  # noqa: E501

        Creates a BYOD Cluster Environment.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_byod_cluster_environment_api_v2_application_templates_byod_post_with_http_info(create_byod_app_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateBYODAppConfig create_byod_app_config: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AppconfigResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'create_byod_app_config'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_byod_cluster_environment_api_v2_application_templates_byod_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'create_byod_app_config' is set
        if self.api_client.client_side_validation and ('create_byod_app_config' not in local_var_params or  # noqa: E501
                                                        local_var_params['create_byod_app_config'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `create_byod_app_config` when calling `create_byod_cluster_environment_api_v2_application_templates_byod_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_byod_app_config' in local_var_params:
            body_params = local_var_params['create_byod_app_config']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/application_templates/byod', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AppconfigResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_cloud_api_v2_clouds_post(self, write_cloud, **kwargs):  # noqa: E501
        """Create Cloud  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_cloud_api_v2_clouds_post(write_cloud, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param WriteCloud write_cloud: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CloudResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_cloud_api_v2_clouds_post_with_http_info(write_cloud, **kwargs)  # noqa: E501

    def create_cloud_api_v2_clouds_post_with_http_info(self, write_cloud, **kwargs):  # noqa: E501
        """Create Cloud  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_cloud_api_v2_clouds_post_with_http_info(write_cloud, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param WriteCloud write_cloud: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CloudResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'write_cloud'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_cloud_api_v2_clouds_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'write_cloud' is set
        if self.api_client.client_side_validation and ('write_cloud' not in local_var_params or  # noqa: E501
                                                        local_var_params['write_cloud'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `write_cloud` when calling `create_cloud_api_v2_clouds_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'write_cloud' in local_var_params:
            body_params = local_var_params['write_cloud']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CloudResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_cloud_collaborator_api_v2_clouds_cloud_id_collaborators_users_post(self, cloud_id, create_cloud_collaborator, **kwargs):  # noqa: E501
        """Create Cloud Collaborator  # noqa: E501

        Give a user in the same organization as auth context who previously did not have any individual permissions for this cloud the designated permissions.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_cloud_collaborator_api_v2_clouds_cloud_id_collaborators_users_post(cloud_id, create_cloud_collaborator, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param CreateCloudCollaborator create_cloud_collaborator: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_cloud_collaborator_api_v2_clouds_cloud_id_collaborators_users_post_with_http_info(cloud_id, create_cloud_collaborator, **kwargs)  # noqa: E501

    def create_cloud_collaborator_api_v2_clouds_cloud_id_collaborators_users_post_with_http_info(self, cloud_id, create_cloud_collaborator, **kwargs):  # noqa: E501
        """Create Cloud Collaborator  # noqa: E501

        Give a user in the same organization as auth context who previously did not have any individual permissions for this cloud the designated permissions.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_cloud_collaborator_api_v2_clouds_cloud_id_collaborators_users_post_with_http_info(cloud_id, create_cloud_collaborator, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param CreateCloudCollaborator create_cloud_collaborator: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id',
            'create_cloud_collaborator'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_cloud_collaborator_api_v2_clouds_cloud_id_collaborators_users_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `create_cloud_collaborator_api_v2_clouds_cloud_id_collaborators_users_post`")  # noqa: E501
        # verify the required parameter 'create_cloud_collaborator' is set
        if self.api_client.client_side_validation and ('create_cloud_collaborator' not in local_var_params or  # noqa: E501
                                                        local_var_params['create_cloud_collaborator'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `create_cloud_collaborator` when calling `create_cloud_collaborator_api_v2_clouds_cloud_id_collaborators_users_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_cloud_collaborator' in local_var_params:
            body_params = local_var_params['create_cloud_collaborator']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds/{cloud_id}/collaborators/users', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_cloud_collaborator_api_v2_projects_project_id_collaborators_cloud_post(self, project_id, **kwargs):  # noqa: E501
        """Create Cloud Collaborator  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_cloud_collaborator_api_v2_projects_project_id_collaborators_cloud_post(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_cloud_collaborator_api_v2_projects_project_id_collaborators_cloud_post_with_http_info(project_id, **kwargs)  # noqa: E501

    def create_cloud_collaborator_api_v2_projects_project_id_collaborators_cloud_post_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """Create Cloud Collaborator  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_cloud_collaborator_api_v2_projects_project_id_collaborators_cloud_post_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_cloud_collaborator_api_v2_projects_project_id_collaborators_cloud_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `create_cloud_collaborator_api_v2_projects_project_id_collaborators_cloud_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in local_var_params:
            path_params['project_id'] = local_var_params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/projects/{project_id}/collaborators/cloud', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_router_post(self, create_cloud_with_cloud_resource, **kwargs):  # noqa: E501
        """Create Cloud With Cloud Resource  # noqa: E501

        Creates a Cloud with CloudResource.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_router_post(create_cloud_with_cloud_resource, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateCloudWithCloudResource create_cloud_with_cloud_resource: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CloudwithcloudresourceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_router_post_with_http_info(create_cloud_with_cloud_resource, **kwargs)  # noqa: E501

    def create_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_router_post_with_http_info(self, create_cloud_with_cloud_resource, **kwargs):  # noqa: E501
        """Create Cloud With Cloud Resource  # noqa: E501

        Creates a Cloud with CloudResource.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_router_post_with_http_info(create_cloud_with_cloud_resource, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateCloudWithCloudResource create_cloud_with_cloud_resource: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CloudwithcloudresourceResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'create_cloud_with_cloud_resource'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_router_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'create_cloud_with_cloud_resource' is set
        if self.api_client.client_side_validation and ('create_cloud_with_cloud_resource' not in local_var_params or  # noqa: E501
                                                        local_var_params['create_cloud_with_cloud_resource'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `create_cloud_with_cloud_resource` when calling `create_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_router_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_cloud_with_cloud_resource' in local_var_params:
            body_params = local_var_params['create_cloud_with_cloud_resource']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds_with_cloud_resource_router/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CloudwithcloudresourceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_compute_template_api_v2_compute_templates_post(self, create_compute_template, **kwargs):  # noqa: E501
        """Create Compute Template  # noqa: E501

        Creates a compute template.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_compute_template_api_v2_compute_templates_post(create_compute_template, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateComputeTemplate create_compute_template: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ComputetemplateResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_compute_template_api_v2_compute_templates_post_with_http_info(create_compute_template, **kwargs)  # noqa: E501

    def create_compute_template_api_v2_compute_templates_post_with_http_info(self, create_compute_template, **kwargs):  # noqa: E501
        """Create Compute Template  # noqa: E501

        Creates a compute template.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_compute_template_api_v2_compute_templates_post_with_http_info(create_compute_template, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateComputeTemplate create_compute_template: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ComputetemplateResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'create_compute_template'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_compute_template_api_v2_compute_templates_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'create_compute_template' is set
        if self.api_client.client_side_validation and ('create_compute_template' not in local_var_params or  # noqa: E501
                                                        local_var_params['create_compute_template'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `create_compute_template` when calling `create_compute_template_api_v2_compute_templates_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_compute_template' in local_var_params:
            body_params = local_var_params['create_compute_template']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/compute_templates/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ComputetemplateResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_connect_session_api_v2_sessions_create_connect_session_post(self, create_session_in_db, **kwargs):  # noqa: E501
        """Create Connect Session  # noqa: E501

        Creates a session for anyscale connect.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_connect_session_api_v2_sessions_create_connect_session_post(create_session_in_db, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateSessionInDb create_session_in_db: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: SessionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_connect_session_api_v2_sessions_create_connect_session_post_with_http_info(create_session_in_db, **kwargs)  # noqa: E501

    def create_connect_session_api_v2_sessions_create_connect_session_post_with_http_info(self, create_session_in_db, **kwargs):  # noqa: E501
        """Create Connect Session  # noqa: E501

        Creates a session for anyscale connect.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_connect_session_api_v2_sessions_create_connect_session_post_with_http_info(create_session_in_db, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateSessionInDb create_session_in_db: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(SessionResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'create_session_in_db'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_connect_session_api_v2_sessions_create_connect_session_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'create_session_in_db' is set
        if self.api_client.client_side_validation and ('create_session_in_db' not in local_var_params or  # noqa: E501
                                                        local_var_params['create_session_in_db'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `create_session_in_db` when calling `create_connect_session_api_v2_sessions_create_connect_session_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_session_in_db' in local_var_params:
            body_params = local_var_params['create_session_in_db']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/sessions/create_connect_session', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SessionResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_endpoint_user_for_org_api_v2_organizations_organization_id_create_endpoint_user_post(self, organization_id, **kwargs):  # noqa: E501
        """Create Endpoint User For Org  # noqa: E501

        Converts an existing console org to an OA org with access to endpoints features by creating an endpoints user account for the organization.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_endpoint_user_for_org_api_v2_organizations_organization_id_create_endpoint_user_post(organization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str organization_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_endpoint_user_for_org_api_v2_organizations_organization_id_create_endpoint_user_post_with_http_info(organization_id, **kwargs)  # noqa: E501

    def create_endpoint_user_for_org_api_v2_organizations_organization_id_create_endpoint_user_post_with_http_info(self, organization_id, **kwargs):  # noqa: E501
        """Create Endpoint User For Org  # noqa: E501

        Converts an existing console org to an OA org with access to endpoints features by creating an endpoints user account for the organization.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_endpoint_user_for_org_api_v2_organizations_organization_id_create_endpoint_user_post_with_http_info(organization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str organization_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'organization_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_endpoint_user_for_org_api_v2_organizations_organization_id_create_endpoint_user_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_id' is set
        if self.api_client.client_side_validation and ('organization_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['organization_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_id` when calling `create_endpoint_user_for_org_api_v2_organizations_organization_id_create_endpoint_user_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_id' in local_var_params:
            path_params['organization_id'] = local_var_params['organization_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organizations/{organization_id}/create_endpoint_user', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_fine_tuning_job_api_v2_fine_tuning_jobs_create_post(self, create_fine_tuning_job_product_request, **kwargs):  # noqa: E501
        """Create Fine Tuning Job  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_fine_tuning_job_api_v2_fine_tuning_jobs_create_post(create_fine_tuning_job_product_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateFineTuningJobProductRequest create_fine_tuning_job_product_request: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PlatformfinetuningjobResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_fine_tuning_job_api_v2_fine_tuning_jobs_create_post_with_http_info(create_fine_tuning_job_product_request, **kwargs)  # noqa: E501

    def create_fine_tuning_job_api_v2_fine_tuning_jobs_create_post_with_http_info(self, create_fine_tuning_job_product_request, **kwargs):  # noqa: E501
        """Create Fine Tuning Job  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_fine_tuning_job_api_v2_fine_tuning_jobs_create_post_with_http_info(create_fine_tuning_job_product_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateFineTuningJobProductRequest create_fine_tuning_job_product_request: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PlatformfinetuningjobResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'create_fine_tuning_job_product_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_fine_tuning_job_api_v2_fine_tuning_jobs_create_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'create_fine_tuning_job_product_request' is set
        if self.api_client.client_side_validation and ('create_fine_tuning_job_product_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['create_fine_tuning_job_product_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `create_fine_tuning_job_product_request` when calling `create_fine_tuning_job_api_v2_fine_tuning_jobs_create_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_fine_tuning_job_product_request' in local_var_params:
            body_params = local_var_params['create_fine_tuning_job_product_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/fine_tuning/jobs/create', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PlatformfinetuningjobResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_invitation_api_v2_organization_invitations_post(self, create_organization_invitation, **kwargs):  # noqa: E501
        """Create Invitation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_invitation_api_v2_organization_invitations_post(create_organization_invitation, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateOrganizationInvitation create_organization_invitation: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: OrganizationinvitationbaseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_invitation_api_v2_organization_invitations_post_with_http_info(create_organization_invitation, **kwargs)  # noqa: E501

    def create_invitation_api_v2_organization_invitations_post_with_http_info(self, create_organization_invitation, **kwargs):  # noqa: E501
        """Create Invitation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_invitation_api_v2_organization_invitations_post_with_http_info(create_organization_invitation, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateOrganizationInvitation create_organization_invitation: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(OrganizationinvitationbaseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'create_organization_invitation'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_invitation_api_v2_organization_invitations_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'create_organization_invitation' is set
        if self.api_client.client_side_validation and ('create_organization_invitation' not in local_var_params or  # noqa: E501
                                                        local_var_params['create_organization_invitation'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `create_organization_invitation` when calling `create_invitation_api_v2_organization_invitations_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_organization_invitation' in local_var_params:
            body_params = local_var_params['create_organization_invitation']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organization_invitations/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OrganizationinvitationbaseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_job_api_v2_decorated_ha_jobs_create_post(self, create_internal_production_job, **kwargs):  # noqa: E501
        """Create Job  # noqa: E501

        Create an HA job  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_job_api_v2_decorated_ha_jobs_create_post(create_internal_production_job, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateInternalProductionJob create_internal_production_job: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InternalproductionjobResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_job_api_v2_decorated_ha_jobs_create_post_with_http_info(create_internal_production_job, **kwargs)  # noqa: E501

    def create_job_api_v2_decorated_ha_jobs_create_post_with_http_info(self, create_internal_production_job, **kwargs):  # noqa: E501
        """Create Job  # noqa: E501

        Create an HA job  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_job_api_v2_decorated_ha_jobs_create_post_with_http_info(create_internal_production_job, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateInternalProductionJob create_internal_production_job: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InternalproductionjobResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'create_internal_production_job'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_job_api_v2_decorated_ha_jobs_create_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'create_internal_production_job' is set
        if self.api_client.client_side_validation and ('create_internal_production_job' not in local_var_params or  # noqa: E501
                                                        local_var_params['create_internal_production_job'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `create_internal_production_job` when calling `create_job_api_v2_decorated_ha_jobs_create_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_internal_production_job' in local_var_params:
            body_params = local_var_params['create_internal_production_job']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/decorated_ha_jobs/create', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InternalproductionjobResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_machine_api_v2_machines_create_post(self, create_machine_request, **kwargs):  # noqa: E501
        """Create Machine  # noqa: E501

        Create a machine to add it to a machine pool.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_machine_api_v2_machines_create_post(create_machine_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateMachineRequest create_machine_request: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CreatemachineresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_machine_api_v2_machines_create_post_with_http_info(create_machine_request, **kwargs)  # noqa: E501

    def create_machine_api_v2_machines_create_post_with_http_info(self, create_machine_request, **kwargs):  # noqa: E501
        """Create Machine  # noqa: E501

        Create a machine to add it to a machine pool.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_machine_api_v2_machines_create_post_with_http_info(create_machine_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateMachineRequest create_machine_request: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CreatemachineresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'create_machine_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_machine_api_v2_machines_create_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'create_machine_request' is set
        if self.api_client.client_side_validation and ('create_machine_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['create_machine_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `create_machine_request` when calling `create_machine_api_v2_machines_create_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_machine_request' in local_var_params:
            body_params = local_var_params['create_machine_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/machines/create', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreatemachineresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_machine_pool_api_v2_machine_pools_create_post(self, create_machine_pool_request, **kwargs):  # noqa: E501
        """Create Machine Pool  # noqa: E501

        Creates a machine pool.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_machine_pool_api_v2_machine_pools_create_post(create_machine_pool_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateMachinePoolRequest create_machine_pool_request: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CreatemachinepoolresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_machine_pool_api_v2_machine_pools_create_post_with_http_info(create_machine_pool_request, **kwargs)  # noqa: E501

    def create_machine_pool_api_v2_machine_pools_create_post_with_http_info(self, create_machine_pool_request, **kwargs):  # noqa: E501
        """Create Machine Pool  # noqa: E501

        Creates a machine pool.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_machine_pool_api_v2_machine_pools_create_post_with_http_info(create_machine_pool_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateMachinePoolRequest create_machine_pool_request: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CreatemachinepoolresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'create_machine_pool_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_machine_pool_api_v2_machine_pools_create_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'create_machine_pool_request' is set
        if self.api_client.client_side_validation and ('create_machine_pool_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['create_machine_pool_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `create_machine_pool_request` when calling `create_machine_pool_api_v2_machine_pools_create_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_machine_pool_request' in local_var_params:
            body_params = local_var_params['create_machine_pool_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/machine_pools/create', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreatemachinepoolresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_new_session_api_v2_sessions_create_new_session_post(self, create_session_from_snapshot_options, **kwargs):  # noqa: E501
        """Create New Session  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_new_session_api_v2_sessions_create_new_session_post(create_session_from_snapshot_options, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateSessionFromSnapshotOptions create_session_from_snapshot_options: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CreatesessionresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_new_session_api_v2_sessions_create_new_session_post_with_http_info(create_session_from_snapshot_options, **kwargs)  # noqa: E501

    def create_new_session_api_v2_sessions_create_new_session_post_with_http_info(self, create_session_from_snapshot_options, **kwargs):  # noqa: E501
        """Create New Session  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_new_session_api_v2_sessions_create_new_session_post_with_http_info(create_session_from_snapshot_options, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateSessionFromSnapshotOptions create_session_from_snapshot_options: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CreatesessionresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'create_session_from_snapshot_options'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_new_session_api_v2_sessions_create_new_session_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'create_session_from_snapshot_options' is set
        if self.api_client.client_side_validation and ('create_session_from_snapshot_options' not in local_var_params or  # noqa: E501
                                                        local_var_params['create_session_from_snapshot_options'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `create_session_from_snapshot_options` when calling `create_new_session_api_v2_sessions_create_new_session_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_session_from_snapshot_options' in local_var_params:
            body_params = local_var_params['create_session_from_snapshot_options']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/sessions/create_new_session', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreatesessionresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_one_time_password_api_v2_users_create_otp_token_get(self, **kwargs):  # noqa: E501
        """Create One Time Password  # noqa: E501

        Create a one time password token and return URL  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_one_time_password_api_v2_users_create_otp_token_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int duration_seconds:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CreateotpreturnapimodelResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_one_time_password_api_v2_users_create_otp_token_get_with_http_info(**kwargs)  # noqa: E501

    def create_one_time_password_api_v2_users_create_otp_token_get_with_http_info(self, **kwargs):  # noqa: E501
        """Create One Time Password  # noqa: E501

        Create a one time password token and return URL  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_one_time_password_api_v2_users_create_otp_token_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int duration_seconds:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CreateotpreturnapimodelResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'duration_seconds'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_one_time_password_api_v2_users_create_otp_token_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'duration_seconds' in local_var_params and local_var_params['duration_seconds'] is not None:  # noqa: E501
            query_params.append(('duration_seconds', local_var_params['duration_seconds']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/users/create_otp_token', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreateotpreturnapimodelResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_or_update_job_api_v2_experimental_cron_jobs_put(self, create_schedule, **kwargs):  # noqa: E501
        """Create Or Update Job  # noqa: E501

        Create or update a CRON Job  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_or_update_job_api_v2_experimental_cron_jobs_put(create_schedule, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateSchedule create_schedule: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedscheduleResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_or_update_job_api_v2_experimental_cron_jobs_put_with_http_info(create_schedule, **kwargs)  # noqa: E501

    def create_or_update_job_api_v2_experimental_cron_jobs_put_with_http_info(self, create_schedule, **kwargs):  # noqa: E501
        """Create Or Update Job  # noqa: E501

        Create or update a CRON Job  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_or_update_job_api_v2_experimental_cron_jobs_put_with_http_info(create_schedule, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateSchedule create_schedule: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedscheduleResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'create_schedule'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_or_update_job_api_v2_experimental_cron_jobs_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'create_schedule' is set
        if self.api_client.client_side_validation and ('create_schedule' not in local_var_params or  # noqa: E501
                                                        local_var_params['create_schedule'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `create_schedule` when calling `create_or_update_job_api_v2_experimental_cron_jobs_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_schedule' in local_var_params:
            body_params = local_var_params['create_schedule']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/experimental_cron_jobs/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedscheduleResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_organization_collaborator_api_v2_projects_project_id_collaborators_organization_post(self, project_id, **kwargs):  # noqa: E501
        """Create Organization Collaborator  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_organization_collaborator_api_v2_projects_project_id_collaborators_organization_post(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_organization_collaborator_api_v2_projects_project_id_collaborators_organization_post_with_http_info(project_id, **kwargs)  # noqa: E501

    def create_organization_collaborator_api_v2_projects_project_id_collaborators_organization_post_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """Create Organization Collaborator  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_organization_collaborator_api_v2_projects_project_id_collaborators_organization_post_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_organization_collaborator_api_v2_projects_project_id_collaborators_organization_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `create_organization_collaborator_api_v2_projects_project_id_collaborators_organization_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in local_var_params:
            path_params['project_id'] = local_var_params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/projects/{project_id}/collaborators/organization', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_project_api_v2_projects_post(self, write_project, **kwargs):  # noqa: E501
        """Create Project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_project_api_v2_projects_post(write_project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param WriteProject write_project: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ProjectbaseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_project_api_v2_projects_post_with_http_info(write_project, **kwargs)  # noqa: E501

    def create_project_api_v2_projects_post_with_http_info(self, write_project, **kwargs):  # noqa: E501
        """Create Project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_project_api_v2_projects_post_with_http_info(write_project, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param WriteProject write_project: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ProjectbaseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'write_project'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_project_api_v2_projects_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'write_project' is set
        if self.api_client.client_side_validation and ('write_project' not in local_var_params or  # noqa: E501
                                                        local_var_params['write_project'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `write_project` when calling `create_project_api_v2_projects_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'write_project' in local_var_params:
            body_params = local_var_params['write_project']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/projects/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ProjectbaseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_project_collaborator_api_v2_projects_project_id_collaborators_users_post(self, project_id, create_user_project_collaborator, **kwargs):  # noqa: E501
        """Create Project Collaborator  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_project_collaborator_api_v2_projects_project_id_collaborators_users_post(project_id, create_user_project_collaborator, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: (required)
        :param CreateUserProjectCollaborator create_user_project_collaborator: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_project_collaborator_api_v2_projects_project_id_collaborators_users_post_with_http_info(project_id, create_user_project_collaborator, **kwargs)  # noqa: E501

    def create_project_collaborator_api_v2_projects_project_id_collaborators_users_post_with_http_info(self, project_id, create_user_project_collaborator, **kwargs):  # noqa: E501
        """Create Project Collaborator  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_project_collaborator_api_v2_projects_project_id_collaborators_users_post_with_http_info(project_id, create_user_project_collaborator, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: (required)
        :param CreateUserProjectCollaborator create_user_project_collaborator: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project_id',
            'create_user_project_collaborator'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_project_collaborator_api_v2_projects_project_id_collaborators_users_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `create_project_collaborator_api_v2_projects_project_id_collaborators_users_post`")  # noqa: E501
        # verify the required parameter 'create_user_project_collaborator' is set
        if self.api_client.client_side_validation and ('create_user_project_collaborator' not in local_var_params or  # noqa: E501
                                                        local_var_params['create_user_project_collaborator'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `create_user_project_collaborator` when calling `create_project_collaborator_api_v2_projects_project_id_collaborators_users_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in local_var_params:
            path_params['project_id'] = local_var_params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_user_project_collaborator' in local_var_params:
            body_params = local_var_params['create_user_project_collaborator']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/projects/{project_id}/collaborators/users', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_service_account_api_v2_users_service_accounts_post(self, name, **kwargs):  # noqa: E501
        """Create Service Account  # noqa: E501

        Create a service account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_service_account_api_v2_users_service_accounts_post(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str name: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AnyscaleserviceaccountResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_service_account_api_v2_users_service_accounts_post_with_http_info(name, **kwargs)  # noqa: E501

    def create_service_account_api_v2_users_service_accounts_post_with_http_info(self, name, **kwargs):  # noqa: E501
        """Create Service Account  # noqa: E501

        Create a service account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_service_account_api_v2_users_service_accounts_post_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str name: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AnyscaleserviceaccountResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_service_account_api_v2_users_service_accounts_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'name' is set
        if self.api_client.client_side_validation and ('name' not in local_var_params or  # noqa: E501
                                                        local_var_params['name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `name` when calling `create_service_account_api_v2_users_service_accounts_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
            query_params.append(('name', local_var_params['name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/users/service_accounts', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AnyscaleserviceaccountResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_session_command_api_v2_sessions_session_id_create_session_command_post(self, session_id, external_terminal_command, **kwargs):  # noqa: E501
        """Create Session Command  # noqa: E501

        Create a shell command entry. This command was executed by external source such as the webterminal  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_session_command_api_v2_sessions_session_id_create_session_command_post(session_id, external_terminal_command, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param ExternalTerminalCommand external_terminal_command: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: SessioncommandidResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_session_command_api_v2_sessions_session_id_create_session_command_post_with_http_info(session_id, external_terminal_command, **kwargs)  # noqa: E501

    def create_session_command_api_v2_sessions_session_id_create_session_command_post_with_http_info(self, session_id, external_terminal_command, **kwargs):  # noqa: E501
        """Create Session Command  # noqa: E501

        Create a shell command entry. This command was executed by external source such as the webterminal  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_session_command_api_v2_sessions_session_id_create_session_command_post_with_http_info(session_id, external_terminal_command, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param ExternalTerminalCommand external_terminal_command: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(SessioncommandidResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'session_id',
            'external_terminal_command'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_session_command_api_v2_sessions_session_id_create_session_command_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'session_id' is set
        if self.api_client.client_side_validation and ('session_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_id` when calling `create_session_command_api_v2_sessions_session_id_create_session_command_post`")  # noqa: E501
        # verify the required parameter 'external_terminal_command' is set
        if self.api_client.client_side_validation and ('external_terminal_command' not in local_var_params or  # noqa: E501
                                                        local_var_params['external_terminal_command'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `external_terminal_command` when calling `create_session_command_api_v2_sessions_session_id_create_session_command_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'session_id' in local_var_params:
            path_params['session_id'] = local_var_params['session_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'external_terminal_command' in local_var_params:
            body_params = local_var_params['external_terminal_command']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/sessions/{session_id}/create_session_command', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SessioncommandidResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_web_terminal_api_v2_sessions_session_id_web_terminals_post(self, session_id, **kwargs):  # noqa: E501
        """Create Web Terminal  # noqa: E501

        DEPRECATED: This API is no deprecated and will not be supported in Anyscale 2.0  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_web_terminal_api_v2_sessions_session_id_web_terminals_post(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: WebterminalResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_web_terminal_api_v2_sessions_session_id_web_terminals_post_with_http_info(session_id, **kwargs)  # noqa: E501

    def create_web_terminal_api_v2_sessions_session_id_web_terminals_post_with_http_info(self, session_id, **kwargs):  # noqa: E501
        """Create Web Terminal  # noqa: E501

        DEPRECATED: This API is no deprecated and will not be supported in Anyscale 2.0  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_web_terminal_api_v2_sessions_session_id_web_terminals_post_with_http_info(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(WebterminalResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'session_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_web_terminal_api_v2_sessions_session_id_web_terminals_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'session_id' is set
        if self.api_client.client_side_validation and ('session_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_id` when calling `create_web_terminal_api_v2_sessions_session_id_web_terminals_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'session_id' in local_var_params:
            path_params['session_id'] = local_var_params['session_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/sessions/{session_id}/web_terminals', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='WebterminalResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_workspace_api_v2_experimental_workspaces_post(self, create_experimental_workspace, **kwargs):  # noqa: E501
        """Create Workspace  # noqa: E501

        Creates a Workspace.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_workspace_api_v2_experimental_workspaces_post(create_experimental_workspace, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateExperimentalWorkspace create_experimental_workspace: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ExperimentalworkspaceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_workspace_api_v2_experimental_workspaces_post_with_http_info(create_experimental_workspace, **kwargs)  # noqa: E501

    def create_workspace_api_v2_experimental_workspaces_post_with_http_info(self, create_experimental_workspace, **kwargs):  # noqa: E501
        """Create Workspace  # noqa: E501

        Creates a Workspace.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_workspace_api_v2_experimental_workspaces_post_with_http_info(create_experimental_workspace, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateExperimentalWorkspace create_experimental_workspace: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ExperimentalworkspaceResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'create_experimental_workspace'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_workspace_api_v2_experimental_workspaces_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'create_experimental_workspace' is set
        if self.api_client.client_side_validation and ('create_experimental_workspace' not in local_var_params or  # noqa: E501
                                                        local_var_params['create_experimental_workspace'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `create_experimental_workspace` when calling `create_workspace_api_v2_experimental_workspaces_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_experimental_workspace' in local_var_params:
            body_params = local_var_params['create_experimental_workspace']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/experimental_workspaces/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ExperimentalworkspaceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_workspace_from_job_api_v2_experimental_workspaces_from_job_post(self, create_experimental_workspace_from_job, **kwargs):  # noqa: E501
        """Create Workspace From Job  # noqa: E501

        Creates a Workspace from a job.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_workspace_from_job_api_v2_experimental_workspaces_from_job_post(create_experimental_workspace_from_job, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateExperimentalWorkspaceFromJob create_experimental_workspace_from_job: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ExperimentalworkspaceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_workspace_from_job_api_v2_experimental_workspaces_from_job_post_with_http_info(create_experimental_workspace_from_job, **kwargs)  # noqa: E501

    def create_workspace_from_job_api_v2_experimental_workspaces_from_job_post_with_http_info(self, create_experimental_workspace_from_job, **kwargs):  # noqa: E501
        """Create Workspace From Job  # noqa: E501

        Creates a Workspace from a job.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_workspace_from_job_api_v2_experimental_workspaces_from_job_post_with_http_info(create_experimental_workspace_from_job, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateExperimentalWorkspaceFromJob create_experimental_workspace_from_job: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ExperimentalworkspaceResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'create_experimental_workspace_from_job'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_workspace_from_job_api_v2_experimental_workspaces_from_job_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'create_experimental_workspace_from_job' is set
        if self.api_client.client_side_validation and ('create_experimental_workspace_from_job' not in local_var_params or  # noqa: E501
                                                        local_var_params['create_experimental_workspace_from_job'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `create_experimental_workspace_from_job` when calling `create_workspace_from_job_api_v2_experimental_workspaces_from_job_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_experimental_workspace_from_job' in local_var_params:
            body_params = local_var_params['create_experimental_workspace_from_job']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/experimental_workspaces/from_job', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ExperimentalworkspaceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_workspace_from_template_api_v2_experimental_workspaces_from_template_post(self, create_workspace_from_template, **kwargs):  # noqa: E501
        """Create Workspace From Template  # noqa: E501

        Create workspace from template  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_workspace_from_template_api_v2_experimental_workspaces_from_template_post(create_workspace_from_template, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateWorkspaceFromTemplate create_workspace_from_template: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ExperimentalworkspaceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_workspace_from_template_api_v2_experimental_workspaces_from_template_post_with_http_info(create_workspace_from_template, **kwargs)  # noqa: E501

    def create_workspace_from_template_api_v2_experimental_workspaces_from_template_post_with_http_info(self, create_workspace_from_template, **kwargs):  # noqa: E501
        """Create Workspace From Template  # noqa: E501

        Create workspace from template  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_workspace_from_template_api_v2_experimental_workspaces_from_template_post_with_http_info(create_workspace_from_template, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateWorkspaceFromTemplate create_workspace_from_template: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ExperimentalworkspaceResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'create_workspace_from_template'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_workspace_from_template_api_v2_experimental_workspaces_from_template_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'create_workspace_from_template' is set
        if self.api_client.client_side_validation and ('create_workspace_from_template' not in local_var_params or  # noqa: E501
                                                        local_var_params['create_workspace_from_template'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `create_workspace_from_template` when calling `create_workspace_from_template_api_v2_experimental_workspaces_from_template_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_workspace_from_template' in local_var_params:
            body_params = local_var_params['create_workspace_from_template']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/experimental_workspaces/from_template', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ExperimentalworkspaceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_application_template_api_v2_application_templates_application_template_id_delete(self, application_template_id, **kwargs):  # noqa: E501
        """Delete Application Template  # noqa: E501

        Deletes an Application Template. Note: application_template is called app_config on the backend api.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_application_template_api_v2_application_templates_application_template_id_delete(application_template_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str application_template_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_application_template_api_v2_application_templates_application_template_id_delete_with_http_info(application_template_id, **kwargs)  # noqa: E501

    def delete_application_template_api_v2_application_templates_application_template_id_delete_with_http_info(self, application_template_id, **kwargs):  # noqa: E501
        """Delete Application Template  # noqa: E501

        Deletes an Application Template. Note: application_template is called app_config on the backend api.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_application_template_api_v2_application_templates_application_template_id_delete_with_http_info(application_template_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str application_template_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'application_template_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_application_template_api_v2_application_templates_application_template_id_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_template_id' is set
        if self.api_client.client_side_validation and ('application_template_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_template_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_template_id` when calling `delete_application_template_api_v2_application_templates_application_template_id_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_template_id' in local_var_params:
            path_params['application_template_id'] = local_var_params['application_template_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/application_templates/{application_template_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_cloud_api_v2_clouds_cloud_id_delete(self, cloud_id, **kwargs):  # noqa: E501
        """Delete Cloud  # noqa: E501

        Deletes a Cloud. Will delete all clusters that are using this cloud. If any of those clusters are not terminated, this call will fail.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_cloud_api_v2_clouds_cloud_id_delete(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_cloud_api_v2_clouds_cloud_id_delete_with_http_info(cloud_id, **kwargs)  # noqa: E501

    def delete_cloud_api_v2_clouds_cloud_id_delete_with_http_info(self, cloud_id, **kwargs):  # noqa: E501
        """Delete Cloud  # noqa: E501

        Deletes a Cloud. Will delete all clusters that are using this cloud. If any of those clusters are not terminated, this call will fail.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_cloud_api_v2_clouds_cloud_id_delete_with_http_info(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_cloud_api_v2_clouds_cloud_id_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `delete_cloud_api_v2_clouds_cloud_id_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds/{cloud_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_cloud_collaborator_api_v2_clouds_cloud_id_collaborators_identity_id_delete(self, cloud_id, identity_id, **kwargs):  # noqa: E501
        """Delete Cloud Collaborator  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_cloud_collaborator_api_v2_clouds_cloud_id_collaborators_identity_id_delete(cloud_id, identity_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param str identity_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_cloud_collaborator_api_v2_clouds_cloud_id_collaborators_identity_id_delete_with_http_info(cloud_id, identity_id, **kwargs)  # noqa: E501

    def delete_cloud_collaborator_api_v2_clouds_cloud_id_collaborators_identity_id_delete_with_http_info(self, cloud_id, identity_id, **kwargs):  # noqa: E501
        """Delete Cloud Collaborator  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_cloud_collaborator_api_v2_clouds_cloud_id_collaborators_identity_id_delete_with_http_info(cloud_id, identity_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param str identity_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id',
            'identity_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_cloud_collaborator_api_v2_clouds_cloud_id_collaborators_identity_id_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `delete_cloud_collaborator_api_v2_clouds_cloud_id_collaborators_identity_id_delete`")  # noqa: E501
        # verify the required parameter 'identity_id' is set
        if self.api_client.client_side_validation and ('identity_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['identity_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `identity_id` when calling `delete_cloud_collaborator_api_v2_clouds_cloud_id_collaborators_identity_id_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501
        if 'identity_id' in local_var_params:
            path_params['identity_id'] = local_var_params['identity_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds/{cloud_id}/collaborators/{identity_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_compute_template_api_v2_compute_templates_template_id_delete(self, template_id, **kwargs):  # noqa: E501
        """Delete Compute Template  # noqa: E501

        Deletes a compute template.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_compute_template_api_v2_compute_templates_template_id_delete(template_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str template_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_compute_template_api_v2_compute_templates_template_id_delete_with_http_info(template_id, **kwargs)  # noqa: E501

    def delete_compute_template_api_v2_compute_templates_template_id_delete_with_http_info(self, template_id, **kwargs):  # noqa: E501
        """Delete Compute Template  # noqa: E501

        Deletes a compute template.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_compute_template_api_v2_compute_templates_template_id_delete_with_http_info(template_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str template_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'template_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_compute_template_api_v2_compute_templates_template_id_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'template_id' is set
        if self.api_client.client_side_validation and ('template_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['template_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `template_id` when calling `delete_compute_template_api_v2_compute_templates_template_id_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'template_id' in local_var_params:
            path_params['template_id'] = local_var_params['template_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/compute_templates/{template_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_hosted_cloud_api_v2_clouds_hosted_cloud_id_delete(self, cloud_id, **kwargs):  # noqa: E501
        """Delete Hosted Cloud  # noqa: E501

        Deletes a hosted cloud.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_hosted_cloud_api_v2_clouds_hosted_cloud_id_delete(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_hosted_cloud_api_v2_clouds_hosted_cloud_id_delete_with_http_info(cloud_id, **kwargs)  # noqa: E501

    def delete_hosted_cloud_api_v2_clouds_hosted_cloud_id_delete_with_http_info(self, cloud_id, **kwargs):  # noqa: E501
        """Delete Hosted Cloud  # noqa: E501

        Deletes a hosted cloud.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_hosted_cloud_api_v2_clouds_hosted_cloud_id_delete_with_http_info(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_hosted_cloud_api_v2_clouds_hosted_cloud_id_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `delete_hosted_cloud_api_v2_clouds_hosted_cloud_id_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds/hosted/{cloud_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_machine_api_v2_machines_delete_post(self, delete_machine_request, **kwargs):  # noqa: E501
        """Delete Machine  # noqa: E501

        Delete a machine from a machine pool.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_machine_api_v2_machines_delete_post(delete_machine_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param DeleteMachineRequest delete_machine_request: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CreatemachineresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_machine_api_v2_machines_delete_post_with_http_info(delete_machine_request, **kwargs)  # noqa: E501

    def delete_machine_api_v2_machines_delete_post_with_http_info(self, delete_machine_request, **kwargs):  # noqa: E501
        """Delete Machine  # noqa: E501

        Delete a machine from a machine pool.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_machine_api_v2_machines_delete_post_with_http_info(delete_machine_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param DeleteMachineRequest delete_machine_request: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CreatemachineresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'delete_machine_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_machine_api_v2_machines_delete_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'delete_machine_request' is set
        if self.api_client.client_side_validation and ('delete_machine_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['delete_machine_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `delete_machine_request` when calling `delete_machine_api_v2_machines_delete_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'delete_machine_request' in local_var_params:
            body_params = local_var_params['delete_machine_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/machines/delete', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreatemachineresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_machine_pool_api_v2_machine_pools_delete_post(self, delete_machine_pool_request, **kwargs):  # noqa: E501
        """Delete Machine Pool  # noqa: E501

        Deletes a machine pool.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_machine_pool_api_v2_machine_pools_delete_post(delete_machine_pool_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param DeleteMachinePoolRequest delete_machine_pool_request: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DeletemachinepoolresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_machine_pool_api_v2_machine_pools_delete_post_with_http_info(delete_machine_pool_request, **kwargs)  # noqa: E501

    def delete_machine_pool_api_v2_machine_pools_delete_post_with_http_info(self, delete_machine_pool_request, **kwargs):  # noqa: E501
        """Delete Machine Pool  # noqa: E501

        Deletes a machine pool.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_machine_pool_api_v2_machine_pools_delete_post_with_http_info(delete_machine_pool_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param DeleteMachinePoolRequest delete_machine_pool_request: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DeletemachinepoolresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'delete_machine_pool_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_machine_pool_api_v2_machine_pools_delete_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'delete_machine_pool_request' is set
        if self.api_client.client_side_validation and ('delete_machine_pool_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['delete_machine_pool_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `delete_machine_pool_request` when calling `delete_machine_pool_api_v2_machine_pools_delete_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'delete_machine_pool_request' in local_var_params:
            body_params = local_var_params['delete_machine_pool_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/machine_pools/delete', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeletemachinepoolresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_project_api_v2_projects_project_id_delete(self, project_id, **kwargs):  # noqa: E501
        """Delete Project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_project_api_v2_projects_project_id_delete(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_project_api_v2_projects_project_id_delete_with_http_info(project_id, **kwargs)  # noqa: E501

    def delete_project_api_v2_projects_project_id_delete_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """Delete Project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_project_api_v2_projects_project_id_delete_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_project_api_v2_projects_project_id_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `delete_project_api_v2_projects_project_id_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in local_var_params:
            path_params['project_id'] = local_var_params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/projects/{project_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_project_collaborator_api_v2_projects_project_id_collaborators_role_or_identity_id_delete(self, project_id, role_or_identity_id, **kwargs):  # noqa: E501
        """Delete Project Collaborator  # noqa: E501

        Delete a collaborator from a project  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_project_collaborator_api_v2_projects_project_id_collaborators_role_or_identity_id_delete(project_id, role_or_identity_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: (required)
        :param str role_or_identity_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_project_collaborator_api_v2_projects_project_id_collaborators_role_or_identity_id_delete_with_http_info(project_id, role_or_identity_id, **kwargs)  # noqa: E501

    def delete_project_collaborator_api_v2_projects_project_id_collaborators_role_or_identity_id_delete_with_http_info(self, project_id, role_or_identity_id, **kwargs):  # noqa: E501
        """Delete Project Collaborator  # noqa: E501

        Delete a collaborator from a project  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_project_collaborator_api_v2_projects_project_id_collaborators_role_or_identity_id_delete_with_http_info(project_id, role_or_identity_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: (required)
        :param str role_or_identity_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project_id',
            'role_or_identity_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_project_collaborator_api_v2_projects_project_id_collaborators_role_or_identity_id_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `delete_project_collaborator_api_v2_projects_project_id_collaborators_role_or_identity_id_delete`")  # noqa: E501
        # verify the required parameter 'role_or_identity_id' is set
        if self.api_client.client_side_validation and ('role_or_identity_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['role_or_identity_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `role_or_identity_id` when calling `delete_project_collaborator_api_v2_projects_project_id_collaborators_role_or_identity_id_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in local_var_params:
            path_params['project_id'] = local_var_params['project_id']  # noqa: E501
        if 'role_or_identity_id' in local_var_params:
            path_params['role_or_identity_id'] = local_var_params['role_or_identity_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/projects/{project_id}/collaborators/{role_or_identity_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_session_api_v2_sessions_session_id_delete(self, session_id, **kwargs):  # noqa: E501
        """Delete Session  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_session_api_v2_sessions_session_id_delete(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_session_api_v2_sessions_session_id_delete_with_http_info(session_id, **kwargs)  # noqa: E501

    def delete_session_api_v2_sessions_session_id_delete_with_http_info(self, session_id, **kwargs):  # noqa: E501
        """Delete Session  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_session_api_v2_sessions_session_id_delete_with_http_info(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'session_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_session_api_v2_sessions_session_id_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'session_id' is set
        if self.api_client.client_side_validation and ('session_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_id` when calling `delete_session_api_v2_sessions_session_id_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'session_id' in local_var_params:
            path_params['session_id'] = local_var_params['session_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/sessions/{session_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_web_terminals_api_v2_sessions_session_id_web_terminals_terminal_id_delete(self, session_id, terminal_id, **kwargs):  # noqa: E501
        """Delete Web Terminals  # noqa: E501

        DEPRECATED: This API is no deprecated and will not be supported in Anyscale 2.0  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_web_terminals_api_v2_sessions_session_id_web_terminals_terminal_id_delete(session_id, terminal_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param str terminal_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_web_terminals_api_v2_sessions_session_id_web_terminals_terminal_id_delete_with_http_info(session_id, terminal_id, **kwargs)  # noqa: E501

    def delete_web_terminals_api_v2_sessions_session_id_web_terminals_terminal_id_delete_with_http_info(self, session_id, terminal_id, **kwargs):  # noqa: E501
        """Delete Web Terminals  # noqa: E501

        DEPRECATED: This API is no deprecated and will not be supported in Anyscale 2.0  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_web_terminals_api_v2_sessions_session_id_web_terminals_terminal_id_delete_with_http_info(session_id, terminal_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param str terminal_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'session_id',
            'terminal_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_web_terminals_api_v2_sessions_session_id_web_terminals_terminal_id_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'session_id' is set
        if self.api_client.client_side_validation and ('session_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_id` when calling `delete_web_terminals_api_v2_sessions_session_id_web_terminals_terminal_id_delete`")  # noqa: E501
        # verify the required parameter 'terminal_id' is set
        if self.api_client.client_side_validation and ('terminal_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['terminal_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `terminal_id` when calling `delete_web_terminals_api_v2_sessions_session_id_web_terminals_terminal_id_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'session_id' in local_var_params:
            path_params['session_id'] = local_var_params['session_id']  # noqa: E501
        if 'terminal_id' in local_var_params:
            path_params['terminal_id'] = local_var_params['terminal_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/sessions/{session_id}/web_terminals/{terminal_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_workspace_api_v2_experimental_workspaces_workspace_id_delete(self, workspace_id, **kwargs):  # noqa: E501
        """Delete Workspace  # noqa: E501

        Deletes a Workspace.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_workspace_api_v2_experimental_workspaces_workspace_id_delete(workspace_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str workspace_id: ID of the Workspace to delete. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_workspace_api_v2_experimental_workspaces_workspace_id_delete_with_http_info(workspace_id, **kwargs)  # noqa: E501

    def delete_workspace_api_v2_experimental_workspaces_workspace_id_delete_with_http_info(self, workspace_id, **kwargs):  # noqa: E501
        """Delete Workspace  # noqa: E501

        Deletes a Workspace.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_workspace_api_v2_experimental_workspaces_workspace_id_delete_with_http_info(workspace_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str workspace_id: ID of the Workspace to delete. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'workspace_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_workspace_api_v2_experimental_workspaces_workspace_id_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'workspace_id' is set
        if self.api_client.client_side_validation and ('workspace_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_id` when calling `delete_workspace_api_v2_experimental_workspaces_workspace_id_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'workspace_id' in local_var_params:
            path_params['workspace_id'] = local_var_params['workspace_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/experimental_workspaces/{workspace_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def describe_session_api_v2_sessions_session_id_describe_get(self, session_id, **kwargs):  # noqa: E501
        """Describe Session  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.describe_session_api_v2_sessions_session_id_describe_get(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: SessiondescribeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.describe_session_api_v2_sessions_session_id_describe_get_with_http_info(session_id, **kwargs)  # noqa: E501

    def describe_session_api_v2_sessions_session_id_describe_get_with_http_info(self, session_id, **kwargs):  # noqa: E501
        """Describe Session  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.describe_session_api_v2_sessions_session_id_describe_get_with_http_info(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(SessiondescribeResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'session_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method describe_session_api_v2_sessions_session_id_describe_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'session_id' is set
        if self.api_client.client_side_validation and ('session_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_id` when calling `describe_session_api_v2_sessions_session_id_describe_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'session_id' in local_var_params:
            path_params['session_id'] = local_var_params['session_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/sessions/{session_id}/describe', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SessiondescribeResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def detach_machine_pool_from_cloud_api_v2_machine_pools_detach_post(self, detach_machine_pool_from_cloud_request, **kwargs):  # noqa: E501
        """Detach Machine Pool From Cloud  # noqa: E501

        Detach a machine pool from a cloud.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.detach_machine_pool_from_cloud_api_v2_machine_pools_detach_post(detach_machine_pool_from_cloud_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param DetachMachinePoolFromCloudRequest detach_machine_pool_from_cloud_request: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DetachmachinepoolfromcloudresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.detach_machine_pool_from_cloud_api_v2_machine_pools_detach_post_with_http_info(detach_machine_pool_from_cloud_request, **kwargs)  # noqa: E501

    def detach_machine_pool_from_cloud_api_v2_machine_pools_detach_post_with_http_info(self, detach_machine_pool_from_cloud_request, **kwargs):  # noqa: E501
        """Detach Machine Pool From Cloud  # noqa: E501

        Detach a machine pool from a cloud.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.detach_machine_pool_from_cloud_api_v2_machine_pools_detach_post_with_http_info(detach_machine_pool_from_cloud_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param DetachMachinePoolFromCloudRequest detach_machine_pool_from_cloud_request: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DetachmachinepoolfromcloudresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'detach_machine_pool_from_cloud_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method detach_machine_pool_from_cloud_api_v2_machine_pools_detach_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'detach_machine_pool_from_cloud_request' is set
        if self.api_client.client_side_validation and ('detach_machine_pool_from_cloud_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['detach_machine_pool_from_cloud_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `detach_machine_pool_from_cloud_request` when calling `detach_machine_pool_from_cloud_api_v2_machine_pools_detach_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'detach_machine_pool_from_cloud_request' in local_var_params:
            body_params = local_var_params['detach_machine_pool_from_cloud_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/machine_pools/detach', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DetachmachinepoolfromcloudresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dismiss_user_card_api_v2_onboarding_cards_card_id_dismiss_post(self, card_id, **kwargs):  # noqa: E501
        """Dismiss User Card  # noqa: E501

        Dismiss given card_id for logged in user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dismiss_user_card_api_v2_onboarding_cards_card_id_dismiss_post(card_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CardId card_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.dismiss_user_card_api_v2_onboarding_cards_card_id_dismiss_post_with_http_info(card_id, **kwargs)  # noqa: E501

    def dismiss_user_card_api_v2_onboarding_cards_card_id_dismiss_post_with_http_info(self, card_id, **kwargs):  # noqa: E501
        """Dismiss User Card  # noqa: E501

        Dismiss given card_id for logged in user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dismiss_user_card_api_v2_onboarding_cards_card_id_dismiss_post_with_http_info(card_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CardId card_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'card_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dismiss_user_card_api_v2_onboarding_cards_card_id_dismiss_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'card_id' is set
        if self.api_client.client_side_validation and ('card_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['card_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `card_id` when calling `dismiss_user_card_api_v2_onboarding_cards_card_id_dismiss_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'card_id' in local_var_params:
            path_params['card_id'] = local_var_params['card_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/onboarding_cards/{card_id}/dismiss', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def echo_ip_api_v2_health_echo_ip_get(self, **kwargs):  # noqa: E501
        """Echo Ip  # noqa: E501

        Check that the product can correctly identify source IP at the router layer.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.echo_ip_api_v2_health_echo_ip_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.echo_ip_api_v2_health_echo_ip_get_with_http_info(**kwargs)  # noqa: E501

    def echo_ip_api_v2_health_echo_ip_get_with_http_info(self, **kwargs):  # noqa: E501
        """Echo Ip  # noqa: E501

        Check that the product can correctly identify source IP at the router layer.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.echo_ip_api_v2_health_echo_ip_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method echo_ip_api_v2_health_echo_ip_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/health/echo_ip', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def edit_cloud_resource_api_v2_clouds_with_cloud_resource_gcp_router_cloud_id_patch(self, cloud_id, editable_cloud_resource_gcp, **kwargs):  # noqa: E501
        """Edit Cloud Resource  # noqa: E501

        Edit Cloud.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_cloud_resource_api_v2_clouds_with_cloud_resource_gcp_router_cloud_id_patch(cloud_id, editable_cloud_resource_gcp, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param EditableCloudResourceGCP editable_cloud_resource_gcp: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CloudresourcegcpResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.edit_cloud_resource_api_v2_clouds_with_cloud_resource_gcp_router_cloud_id_patch_with_http_info(cloud_id, editable_cloud_resource_gcp, **kwargs)  # noqa: E501

    def edit_cloud_resource_api_v2_clouds_with_cloud_resource_gcp_router_cloud_id_patch_with_http_info(self, cloud_id, editable_cloud_resource_gcp, **kwargs):  # noqa: E501
        """Edit Cloud Resource  # noqa: E501

        Edit Cloud.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_cloud_resource_api_v2_clouds_with_cloud_resource_gcp_router_cloud_id_patch_with_http_info(cloud_id, editable_cloud_resource_gcp, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param EditableCloudResourceGCP editable_cloud_resource_gcp: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CloudresourcegcpResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id',
            'editable_cloud_resource_gcp'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method edit_cloud_resource_api_v2_clouds_with_cloud_resource_gcp_router_cloud_id_patch" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `edit_cloud_resource_api_v2_clouds_with_cloud_resource_gcp_router_cloud_id_patch`")  # noqa: E501
        # verify the required parameter 'editable_cloud_resource_gcp' is set
        if self.api_client.client_side_validation and ('editable_cloud_resource_gcp' not in local_var_params or  # noqa: E501
                                                        local_var_params['editable_cloud_resource_gcp'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `editable_cloud_resource_gcp` when calling `edit_cloud_resource_api_v2_clouds_with_cloud_resource_gcp_router_cloud_id_patch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'editable_cloud_resource_gcp' in local_var_params:
            body_params = local_var_params['editable_cloud_resource_gcp']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds_with_cloud_resource_gcp_router/{cloud_id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CloudresourcegcpResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def edit_cloud_resource_api_v2_clouds_with_cloud_resource_router_cloud_id_patch(self, cloud_id, editable_cloud_resource, **kwargs):  # noqa: E501
        """Edit Cloud Resource  # noqa: E501

        Edit Cloud.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_cloud_resource_api_v2_clouds_with_cloud_resource_router_cloud_id_patch(cloud_id, editable_cloud_resource, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param EditableCloudResource editable_cloud_resource: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CloudresourceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.edit_cloud_resource_api_v2_clouds_with_cloud_resource_router_cloud_id_patch_with_http_info(cloud_id, editable_cloud_resource, **kwargs)  # noqa: E501

    def edit_cloud_resource_api_v2_clouds_with_cloud_resource_router_cloud_id_patch_with_http_info(self, cloud_id, editable_cloud_resource, **kwargs):  # noqa: E501
        """Edit Cloud Resource  # noqa: E501

        Edit Cloud.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_cloud_resource_api_v2_clouds_with_cloud_resource_router_cloud_id_patch_with_http_info(cloud_id, editable_cloud_resource, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param EditableCloudResource editable_cloud_resource: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CloudresourceResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id',
            'editable_cloud_resource'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method edit_cloud_resource_api_v2_clouds_with_cloud_resource_router_cloud_id_patch" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `edit_cloud_resource_api_v2_clouds_with_cloud_resource_router_cloud_id_patch`")  # noqa: E501
        # verify the required parameter 'editable_cloud_resource' is set
        if self.api_client.client_side_validation and ('editable_cloud_resource' not in local_var_params or  # noqa: E501
                                                        local_var_params['editable_cloud_resource'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `editable_cloud_resource` when calling `edit_cloud_resource_api_v2_clouds_with_cloud_resource_router_cloud_id_patch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'editable_cloud_resource' in local_var_params:
            body_params = local_var_params['editable_cloud_resource']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds_with_cloud_resource_router/{cloud_id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CloudresourceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def execute_interactive_command_api_v2_sessions_session_id_execute_interactive_command_post(self, session_id, execute_interactive_command_options, **kwargs):  # noqa: E501
        """Execute Interactive Command  # noqa: E501

        Execute an interative command on a session.  This endpoint differs with other execute_* since it doesn't actually execute the command. It will just create the command and return auxiliary information for user to ssh into the head node and run their command.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.execute_interactive_command_api_v2_sessions_session_id_execute_interactive_command_post(session_id, execute_interactive_command_options, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param ExecuteInteractiveCommandOptions execute_interactive_command_options: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ExecutecommandresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.execute_interactive_command_api_v2_sessions_session_id_execute_interactive_command_post_with_http_info(session_id, execute_interactive_command_options, **kwargs)  # noqa: E501

    def execute_interactive_command_api_v2_sessions_session_id_execute_interactive_command_post_with_http_info(self, session_id, execute_interactive_command_options, **kwargs):  # noqa: E501
        """Execute Interactive Command  # noqa: E501

        Execute an interative command on a session.  This endpoint differs with other execute_* since it doesn't actually execute the command. It will just create the command and return auxiliary information for user to ssh into the head node and run their command.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.execute_interactive_command_api_v2_sessions_session_id_execute_interactive_command_post_with_http_info(session_id, execute_interactive_command_options, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param ExecuteInteractiveCommandOptions execute_interactive_command_options: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ExecutecommandresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'session_id',
            'execute_interactive_command_options'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method execute_interactive_command_api_v2_sessions_session_id_execute_interactive_command_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'session_id' is set
        if self.api_client.client_side_validation and ('session_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_id` when calling `execute_interactive_command_api_v2_sessions_session_id_execute_interactive_command_post`")  # noqa: E501
        # verify the required parameter 'execute_interactive_command_options' is set
        if self.api_client.client_side_validation and ('execute_interactive_command_options' not in local_var_params or  # noqa: E501
                                                        local_var_params['execute_interactive_command_options'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `execute_interactive_command_options` when calling `execute_interactive_command_api_v2_sessions_session_id_execute_interactive_command_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'session_id' in local_var_params:
            path_params['session_id'] = local_var_params['session_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'execute_interactive_command_options' in local_var_params:
            body_params = local_var_params['execute_interactive_command_options']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/sessions/{session_id}/execute_interactive_command', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ExecutecommandresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def execute_shell_command_api_v2_sessions_session_id_execute_shell_command_post(self, session_id, execute_shell_command_options, **kwargs):  # noqa: E501
        """Execute Shell Command  # noqa: E501

        DEPRECATED: This API is no deprecated and will not be supported in Anyscale 2.0  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.execute_shell_command_api_v2_sessions_session_id_execute_shell_command_post(session_id, execute_shell_command_options, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param ExecuteShellCommandOptions execute_shell_command_options: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: SessioncommandidResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.execute_shell_command_api_v2_sessions_session_id_execute_shell_command_post_with_http_info(session_id, execute_shell_command_options, **kwargs)  # noqa: E501

    def execute_shell_command_api_v2_sessions_session_id_execute_shell_command_post_with_http_info(self, session_id, execute_shell_command_options, **kwargs):  # noqa: E501
        """Execute Shell Command  # noqa: E501

        DEPRECATED: This API is no deprecated and will not be supported in Anyscale 2.0  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.execute_shell_command_api_v2_sessions_session_id_execute_shell_command_post_with_http_info(session_id, execute_shell_command_options, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param ExecuteShellCommandOptions execute_shell_command_options: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(SessioncommandidResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'session_id',
            'execute_shell_command_options'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method execute_shell_command_api_v2_sessions_session_id_execute_shell_command_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'session_id' is set
        if self.api_client.client_side_validation and ('session_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_id` when calling `execute_shell_command_api_v2_sessions_session_id_execute_shell_command_post`")  # noqa: E501
        # verify the required parameter 'execute_shell_command_options' is set
        if self.api_client.client_side_validation and ('execute_shell_command_options' not in local_var_params or  # noqa: E501
                                                        local_var_params['execute_shell_command_options'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `execute_shell_command_options` when calling `execute_shell_command_api_v2_sessions_session_id_execute_shell_command_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'session_id' in local_var_params:
            path_params['session_id'] = local_var_params['session_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'execute_shell_command_options' in local_var_params:
            body_params = local_var_params['execute_shell_command_options']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/sessions/{session_id}/execute_shell_command', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SessioncommandidResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def find_cloud_by_name_api_v2_clouds_find_by_name_post(self, cloud_name_options, **kwargs):  # noqa: E501
        """Find Cloud By Name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.find_cloud_by_name_api_v2_clouds_find_by_name_post(cloud_name_options, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CloudNameOptions cloud_name_options: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CloudResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.find_cloud_by_name_api_v2_clouds_find_by_name_post_with_http_info(cloud_name_options, **kwargs)  # noqa: E501

    def find_cloud_by_name_api_v2_clouds_find_by_name_post_with_http_info(self, cloud_name_options, **kwargs):  # noqa: E501
        """Find Cloud By Name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.find_cloud_by_name_api_v2_clouds_find_by_name_post_with_http_info(cloud_name_options, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CloudNameOptions cloud_name_options: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CloudResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_name_options'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method find_cloud_by_name_api_v2_clouds_find_by_name_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_name_options' is set
        if self.api_client.client_side_validation and ('cloud_name_options' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_name_options'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_name_options` when calling `find_cloud_by_name_api_v2_clouds_find_by_name_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'cloud_name_options' in local_var_params:
            body_params = local_var_params['cloud_name_options']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds/find_by_name', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CloudResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def find_project_by_project_name_api_v2_projects_find_by_name_get(self, name, **kwargs):  # noqa: E501
        """Find Project By Project Name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.find_project_by_project_name_api_v2_projects_find_by_name_get(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str name: (required)
        :param str owner:
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ProjectListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.find_project_by_project_name_api_v2_projects_find_by_name_get_with_http_info(name, **kwargs)  # noqa: E501

    def find_project_by_project_name_api_v2_projects_find_by_name_get_with_http_info(self, name, **kwargs):  # noqa: E501
        """Find Project By Project Name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.find_project_by_project_name_api_v2_projects_find_by_name_get_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str name: (required)
        :param str owner:
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ProjectListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'name',
            'owner',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method find_project_by_project_name_api_v2_projects_find_by_name_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'name' is set
        if self.api_client.client_side_validation and ('name' not in local_var_params or  # noqa: E501
                                                        local_var_params['name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `name` when calling `find_project_by_project_name_api_v2_projects_find_by_name_get`")  # noqa: E501

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 50:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `find_project_by_project_name_api_v2_projects_find_by_name_get`, must be a value less than or equal to `50`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `find_project_by_project_name_api_v2_projects_find_by_name_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
            query_params.append(('name', local_var_params['name']))  # noqa: E501
        if 'owner' in local_var_params and local_var_params['owner'] is not None:  # noqa: E501
            query_params.append(('owner', local_var_params['owner']))  # noqa: E501
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/projects/find_by_name', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ProjectListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def find_with_invitation_api_v2_organizations_find_with_invitation_get(self, invitation_id, **kwargs):  # noqa: E501
        """Find With Invitation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.find_with_invitation_api_v2_organizations_find_with_invitation_get(invitation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str invitation_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: OrganizationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.find_with_invitation_api_v2_organizations_find_with_invitation_get_with_http_info(invitation_id, **kwargs)  # noqa: E501

    def find_with_invitation_api_v2_organizations_find_with_invitation_get_with_http_info(self, invitation_id, **kwargs):  # noqa: E501
        """Find With Invitation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.find_with_invitation_api_v2_organizations_find_with_invitation_get_with_http_info(invitation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str invitation_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(OrganizationResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'invitation_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method find_with_invitation_api_v2_organizations_find_with_invitation_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'invitation_id' is set
        if self.api_client.client_side_validation and ('invitation_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['invitation_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `invitation_id` when calling `find_with_invitation_api_v2_organizations_find_with_invitation_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'invitation_id' in local_var_params and local_var_params['invitation_id'] is not None:  # noqa: E501
            query_params.append(('invitation_id', local_var_params['invitation_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organizations/find_with_invitation', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OrganizationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def find_with_public_identifier_api_v2_organizations_find_with_public_identifier_get(self, public_identifier, **kwargs):  # noqa: E501
        """Find With Public Identifier  # noqa: E501

        Deprecated because this can leak information about our customers to any unauthenticated person.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.find_with_public_identifier_api_v2_organizations_find_with_public_identifier_get(public_identifier, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str public_identifier: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: OrganizationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.find_with_public_identifier_api_v2_organizations_find_with_public_identifier_get_with_http_info(public_identifier, **kwargs)  # noqa: E501

    def find_with_public_identifier_api_v2_organizations_find_with_public_identifier_get_with_http_info(self, public_identifier, **kwargs):  # noqa: E501
        """Find With Public Identifier  # noqa: E501

        Deprecated because this can leak information about our customers to any unauthenticated person.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.find_with_public_identifier_api_v2_organizations_find_with_public_identifier_get_with_http_info(public_identifier, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str public_identifier: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(OrganizationResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'public_identifier'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method find_with_public_identifier_api_v2_organizations_find_with_public_identifier_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'public_identifier' is set
        if self.api_client.client_side_validation and ('public_identifier' not in local_var_params or  # noqa: E501
                                                        local_var_params['public_identifier'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `public_identifier` when calling `find_with_public_identifier_api_v2_organizations_find_with_public_identifier_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'public_identifier' in local_var_params and local_var_params['public_identifier'] is not None:  # noqa: E501
            query_params.append(('public_identifier', local_var_params['public_identifier']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organizations/find_with_public_identifier', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OrganizationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def find_with_user_api_v2_organizations_find_with_user_get(self, user_email, **kwargs):  # noqa: E501
        """Find With User  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.find_with_user_api_v2_organizations_find_with_user_get(user_email, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_email: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: OrganizationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.find_with_user_api_v2_organizations_find_with_user_get_with_http_info(user_email, **kwargs)  # noqa: E501

    def find_with_user_api_v2_organizations_find_with_user_get_with_http_info(self, user_email, **kwargs):  # noqa: E501
        """Find With User  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.find_with_user_api_v2_organizations_find_with_user_get_with_http_info(user_email, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_email: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(OrganizationResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'user_email'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method find_with_user_api_v2_organizations_find_with_user_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user_email' is set
        if self.api_client.client_side_validation and ('user_email' not in local_var_params or  # noqa: E501
                                                        local_var_params['user_email'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `user_email` when calling `find_with_user_api_v2_organizations_find_with_user_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'user_email' in local_var_params and local_var_params['user_email'] is not None:  # noqa: E501
            query_params.append(('user_email', local_var_params['user_email']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organizations/find_with_user', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OrganizationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def fine_tuning_job_callback_api_v2_fine_tuning_jobs_internal_finish_post(self, finish_ft_job_request, **kwargs):  # noqa: E501
        """Fine Tuning Job Callback  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.fine_tuning_job_callback_api_v2_fine_tuning_jobs_internal_finish_post(finish_ft_job_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param FinishFTJobRequest finish_ft_job_request: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.fine_tuning_job_callback_api_v2_fine_tuning_jobs_internal_finish_post_with_http_info(finish_ft_job_request, **kwargs)  # noqa: E501

    def fine_tuning_job_callback_api_v2_fine_tuning_jobs_internal_finish_post_with_http_info(self, finish_ft_job_request, **kwargs):  # noqa: E501
        """Fine Tuning Job Callback  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.fine_tuning_job_callback_api_v2_fine_tuning_jobs_internal_finish_post_with_http_info(finish_ft_job_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param FinishFTJobRequest finish_ft_job_request: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'finish_ft_job_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method fine_tuning_job_callback_api_v2_fine_tuning_jobs_internal_finish_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'finish_ft_job_request' is set
        if self.api_client.client_side_validation and ('finish_ft_job_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['finish_ft_job_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `finish_ft_job_request` when calling `fine_tuning_job_callback_api_v2_fine_tuning_jobs_internal_finish_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'finish_ft_job_request' in local_var_params:
            body_params = local_var_params['finish_ft_job_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/fine_tuning/jobs/internal/finish', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def fine_tuning_job_callback_v2_api_v2_fine_tuning_v2_jobs_internal_finish_post(self, finish_ft_job_request_v2, **kwargs):  # noqa: E501
        """Fine Tuning Job Callback V2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.fine_tuning_job_callback_v2_api_v2_fine_tuning_v2_jobs_internal_finish_post(finish_ft_job_request_v2, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param FinishFTJobRequestV2 finish_ft_job_request_v2: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.fine_tuning_job_callback_v2_api_v2_fine_tuning_v2_jobs_internal_finish_post_with_http_info(finish_ft_job_request_v2, **kwargs)  # noqa: E501

    def fine_tuning_job_callback_v2_api_v2_fine_tuning_v2_jobs_internal_finish_post_with_http_info(self, finish_ft_job_request_v2, **kwargs):  # noqa: E501
        """Fine Tuning Job Callback V2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.fine_tuning_job_callback_v2_api_v2_fine_tuning_v2_jobs_internal_finish_post_with_http_info(finish_ft_job_request_v2, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param FinishFTJobRequestV2 finish_ft_job_request_v2: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'finish_ft_job_request_v2'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method fine_tuning_job_callback_v2_api_v2_fine_tuning_v2_jobs_internal_finish_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'finish_ft_job_request_v2' is set
        if self.api_client.client_side_validation and ('finish_ft_job_request_v2' not in local_var_params or  # noqa: E501
                                                        local_var_params['finish_ft_job_request_v2'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `finish_ft_job_request_v2` when calling `fine_tuning_job_callback_v2_api_v2_fine_tuning_v2_jobs_internal_finish_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'finish_ft_job_request_v2' in local_var_params:
            body_params = local_var_params['finish_ft_job_request_v2']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/fine_tuning_v2/jobs/internal/finish', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def finish_session_command_api_v2_session_commands_session_command_id_finish_post(self, session_command_id, session_command_finish_options, **kwargs):  # noqa: E501
        """Finish Session Command  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.finish_session_command_api_v2_session_commands_session_command_id_finish_post(session_command_id, session_command_finish_options, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_command_id: (required)
        :param SessionCommandFinishOptions session_command_finish_options: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.finish_session_command_api_v2_session_commands_session_command_id_finish_post_with_http_info(session_command_id, session_command_finish_options, **kwargs)  # noqa: E501

    def finish_session_command_api_v2_session_commands_session_command_id_finish_post_with_http_info(self, session_command_id, session_command_finish_options, **kwargs):  # noqa: E501
        """Finish Session Command  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.finish_session_command_api_v2_session_commands_session_command_id_finish_post_with_http_info(session_command_id, session_command_finish_options, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_command_id: (required)
        :param SessionCommandFinishOptions session_command_finish_options: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'session_command_id',
            'session_command_finish_options'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method finish_session_command_api_v2_session_commands_session_command_id_finish_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'session_command_id' is set
        if self.api_client.client_side_validation and ('session_command_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_command_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_command_id` when calling `finish_session_command_api_v2_session_commands_session_command_id_finish_post`")  # noqa: E501
        # verify the required parameter 'session_command_finish_options' is set
        if self.api_client.client_side_validation and ('session_command_finish_options' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_command_finish_options'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_command_finish_options` when calling `finish_session_command_api_v2_session_commands_session_command_id_finish_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'session_command_id' in local_var_params:
            path_params['session_command_id'] = local_var_params['session_command_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'session_command_finish_options' in local_var_params:
            body_params = local_var_params['session_command_finish_options']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/session_commands/{session_command_id}/finish', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def generate_cloud_data_bucket_presigned_upload_url_api_v2_clouds_cloud_id_generate_cloud_data_bucket_presigned_upload_url_post(self, cloud_id, cloud_data_bucket_presigned_upload_request, **kwargs):  # noqa: E501
        """Generate Cloud Data Bucket Presigned Upload Url  # noqa: E501

        This method generates and returns a presigned upload URL for the provided file type & name. All files scoped to a cloud should be nested underneath {organization_id}/{cloud_id}, so the path that is generated will follow the pattern:      {organization_id}/{cloud_id}/{file_type}/{file_name}  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.generate_cloud_data_bucket_presigned_upload_url_api_v2_clouds_cloud_id_generate_cloud_data_bucket_presigned_upload_url_post(cloud_id, cloud_data_bucket_presigned_upload_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param CloudDataBucketPresignedUploadRequest cloud_data_bucket_presigned_upload_request: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ClouddatabucketpresigneduploadinfoResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.generate_cloud_data_bucket_presigned_upload_url_api_v2_clouds_cloud_id_generate_cloud_data_bucket_presigned_upload_url_post_with_http_info(cloud_id, cloud_data_bucket_presigned_upload_request, **kwargs)  # noqa: E501

    def generate_cloud_data_bucket_presigned_upload_url_api_v2_clouds_cloud_id_generate_cloud_data_bucket_presigned_upload_url_post_with_http_info(self, cloud_id, cloud_data_bucket_presigned_upload_request, **kwargs):  # noqa: E501
        """Generate Cloud Data Bucket Presigned Upload Url  # noqa: E501

        This method generates and returns a presigned upload URL for the provided file type & name. All files scoped to a cloud should be nested underneath {organization_id}/{cloud_id}, so the path that is generated will follow the pattern:      {organization_id}/{cloud_id}/{file_type}/{file_name}  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.generate_cloud_data_bucket_presigned_upload_url_api_v2_clouds_cloud_id_generate_cloud_data_bucket_presigned_upload_url_post_with_http_info(cloud_id, cloud_data_bucket_presigned_upload_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param CloudDataBucketPresignedUploadRequest cloud_data_bucket_presigned_upload_request: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ClouddatabucketpresigneduploadinfoResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id',
            'cloud_data_bucket_presigned_upload_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method generate_cloud_data_bucket_presigned_upload_url_api_v2_clouds_cloud_id_generate_cloud_data_bucket_presigned_upload_url_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `generate_cloud_data_bucket_presigned_upload_url_api_v2_clouds_cloud_id_generate_cloud_data_bucket_presigned_upload_url_post`")  # noqa: E501
        # verify the required parameter 'cloud_data_bucket_presigned_upload_request' is set
        if self.api_client.client_side_validation and ('cloud_data_bucket_presigned_upload_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_data_bucket_presigned_upload_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_data_bucket_presigned_upload_request` when calling `generate_cloud_data_bucket_presigned_upload_url_api_v2_clouds_cloud_id_generate_cloud_data_bucket_presigned_upload_url_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'cloud_data_bucket_presigned_upload_request' in local_var_params:
            body_params = local_var_params['cloud_data_bucket_presigned_upload_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds/{cloud_id}/generate_cloud_data_bucket_presigned_upload_url', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClouddatabucketpresigneduploadinfoResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_active_billing_version_api_v2_organization_billing_active_billing_version_get(self, **kwargs):  # noqa: E501
        """Get Active Billing Version  # noqa: E501

        Returns the active billing version code for the user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_active_billing_version_api_v2_organization_billing_active_billing_version_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: BillingVersionCode
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_active_billing_version_api_v2_organization_billing_active_billing_version_get_with_http_info(**kwargs)  # noqa: E501

    def get_active_billing_version_api_v2_organization_billing_active_billing_version_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get Active Billing Version  # noqa: E501

        Returns the active billing version code for the user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_active_billing_version_api_v2_organization_billing_active_billing_version_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(BillingVersionCode, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_active_billing_version_api_v2_organization_billing_active_billing_version_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organization_billing/active_billing_version', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BillingVersionCode',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_anyscale_aws_account_api_v2_clouds_anyscale_aws_account_get(self, **kwargs):  # noqa: E501
        """Get Anyscale Aws Account  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_anyscale_aws_account_api_v2_clouds_anyscale_aws_account_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AnyscaleawsaccountResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_anyscale_aws_account_api_v2_clouds_anyscale_aws_account_get_with_http_info(**kwargs)  # noqa: E501

    def get_anyscale_aws_account_api_v2_clouds_anyscale_aws_account_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get Anyscale Aws Account  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_anyscale_aws_account_api_v2_clouds_anyscale_aws_account_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AnyscaleawsaccountResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_anyscale_aws_account_api_v2_clouds_anyscale_aws_account_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds/anyscale/aws_account', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AnyscaleawsaccountResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_anyscale_version_api_v2_userinfo_anyscale_version_get(self, **kwargs):  # noqa: E501
        """Get Anyscale Version  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_anyscale_version_api_v2_userinfo_anyscale_version_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AnyscaleversionresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_anyscale_version_api_v2_userinfo_anyscale_version_get_with_http_info(**kwargs)  # noqa: E501

    def get_anyscale_version_api_v2_userinfo_anyscale_version_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get Anyscale Version  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_anyscale_version_api_v2_userinfo_anyscale_version_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AnyscaleversionresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_anyscale_version_api_v2_userinfo_anyscale_version_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/userinfo/anyscale_version', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AnyscaleversionresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_application_template_api_v2_application_templates_application_template_id_get(self, application_template_id, **kwargs):  # noqa: E501
        """Get Application Template  # noqa: E501

        Retrieves a Cluster Environment. Note: cluster_environment is called app_config on the backend api.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_template_api_v2_application_templates_application_template_id_get(application_template_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str application_template_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedapplicationtemplateResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_application_template_api_v2_application_templates_application_template_id_get_with_http_info(application_template_id, **kwargs)  # noqa: E501

    def get_application_template_api_v2_application_templates_application_template_id_get_with_http_info(self, application_template_id, **kwargs):  # noqa: E501
        """Get Application Template  # noqa: E501

        Retrieves a Cluster Environment. Note: cluster_environment is called app_config on the backend api.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_template_api_v2_application_templates_application_template_id_get_with_http_info(application_template_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str application_template_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedapplicationtemplateResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'application_template_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_application_template_api_v2_application_templates_application_template_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_template_id' is set
        if self.api_client.client_side_validation and ('application_template_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_template_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_template_id` when calling `get_application_template_api_v2_application_templates_application_template_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_template_id' in local_var_params:
            path_params['application_template_id'] = local_var_params['application_template_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/application_templates/{application_template_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedapplicationtemplateResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_billing_information_api_v2_organization_billing_billing_information_get(self, **kwargs):  # noqa: E501
        """Get Billing Information  # noqa: E501

        Returns billing information for the current organization.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_billing_information_api_v2_organization_billing_billing_information_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: BillingInformation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_billing_information_api_v2_organization_billing_billing_information_get_with_http_info(**kwargs)  # noqa: E501

    def get_billing_information_api_v2_organization_billing_billing_information_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get Billing Information  # noqa: E501

        Returns billing information for the current organization.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_billing_information_api_v2_organization_billing_billing_information_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(BillingInformation, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_billing_information_api_v2_organization_billing_billing_information_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organization_billing/billing_information', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BillingInformation',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_billing_versions_by_organization_api_v2_organization_billing_billing_versions_get(self, organization_id, **kwargs):  # noqa: E501
        """Get Billing Versions By Organization  # noqa: E501

        Returns the list of billing versions for the organization.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_billing_versions_by_organization_api_v2_organization_billing_billing_versions_get(organization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str organization_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ReadbillingversionListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_billing_versions_by_organization_api_v2_organization_billing_billing_versions_get_with_http_info(organization_id, **kwargs)  # noqa: E501

    def get_billing_versions_by_organization_api_v2_organization_billing_billing_versions_get_with_http_info(self, organization_id, **kwargs):  # noqa: E501
        """Get Billing Versions By Organization  # noqa: E501

        Returns the list of billing versions for the organization.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_billing_versions_by_organization_api_v2_organization_billing_billing_versions_get_with_http_info(organization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str organization_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ReadbillingversionListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'organization_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_billing_versions_by_organization_api_v2_organization_billing_billing_versions_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_id' is set
        if self.api_client.client_side_validation and ('organization_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['organization_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_id` when calling `get_billing_versions_by_organization_api_v2_organization_billing_billing_versions_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'organization_id' in local_var_params and local_var_params['organization_id'] is not None:  # noqa: E501
            query_params.append(('organization_id', local_var_params['organization_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organization_billing/billing_versions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ReadbillingversionListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_build_api_v2_builds_build_id_get(self, build_id, **kwargs):  # noqa: E501
        """Get Build  # noqa: E501

        Retrieves a Build.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_build_api_v2_builds_build_id_get(build_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str build_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedbuildResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_build_api_v2_builds_build_id_get_with_http_info(build_id, **kwargs)  # noqa: E501

    def get_build_api_v2_builds_build_id_get_with_http_info(self, build_id, **kwargs):  # noqa: E501
        """Get Build  # noqa: E501

        Retrieves a Build.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_build_api_v2_builds_build_id_get_with_http_info(build_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str build_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedbuildResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'build_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_build_api_v2_builds_build_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'build_id' is set
        if self.api_client.client_side_validation and ('build_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['build_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `build_id` when calling `get_build_api_v2_builds_build_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'build_id' in local_var_params:
            path_params['build_id'] = local_var_params['build_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/builds/{build_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedbuildResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_build_logs_api_v2_builds_build_id_logs_get(self, build_id, **kwargs):  # noqa: E501
        """Get Build Logs  # noqa: E501

        Retrieves logs for a Build.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_build_logs_api_v2_builds_build_id_logs_get(build_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str build_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: BuildlogresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_build_logs_api_v2_builds_build_id_logs_get_with_http_info(build_id, **kwargs)  # noqa: E501

    def get_build_logs_api_v2_builds_build_id_logs_get_with_http_info(self, build_id, **kwargs):  # noqa: E501
        """Get Build Logs  # noqa: E501

        Retrieves logs for a Build.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_build_logs_api_v2_builds_build_id_logs_get_with_http_info(build_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str build_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(BuildlogresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'build_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_build_logs_api_v2_builds_build_id_logs_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'build_id' is set
        if self.api_client.client_side_validation and ('build_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['build_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `build_id` when calling `get_build_logs_api_v2_builds_build_id_logs_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'build_id' in local_var_params:
            path_params['build_id'] = local_var_params['build_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/builds/{build_id}/logs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BuildlogresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_cloud_api_v2_clouds_cloud_id_get(self, cloud_id, **kwargs):  # noqa: E501
        """Get Cloud  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cloud_api_v2_clouds_cloud_id_get(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CloudResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_cloud_api_v2_clouds_cloud_id_get_with_http_info(cloud_id, **kwargs)  # noqa: E501

    def get_cloud_api_v2_clouds_cloud_id_get_with_http_info(self, cloud_id, **kwargs):  # noqa: E501
        """Get Cloud  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cloud_api_v2_clouds_cloud_id_get_with_http_info(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CloudResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_cloud_api_v2_clouds_cloud_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `get_cloud_api_v2_clouds_cloud_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds/{cloud_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CloudResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_cloud_project_collaborator_api_v2_projects_project_id_collaborators_clouds_get(self, project_id, **kwargs):  # noqa: E501
        """Get Cloud Project Collaborator  # noqa: E501

        Get cloud that has permission for a given project if that project is public in the cloud.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cloud_project_collaborator_api_v2_projects_project_id_collaborators_clouds_get(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CloudProjectCollaborator
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_cloud_project_collaborator_api_v2_projects_project_id_collaborators_clouds_get_with_http_info(project_id, **kwargs)  # noqa: E501

    def get_cloud_project_collaborator_api_v2_projects_project_id_collaborators_clouds_get_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """Get Cloud Project Collaborator  # noqa: E501

        Get cloud that has permission for a given project if that project is public in the cloud.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cloud_project_collaborator_api_v2_projects_project_id_collaborators_clouds_get_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CloudProjectCollaborator, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_cloud_project_collaborator_api_v2_projects_project_id_collaborators_clouds_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `get_cloud_project_collaborator_api_v2_projects_project_id_collaborators_clouds_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in local_var_params:
            path_params['project_id'] = local_var_params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/projects/{project_id}/collaborators/clouds', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CloudProjectCollaborator',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_gcp_router_cloud_id_get(self, cloud_id, **kwargs):  # noqa: E501
        """Get Cloud With Cloud Resource  # noqa: E501

        Retrieves a Cloud with CloudResource.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_gcp_router_cloud_id_get(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CloudwithcloudresourcegcpResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_gcp_router_cloud_id_get_with_http_info(cloud_id, **kwargs)  # noqa: E501

    def get_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_gcp_router_cloud_id_get_with_http_info(self, cloud_id, **kwargs):  # noqa: E501
        """Get Cloud With Cloud Resource  # noqa: E501

        Retrieves a Cloud with CloudResource.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_gcp_router_cloud_id_get_with_http_info(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CloudwithcloudresourcegcpResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_gcp_router_cloud_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `get_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_gcp_router_cloud_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds_with_cloud_resource_gcp_router/{cloud_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CloudwithcloudresourcegcpResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_router_cloud_id_get(self, cloud_id, **kwargs):  # noqa: E501
        """Get Cloud With Cloud Resource  # noqa: E501

        Retrieves a Cloud with CloudResource.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_router_cloud_id_get(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CloudwithcloudresourceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_router_cloud_id_get_with_http_info(cloud_id, **kwargs)  # noqa: E501

    def get_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_router_cloud_id_get_with_http_info(self, cloud_id, **kwargs):  # noqa: E501
        """Get Cloud With Cloud Resource  # noqa: E501

        Retrieves a Cloud with CloudResource.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_router_cloud_id_get_with_http_info(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CloudwithcloudresourceResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_router_cloud_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `get_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_router_cloud_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds_with_cloud_resource_router/{cloud_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CloudwithcloudresourceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_cluster_product_autoscaler_flag_api_v2_logs_cluster_product_autoscaler_flag_session_id_get(self, session_id, **kwargs):  # noqa: E501
        """Get Cluster Product Autoscaler Flag  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cluster_product_autoscaler_flag_api_v2_logs_cluster_product_autoscaler_flag_session_id_get(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ProductautoscalerflagResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_cluster_product_autoscaler_flag_api_v2_logs_cluster_product_autoscaler_flag_session_id_get_with_http_info(session_id, **kwargs)  # noqa: E501

    def get_cluster_product_autoscaler_flag_api_v2_logs_cluster_product_autoscaler_flag_session_id_get_with_http_info(self, session_id, **kwargs):  # noqa: E501
        """Get Cluster Product Autoscaler Flag  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cluster_product_autoscaler_flag_api_v2_logs_cluster_product_autoscaler_flag_session_id_get_with_http_info(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ProductautoscalerflagResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'session_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_cluster_product_autoscaler_flag_api_v2_logs_cluster_product_autoscaler_flag_session_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'session_id' is set
        if self.api_client.client_side_validation and ('session_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_id` when calling `get_cluster_product_autoscaler_flag_api_v2_logs_cluster_product_autoscaler_flag_session_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'session_id' in local_var_params:
            path_params['session_id'] = local_var_params['session_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/logs/cluster_product_autoscaler_flag/{session_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ProductautoscalerflagResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_compute_template_api_v2_compute_templates_template_id_get(self, template_id, **kwargs):  # noqa: E501
        """Get Compute Template  # noqa: E501

        Retrieves a compute template.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_compute_template_api_v2_compute_templates_template_id_get(template_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str template_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedcomputetemplateResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_compute_template_api_v2_compute_templates_template_id_get_with_http_info(template_id, **kwargs)  # noqa: E501

    def get_compute_template_api_v2_compute_templates_template_id_get_with_http_info(self, template_id, **kwargs):  # noqa: E501
        """Get Compute Template  # noqa: E501

        Retrieves a compute template.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_compute_template_api_v2_compute_templates_template_id_get_with_http_info(template_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str template_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedcomputetemplateResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'template_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_compute_template_api_v2_compute_templates_template_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'template_id' is set
        if self.api_client.client_side_validation and ('template_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['template_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `template_id` when calling `get_compute_template_api_v2_compute_templates_template_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'template_id' in local_var_params:
            path_params['template_id'] = local_var_params['template_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/compute_templates/{template_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedcomputetemplateResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_cron_job_api_v2_experimental_cron_jobs_cron_job_id_get(self, cron_job_id, **kwargs):  # noqa: E501
        """Get Cron Job  # noqa: E501

        Get CRON Job  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cron_job_api_v2_experimental_cron_jobs_cron_job_id_get(cron_job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cron_job_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedscheduleResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_cron_job_api_v2_experimental_cron_jobs_cron_job_id_get_with_http_info(cron_job_id, **kwargs)  # noqa: E501

    def get_cron_job_api_v2_experimental_cron_jobs_cron_job_id_get_with_http_info(self, cron_job_id, **kwargs):  # noqa: E501
        """Get Cron Job  # noqa: E501

        Get CRON Job  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cron_job_api_v2_experimental_cron_jobs_cron_job_id_get_with_http_info(cron_job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cron_job_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedscheduleResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cron_job_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_cron_job_api_v2_experimental_cron_jobs_cron_job_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cron_job_id' is set
        if self.api_client.client_side_validation and ('cron_job_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cron_job_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cron_job_id` when calling `get_cron_job_api_v2_experimental_cron_jobs_cron_job_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cron_job_id' in local_var_params:
            path_params['cron_job_id'] = local_var_params['cron_job_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/experimental_cron_jobs/{cron_job_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedscheduleResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_decorated_cluster_api_v2_decorated_sessions_cluster_id_get(self, cluster_id, **kwargs):  # noqa: E501
        """Get Decorated Cluster  # noqa: E501

        Get a single cluster by id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_decorated_cluster_api_v2_decorated_sessions_cluster_id_get(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedsessionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_decorated_cluster_api_v2_decorated_sessions_cluster_id_get_with_http_info(cluster_id, **kwargs)  # noqa: E501

    def get_decorated_cluster_api_v2_decorated_sessions_cluster_id_get_with_http_info(self, cluster_id, **kwargs):  # noqa: E501
        """Get Decorated Cluster  # noqa: E501

        Get a single cluster by id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_decorated_cluster_api_v2_decorated_sessions_cluster_id_get_with_http_info(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedsessionResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cluster_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_decorated_cluster_api_v2_decorated_sessions_cluster_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and ('cluster_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cluster_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `get_decorated_cluster_api_v2_decorated_sessions_cluster_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in local_var_params:
            path_params['cluster_id'] = local_var_params['cluster_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/decorated_sessions/{cluster_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedsessionResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_decorated_interactive_session_api_v2_decorated_interactive_sessions_interactive_session_id_get(self, interactive_session_id, **kwargs):  # noqa: E501
        """Get Decorated Interactive Session  # noqa: E501

        Get one specific decorated job by it's db id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_decorated_interactive_session_api_v2_decorated_interactive_sessions_interactive_session_id_get(interactive_session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str interactive_session_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedinteractivesessionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_decorated_interactive_session_api_v2_decorated_interactive_sessions_interactive_session_id_get_with_http_info(interactive_session_id, **kwargs)  # noqa: E501

    def get_decorated_interactive_session_api_v2_decorated_interactive_sessions_interactive_session_id_get_with_http_info(self, interactive_session_id, **kwargs):  # noqa: E501
        """Get Decorated Interactive Session  # noqa: E501

        Get one specific decorated job by it's db id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_decorated_interactive_session_api_v2_decorated_interactive_sessions_interactive_session_id_get_with_http_info(interactive_session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str interactive_session_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedinteractivesessionResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'interactive_session_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_decorated_interactive_session_api_v2_decorated_interactive_sessions_interactive_session_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'interactive_session_id' is set
        if self.api_client.client_side_validation and ('interactive_session_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['interactive_session_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `interactive_session_id` when calling `get_decorated_interactive_session_api_v2_decorated_interactive_sessions_interactive_session_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'interactive_session_id' in local_var_params:
            path_params['interactive_session_id'] = local_var_params['interactive_session_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/decorated_interactive_sessions/{interactive_session_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedinteractivesessionResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_decorated_interactive_session_logs_api_v2_decorated_interactive_sessions_interactive_session_id_logs_get(self, interactive_session_id, **kwargs):  # noqa: E501
        """Get Decorated Interactive Session Logs  # noqa: E501

        Get a interactive session id logs by db id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_decorated_interactive_session_logs_api_v2_decorated_interactive_sessions_interactive_session_id_logs_get(interactive_session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str interactive_session_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InteractivesessionlogsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_decorated_interactive_session_logs_api_v2_decorated_interactive_sessions_interactive_session_id_logs_get_with_http_info(interactive_session_id, **kwargs)  # noqa: E501

    def get_decorated_interactive_session_logs_api_v2_decorated_interactive_sessions_interactive_session_id_logs_get_with_http_info(self, interactive_session_id, **kwargs):  # noqa: E501
        """Get Decorated Interactive Session Logs  # noqa: E501

        Get a interactive session id logs by db id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_decorated_interactive_session_logs_api_v2_decorated_interactive_sessions_interactive_session_id_logs_get_with_http_info(interactive_session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str interactive_session_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InteractivesessionlogsResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'interactive_session_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_decorated_interactive_session_logs_api_v2_decorated_interactive_sessions_interactive_session_id_logs_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'interactive_session_id' is set
        if self.api_client.client_side_validation and ('interactive_session_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['interactive_session_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `interactive_session_id` when calling `get_decorated_interactive_session_logs_api_v2_decorated_interactive_sessions_interactive_session_id_logs_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'interactive_session_id' in local_var_params:
            path_params['interactive_session_id'] = local_var_params['interactive_session_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/decorated_interactive_sessions/{interactive_session_id}/logs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InteractivesessionlogsResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_decorated_job_api_v2_decorated_jobs_job_id_get(self, job_id, **kwargs):  # noqa: E501
        """Get Decorated Job  # noqa: E501

        Get one specific decorated job by it's db id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_decorated_job_api_v2_decorated_jobs_job_id_get(job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str job_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedjobResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_decorated_job_api_v2_decorated_jobs_job_id_get_with_http_info(job_id, **kwargs)  # noqa: E501

    def get_decorated_job_api_v2_decorated_jobs_job_id_get_with_http_info(self, job_id, **kwargs):  # noqa: E501
        """Get Decorated Job  # noqa: E501

        Get one specific decorated job by it's db id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_decorated_job_api_v2_decorated_jobs_job_id_get_with_http_info(job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str job_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedjobResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'job_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_decorated_job_api_v2_decorated_jobs_job_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'job_id' is set
        if self.api_client.client_side_validation and ('job_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['job_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `job_id` when calling `get_decorated_job_api_v2_decorated_jobs_job_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'job_id' in local_var_params:
            path_params['job_id'] = local_var_params['job_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/decorated_jobs/{job_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedjobResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_decorated_job_logs_api_v2_decorated_jobs_job_id_logs_get(self, job_id, **kwargs):  # noqa: E501
        """Get Decorated Job Logs  # noqa: E501

        Get a jobs logs by db id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_decorated_job_logs_api_v2_decorated_jobs_job_id_logs_get(job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str job_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: JobslogsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_decorated_job_logs_api_v2_decorated_jobs_job_id_logs_get_with_http_info(job_id, **kwargs)  # noqa: E501

    def get_decorated_job_logs_api_v2_decorated_jobs_job_id_logs_get_with_http_info(self, job_id, **kwargs):  # noqa: E501
        """Get Decorated Job Logs  # noqa: E501

        Get a jobs logs by db id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_decorated_job_logs_api_v2_decorated_jobs_job_id_logs_get_with_http_info(job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str job_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(JobslogsResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'job_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_decorated_job_logs_api_v2_decorated_jobs_job_id_logs_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'job_id' is set
        if self.api_client.client_side_validation and ('job_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['job_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `job_id` when calling `get_decorated_job_logs_api_v2_decorated_jobs_job_id_logs_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'job_id' in local_var_params:
            path_params['job_id'] = local_var_params['job_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/decorated_jobs/{job_id}/logs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='JobslogsResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_decorated_job_submission_api_v2_decorated_job_submissions_ray_job_submission_db_id_get(self, ray_job_submission_db_id, **kwargs):  # noqa: E501
        """Get Decorated Job Submission  # noqa: E501

        Get the job submission based on its db id.  Returns ------- Response[DecoratedJobSubmission]     selected DecoratedJobSubmission based on the passed in db id  Raises ------ HTTPException(status_code=400)     if the provided job submision db id does not exist  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_decorated_job_submission_api_v2_decorated_job_submissions_ray_job_submission_db_id_get(ray_job_submission_db_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str ray_job_submission_db_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedjobsubmissionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_decorated_job_submission_api_v2_decorated_job_submissions_ray_job_submission_db_id_get_with_http_info(ray_job_submission_db_id, **kwargs)  # noqa: E501

    def get_decorated_job_submission_api_v2_decorated_job_submissions_ray_job_submission_db_id_get_with_http_info(self, ray_job_submission_db_id, **kwargs):  # noqa: E501
        """Get Decorated Job Submission  # noqa: E501

        Get the job submission based on its db id.  Returns ------- Response[DecoratedJobSubmission]     selected DecoratedJobSubmission based on the passed in db id  Raises ------ HTTPException(status_code=400)     if the provided job submision db id does not exist  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_decorated_job_submission_api_v2_decorated_job_submissions_ray_job_submission_db_id_get_with_http_info(ray_job_submission_db_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str ray_job_submission_db_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedjobsubmissionResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'ray_job_submission_db_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_decorated_job_submission_api_v2_decorated_job_submissions_ray_job_submission_db_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'ray_job_submission_db_id' is set
        if self.api_client.client_side_validation and ('ray_job_submission_db_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['ray_job_submission_db_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `ray_job_submission_db_id` when calling `get_decorated_job_submission_api_v2_decorated_job_submissions_ray_job_submission_db_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ray_job_submission_db_id' in local_var_params:
            path_params['ray_job_submission_db_id'] = local_var_params['ray_job_submission_db_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/decorated_job_submissions/{ray_job_submission_db_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedjobsubmissionResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_decorated_job_submission_logs_api_v2_decorated_job_submissions_ray_job_submission_db_id_logs_get(self, ray_job_submission_db_id, **kwargs):  # noqa: E501
        """Get Decorated Job Submission Logs  # noqa: E501

        Get a job submission logs by ray_job_submission_db_id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_decorated_job_submission_logs_api_v2_decorated_job_submissions_ray_job_submission_db_id_logs_get(ray_job_submission_db_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str ray_job_submission_db_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InteractivesessionlogsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_decorated_job_submission_logs_api_v2_decorated_job_submissions_ray_job_submission_db_id_logs_get_with_http_info(ray_job_submission_db_id, **kwargs)  # noqa: E501

    def get_decorated_job_submission_logs_api_v2_decorated_job_submissions_ray_job_submission_db_id_logs_get_with_http_info(self, ray_job_submission_db_id, **kwargs):  # noqa: E501
        """Get Decorated Job Submission Logs  # noqa: E501

        Get a job submission logs by ray_job_submission_db_id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_decorated_job_submission_logs_api_v2_decorated_job_submissions_ray_job_submission_db_id_logs_get_with_http_info(ray_job_submission_db_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str ray_job_submission_db_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InteractivesessionlogsResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'ray_job_submission_db_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_decorated_job_submission_logs_api_v2_decorated_job_submissions_ray_job_submission_db_id_logs_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'ray_job_submission_db_id' is set
        if self.api_client.client_side_validation and ('ray_job_submission_db_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['ray_job_submission_db_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `ray_job_submission_db_id` when calling `get_decorated_job_submission_logs_api_v2_decorated_job_submissions_ray_job_submission_db_id_logs_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ray_job_submission_db_id' in local_var_params:
            path_params['ray_job_submission_db_id'] = local_var_params['ray_job_submission_db_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/decorated_job_submissions/{ray_job_submission_db_id}/logs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InteractivesessionlogsResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_decorated_runtime_env_api_v2_decorated_runtime_envs_runtime_env_id_get(self, runtime_env_id, **kwargs):  # noqa: E501
        """Get Decorated Runtime Env  # noqa: E501

        Get a single Runtime Environment by id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_decorated_runtime_env_api_v2_decorated_runtime_envs_runtime_env_id_get(runtime_env_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str runtime_env_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedruntimeenvResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_decorated_runtime_env_api_v2_decorated_runtime_envs_runtime_env_id_get_with_http_info(runtime_env_id, **kwargs)  # noqa: E501

    def get_decorated_runtime_env_api_v2_decorated_runtime_envs_runtime_env_id_get_with_http_info(self, runtime_env_id, **kwargs):  # noqa: E501
        """Get Decorated Runtime Env  # noqa: E501

        Get a single Runtime Environment by id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_decorated_runtime_env_api_v2_decorated_runtime_envs_runtime_env_id_get_with_http_info(runtime_env_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str runtime_env_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedruntimeenvResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'runtime_env_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_decorated_runtime_env_api_v2_decorated_runtime_envs_runtime_env_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'runtime_env_id' is set
        if self.api_client.client_side_validation and ('runtime_env_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['runtime_env_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `runtime_env_id` when calling `get_decorated_runtime_env_api_v2_decorated_runtime_envs_runtime_env_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'runtime_env_id' in local_var_params:
            path_params['runtime_env_id'] = local_var_params['runtime_env_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/decorated_runtime_envs/{runtime_env_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedruntimeenvResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_decorated_serve_deployment_api_v2_decorated_serve_deployments_serve_deloyment_id_get(self, serve_deloyment_id, **kwargs):  # noqa: E501
        """Get Decorated Serve Deployment  # noqa: E501

        Get a decorated serve deployment  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_decorated_serve_deployment_api_v2_decorated_serve_deployments_serve_deloyment_id_get(serve_deloyment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str serve_deloyment_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedservedeploymentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_decorated_serve_deployment_api_v2_decorated_serve_deployments_serve_deloyment_id_get_with_http_info(serve_deloyment_id, **kwargs)  # noqa: E501

    def get_decorated_serve_deployment_api_v2_decorated_serve_deployments_serve_deloyment_id_get_with_http_info(self, serve_deloyment_id, **kwargs):  # noqa: E501
        """Get Decorated Serve Deployment  # noqa: E501

        Get a decorated serve deployment  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_decorated_serve_deployment_api_v2_decorated_serve_deployments_serve_deloyment_id_get_with_http_info(serve_deloyment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str serve_deloyment_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedservedeploymentResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'serve_deloyment_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_decorated_serve_deployment_api_v2_decorated_serve_deployments_serve_deloyment_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'serve_deloyment_id' is set
        if self.api_client.client_side_validation and ('serve_deloyment_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['serve_deloyment_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `serve_deloyment_id` when calling `get_decorated_serve_deployment_api_v2_decorated_serve_deployments_serve_deloyment_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'serve_deloyment_id' in local_var_params:
            path_params['serve_deloyment_id'] = local_var_params['serve_deloyment_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/decorated_serve_deployments/{serve_deloyment_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedservedeploymentResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_decorated_serve_deployment_logs_api_v2_decorated_serve_deployments_serve_deployment_id_logs_get(self, serve_deployment_id, **kwargs):  # noqa: E501
        """Get Decorated Serve Deployment Logs  # noqa: E501

        Get a serve deployment logs by db id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_decorated_serve_deployment_logs_api_v2_decorated_serve_deployments_serve_deployment_id_logs_get(serve_deployment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str serve_deployment_id: (required)
        :param str cluster_id: A cluster id to filter by
        :param str deployment_name: A cluster id to filter by
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ServedeploymentlogsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_decorated_serve_deployment_logs_api_v2_decorated_serve_deployments_serve_deployment_id_logs_get_with_http_info(serve_deployment_id, **kwargs)  # noqa: E501

    def get_decorated_serve_deployment_logs_api_v2_decorated_serve_deployments_serve_deployment_id_logs_get_with_http_info(self, serve_deployment_id, **kwargs):  # noqa: E501
        """Get Decorated Serve Deployment Logs  # noqa: E501

        Get a serve deployment logs by db id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_decorated_serve_deployment_logs_api_v2_decorated_serve_deployments_serve_deployment_id_logs_get_with_http_info(serve_deployment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str serve_deployment_id: (required)
        :param str cluster_id: A cluster id to filter by
        :param str deployment_name: A cluster id to filter by
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ServedeploymentlogsResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'serve_deployment_id',
            'cluster_id',
            'deployment_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_decorated_serve_deployment_logs_api_v2_decorated_serve_deployments_serve_deployment_id_logs_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'serve_deployment_id' is set
        if self.api_client.client_side_validation and ('serve_deployment_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['serve_deployment_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `serve_deployment_id` when calling `get_decorated_serve_deployment_logs_api_v2_decorated_serve_deployments_serve_deployment_id_logs_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'serve_deployment_id' in local_var_params:
            path_params['serve_deployment_id'] = local_var_params['serve_deployment_id']  # noqa: E501

        query_params = []
        if 'cluster_id' in local_var_params and local_var_params['cluster_id'] is not None:  # noqa: E501
            query_params.append(('cluster_id', local_var_params['cluster_id']))  # noqa: E501
        if 'deployment_name' in local_var_params and local_var_params['deployment_name'] is not None:  # noqa: E501
            query_params.append(('deployment_name', local_var_params['deployment_name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/decorated_serve_deployments/{serve_deployment_id}/logs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ServedeploymentlogsResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_decorated_support_request_for_user_organization_api_v2_support_requests_get(self, **kwargs):  # noqa: E501
        """Get Decorated Support Request For User Organization  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_decorated_support_request_for_user_organization_api_v2_support_requests_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedsupportrequestResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_decorated_support_request_for_user_organization_api_v2_support_requests_get_with_http_info(**kwargs)  # noqa: E501

    def get_decorated_support_request_for_user_organization_api_v2_support_requests_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get Decorated Support Request For User Organization  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_decorated_support_request_for_user_organization_api_v2_support_requests_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedsupportrequestResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_decorated_support_request_for_user_organization_api_v2_support_requests_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/support_requests/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedsupportrequestResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_default_cluster_env_build_api_v2_builds_default_py_version_ray_version_get(self, py_version, ray_version, **kwargs):  # noqa: E501
        """Get Default Cluster Env Build  # noqa: E501

        Retrieves default build.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_default_cluster_env_build_api_v2_builds_default_py_version_ray_version_get(py_version, ray_version, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str py_version: (required)
        :param str ray_version: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedbuildResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_default_cluster_env_build_api_v2_builds_default_py_version_ray_version_get_with_http_info(py_version, ray_version, **kwargs)  # noqa: E501

    def get_default_cluster_env_build_api_v2_builds_default_py_version_ray_version_get_with_http_info(self, py_version, ray_version, **kwargs):  # noqa: E501
        """Get Default Cluster Env Build  # noqa: E501

        Retrieves default build.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_default_cluster_env_build_api_v2_builds_default_py_version_ray_version_get_with_http_info(py_version, ray_version, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str py_version: (required)
        :param str ray_version: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedbuildResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'py_version',
            'ray_version'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_default_cluster_env_build_api_v2_builds_default_py_version_ray_version_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'py_version' is set
        if self.api_client.client_side_validation and ('py_version' not in local_var_params or  # noqa: E501
                                                        local_var_params['py_version'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `py_version` when calling `get_default_cluster_env_build_api_v2_builds_default_py_version_ray_version_get`")  # noqa: E501
        # verify the required parameter 'ray_version' is set
        if self.api_client.client_side_validation and ('ray_version' not in local_var_params or  # noqa: E501
                                                        local_var_params['ray_version'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `ray_version` when calling `get_default_cluster_env_build_api_v2_builds_default_py_version_ray_version_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'py_version' in local_var_params:
            path_params['py_version'] = local_var_params['py_version']  # noqa: E501
        if 'ray_version' in local_var_params:
            path_params['ray_version'] = local_var_params['ray_version']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/builds/default/{py_version}/{ray_version}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedbuildResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_default_compute_config_api_v2_compute_templates_default_cloud_id_get(self, cloud_id, **kwargs):  # noqa: E501
        """Get Default Compute Config  # noqa: E501

        Return a default compute configuration for this cloud.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_default_compute_config_api_v2_compute_templates_default_cloud_id_get(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ComputetemplateconfigResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_default_compute_config_api_v2_compute_templates_default_cloud_id_get_with_http_info(cloud_id, **kwargs)  # noqa: E501

    def get_default_compute_config_api_v2_compute_templates_default_cloud_id_get_with_http_info(self, cloud_id, **kwargs):  # noqa: E501
        """Get Default Compute Config  # noqa: E501

        Return a default compute configuration for this cloud.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_default_compute_config_api_v2_compute_templates_default_cloud_id_get_with_http_info(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ComputetemplateconfigResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_default_compute_config_api_v2_compute_templates_default_cloud_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `get_default_compute_config_api_v2_compute_templates_default_cloud_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/compute_templates/default/{cloud_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ComputetemplateconfigResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_default_project_api_v2_projects_default_project_get(self, **kwargs):  # noqa: E501
        """Get Default Project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_default_project_api_v2_projects_default_project_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str parent_cloud_id: Cloud to fetch this default project for. This is only required if cloud isolation is enabled.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ProjectResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_default_project_api_v2_projects_default_project_get_with_http_info(**kwargs)  # noqa: E501

    def get_default_project_api_v2_projects_default_project_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get Default Project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_default_project_api_v2_projects_default_project_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str parent_cloud_id: Cloud to fetch this default project for. This is only required if cloud isolation is enabled.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ProjectResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'parent_cloud_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_default_project_api_v2_projects_default_project_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'parent_cloud_id' in local_var_params and local_var_params['parent_cloud_id'] is not None:  # noqa: E501
            query_params.append(('parent_cloud_id', local_var_params['parent_cloud_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/projects/default_project', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ProjectResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_edit_payment_information_url_api_v2_organization_billing_edit_payment_information_url_get(self, **kwargs):  # noqa: E501
        """Get Edit Payment Information Url  # noqa: E501

        Returns URL to edit Chargify active payment information.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_edit_payment_information_url_api_v2_organization_billing_edit_payment_information_url_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_edit_payment_information_url_api_v2_organization_billing_edit_payment_information_url_get_with_http_info(**kwargs)  # noqa: E501

    def get_edit_payment_information_url_api_v2_organization_billing_edit_payment_information_url_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get Edit Payment Information Url  # noqa: E501

        Returns URL to edit Chargify active payment information.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_edit_payment_information_url_api_v2_organization_billing_edit_payment_information_url_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(str, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_edit_payment_information_url_api_v2_organization_billing_edit_payment_information_url_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organization_billing/edit_payment_information_url', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_endpoint_api_v2_aica_endpoints_endpoint_id_get(self, endpoint_id, **kwargs):  # noqa: E501
        """Get Endpoint  # noqa: E501

        Get an endpoint by id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_endpoint_api_v2_aica_endpoints_endpoint_id_get(endpoint_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str endpoint_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AicaEndpoint
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_endpoint_api_v2_aica_endpoints_endpoint_id_get_with_http_info(endpoint_id, **kwargs)  # noqa: E501

    def get_endpoint_api_v2_aica_endpoints_endpoint_id_get_with_http_info(self, endpoint_id, **kwargs):  # noqa: E501
        """Get Endpoint  # noqa: E501

        Get an endpoint by id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_endpoint_api_v2_aica_endpoints_endpoint_id_get_with_http_info(endpoint_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str endpoint_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AicaEndpoint, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'endpoint_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_endpoint_api_v2_aica_endpoints_endpoint_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'endpoint_id' is set
        if self.api_client.client_side_validation and ('endpoint_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['endpoint_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `endpoint_id` when calling `get_endpoint_api_v2_aica_endpoints_endpoint_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'endpoint_id' in local_var_params:
            path_params['endpoint_id'] = local_var_params['endpoint_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/aica_endpoints/{endpoint_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AicaEndpoint',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_events_api_v2_sessions_session_id_events_get(self, session_id, start_index, end_index, **kwargs):  # noqa: E501
        """Get Events  # noqa: E501

        Return events for this cluster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_events_api_v2_sessions_session_id_events_get(session_id, start_index, end_index, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param int start_index: (required)
        :param int end_index: (required)
        :param datetime start_time:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ClustereventsoutputResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_events_api_v2_sessions_session_id_events_get_with_http_info(session_id, start_index, end_index, **kwargs)  # noqa: E501

    def get_events_api_v2_sessions_session_id_events_get_with_http_info(self, session_id, start_index, end_index, **kwargs):  # noqa: E501
        """Get Events  # noqa: E501

        Return events for this cluster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_events_api_v2_sessions_session_id_events_get_with_http_info(session_id, start_index, end_index, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param int start_index: (required)
        :param int end_index: (required)
        :param datetime start_time:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ClustereventsoutputResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'session_id',
            'start_index',
            'end_index',
            'start_time'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_events_api_v2_sessions_session_id_events_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'session_id' is set
        if self.api_client.client_side_validation and ('session_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_id` when calling `get_events_api_v2_sessions_session_id_events_get`")  # noqa: E501
        # verify the required parameter 'start_index' is set
        if self.api_client.client_side_validation and ('start_index' not in local_var_params or  # noqa: E501
                                                        local_var_params['start_index'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `start_index` when calling `get_events_api_v2_sessions_session_id_events_get`")  # noqa: E501
        # verify the required parameter 'end_index' is set
        if self.api_client.client_side_validation and ('end_index' not in local_var_params or  # noqa: E501
                                                        local_var_params['end_index'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `end_index` when calling `get_events_api_v2_sessions_session_id_events_get`")  # noqa: E501

        if self.api_client.client_side_validation and 'start_index' in local_var_params and local_var_params['start_index'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `start_index` when calling `get_events_api_v2_sessions_session_id_events_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'session_id' in local_var_params:
            path_params['session_id'] = local_var_params['session_id']  # noqa: E501

        query_params = []
        if 'start_index' in local_var_params and local_var_params['start_index'] is not None:  # noqa: E501
            query_params.append(('start_index', local_var_params['start_index']))  # noqa: E501
        if 'end_index' in local_var_params and local_var_params['end_index'] is not None:  # noqa: E501
            query_params.append(('end_index', local_var_params['end_index']))  # noqa: E501
        if 'start_time' in local_var_params and local_var_params['start_time'] is not None:  # noqa: E501
            query_params.append(('start_time', local_var_params['start_time']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/sessions/{session_id}/events', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClustereventsoutputResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_execution_logs_api_v2_session_commands_session_command_id_execution_logs_get(self, session_command_id, start_line, end_line, **kwargs):  # noqa: E501
        """Get Execution Logs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_execution_logs_api_v2_session_commands_session_command_id_execution_logs_get(session_command_id, start_line, end_line, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_command_id: (required)
        :param int start_line: (required)
        :param int end_line: (required)
        :param str extension:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: LogsoutputResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_execution_logs_api_v2_session_commands_session_command_id_execution_logs_get_with_http_info(session_command_id, start_line, end_line, **kwargs)  # noqa: E501

    def get_execution_logs_api_v2_session_commands_session_command_id_execution_logs_get_with_http_info(self, session_command_id, start_line, end_line, **kwargs):  # noqa: E501
        """Get Execution Logs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_execution_logs_api_v2_session_commands_session_command_id_execution_logs_get_with_http_info(session_command_id, start_line, end_line, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_command_id: (required)
        :param int start_line: (required)
        :param int end_line: (required)
        :param str extension:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(LogsoutputResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'session_command_id',
            'start_line',
            'end_line',
            'extension'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_execution_logs_api_v2_session_commands_session_command_id_execution_logs_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'session_command_id' is set
        if self.api_client.client_side_validation and ('session_command_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_command_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_command_id` when calling `get_execution_logs_api_v2_session_commands_session_command_id_execution_logs_get`")  # noqa: E501
        # verify the required parameter 'start_line' is set
        if self.api_client.client_side_validation and ('start_line' not in local_var_params or  # noqa: E501
                                                        local_var_params['start_line'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `start_line` when calling `get_execution_logs_api_v2_session_commands_session_command_id_execution_logs_get`")  # noqa: E501
        # verify the required parameter 'end_line' is set
        if self.api_client.client_side_validation and ('end_line' not in local_var_params or  # noqa: E501
                                                        local_var_params['end_line'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `end_line` when calling `get_execution_logs_api_v2_session_commands_session_command_id_execution_logs_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'session_command_id' in local_var_params:
            path_params['session_command_id'] = local_var_params['session_command_id']  # noqa: E501

        query_params = []
        if 'start_line' in local_var_params and local_var_params['start_line'] is not None:  # noqa: E501
            query_params.append(('start_line', local_var_params['start_line']))  # noqa: E501
        if 'end_line' in local_var_params and local_var_params['end_line'] is not None:  # noqa: E501
            query_params.append(('end_line', local_var_params['end_line']))  # noqa: E501
        if 'extension' in local_var_params and local_var_params['extension'] is not None:  # noqa: E501
            query_params.append(('extension', local_var_params['extension']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/session_commands/{session_command_id}/execution_logs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogsoutputResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_execution_logs_archived_api_v2_session_commands_session_command_id_execution_logs_archived_get(self, session_command_id, **kwargs):  # noqa: E501
        """Get Execution Logs Archived  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_execution_logs_archived_api_v2_session_commands_session_command_id_execution_logs_archived_get(session_command_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_command_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ArchivedlogsinfoResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_execution_logs_archived_api_v2_session_commands_session_command_id_execution_logs_archived_get_with_http_info(session_command_id, **kwargs)  # noqa: E501

    def get_execution_logs_archived_api_v2_session_commands_session_command_id_execution_logs_archived_get_with_http_info(self, session_command_id, **kwargs):  # noqa: E501
        """Get Execution Logs Archived  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_execution_logs_archived_api_v2_session_commands_session_command_id_execution_logs_archived_get_with_http_info(session_command_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_command_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ArchivedlogsinfoResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'session_command_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_execution_logs_archived_api_v2_session_commands_session_command_id_execution_logs_archived_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'session_command_id' is set
        if self.api_client.client_side_validation and ('session_command_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_command_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_command_id` when calling `get_execution_logs_archived_api_v2_session_commands_session_command_id_execution_logs_archived_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'session_command_id' in local_var_params:
            path_params['session_command_id'] = local_var_params['session_command_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/session_commands/{session_command_id}/execution_logs_archived', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ArchivedlogsinfoResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_feature_compatibility_api_v2_product_features_get(self, **kwargs):  # noqa: E501
        """Get Feature Compatibility  # noqa: E501

        Retrieve the compatibility of product features with a ray version  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_feature_compatibility_api_v2_product_features_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: A cluster to query the ray version of.
        :param str ray_version_str: A ray version to test feature compatibility with.Useful for preemptively testing ray version of clusters that haven't started yet
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ClusterfeaturesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_feature_compatibility_api_v2_product_features_get_with_http_info(**kwargs)  # noqa: E501

    def get_feature_compatibility_api_v2_product_features_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get Feature Compatibility  # noqa: E501

        Retrieve the compatibility of product features with a ray version  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_feature_compatibility_api_v2_product_features_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: A cluster to query the ray version of.
        :param str ray_version_str: A ray version to test feature compatibility with.Useful for preemptively testing ray version of clusters that haven't started yet
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ClusterfeaturesResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cluster_id',
            'ray_version_str'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_feature_compatibility_api_v2_product_features_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cluster_id' in local_var_params and local_var_params['cluster_id'] is not None:  # noqa: E501
            query_params.append(('cluster_id', local_var_params['cluster_id']))  # noqa: E501
        if 'ray_version_str' in local_var_params and local_var_params['ray_version_str'] is not None:  # noqa: E501
            query_params.append(('ray_version_str', local_var_params['ray_version_str']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/product_features/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClusterfeaturesResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_file_api_v2_files_file_id_get(self, file_id, **kwargs):  # noqa: E501
        """Get File  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_file_api_v2_files_file_id_get(file_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str file_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: FilemodelResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_file_api_v2_files_file_id_get_with_http_info(file_id, **kwargs)  # noqa: E501

    def get_file_api_v2_files_file_id_get_with_http_info(self, file_id, **kwargs):  # noqa: E501
        """Get File  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_file_api_v2_files_file_id_get_with_http_info(file_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str file_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(FilemodelResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'file_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_file_api_v2_files_file_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'file_id' is set
        if self.api_client.client_side_validation and ('file_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['file_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `file_id` when calling `get_file_api_v2_files_file_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'file_id' in local_var_params:
            path_params['file_id'] = local_var_params['file_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/files/{file_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FilemodelResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_file_upload_url_api_v2_files_upload_url_post(self, presigned_upload_file_request, **kwargs):  # noqa: E501
        """Get File Upload Url  # noqa: E501

        Returns a presigned url that allows the clients to upload the file to cloud storage  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_file_upload_url_api_v2_files_upload_url_post(presigned_upload_file_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param PresignedUploadFileRequest presigned_upload_file_request: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PresignedUploadFile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_file_upload_url_api_v2_files_upload_url_post_with_http_info(presigned_upload_file_request, **kwargs)  # noqa: E501

    def get_file_upload_url_api_v2_files_upload_url_post_with_http_info(self, presigned_upload_file_request, **kwargs):  # noqa: E501
        """Get File Upload Url  # noqa: E501

        Returns a presigned url that allows the clients to upload the file to cloud storage  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_file_upload_url_api_v2_files_upload_url_post_with_http_info(presigned_upload_file_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param PresignedUploadFileRequest presigned_upload_file_request: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PresignedUploadFile, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'presigned_upload_file_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_file_upload_url_api_v2_files_upload_url_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'presigned_upload_file_request' is set
        if self.api_client.client_side_validation and ('presigned_upload_file_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['presigned_upload_file_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `presigned_upload_file_request` when calling `get_file_upload_url_api_v2_files_upload_url_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'presigned_upload_file_request' in local_var_params:
            body_params = local_var_params['presigned_upload_file_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/files/upload_url', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PresignedUploadFile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_fine_tuning_job_api_v2_fine_tuning_jobs_fine_tuning_job_id_get(self, fine_tuning_job_id, **kwargs):  # noqa: E501
        """Get Fine Tuning Job  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_fine_tuning_job_api_v2_fine_tuning_jobs_fine_tuning_job_id_get(fine_tuning_job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str fine_tuning_job_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PlatformfinetuningjobResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_fine_tuning_job_api_v2_fine_tuning_jobs_fine_tuning_job_id_get_with_http_info(fine_tuning_job_id, **kwargs)  # noqa: E501

    def get_fine_tuning_job_api_v2_fine_tuning_jobs_fine_tuning_job_id_get_with_http_info(self, fine_tuning_job_id, **kwargs):  # noqa: E501
        """Get Fine Tuning Job  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_fine_tuning_job_api_v2_fine_tuning_jobs_fine_tuning_job_id_get_with_http_info(fine_tuning_job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str fine_tuning_job_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PlatformfinetuningjobResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'fine_tuning_job_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_fine_tuning_job_api_v2_fine_tuning_jobs_fine_tuning_job_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'fine_tuning_job_id' is set
        if self.api_client.client_side_validation and ('fine_tuning_job_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['fine_tuning_job_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `fine_tuning_job_id` when calling `get_fine_tuning_job_api_v2_fine_tuning_jobs_fine_tuning_job_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'fine_tuning_job_id' in local_var_params:
            path_params['fine_tuning_job_id'] = local_var_params['fine_tuning_job_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/fine_tuning/jobs/{fine_tuning_job_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PlatformfinetuningjobResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_invitation_api_v2_organization_invitations_invitation_id_get(self, invitation_id, **kwargs):  # noqa: E501
        """Get Invitation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_invitation_api_v2_organization_invitations_invitation_id_get(invitation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str invitation_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: OrganizationinvitationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_invitation_api_v2_organization_invitations_invitation_id_get_with_http_info(invitation_id, **kwargs)  # noqa: E501

    def get_invitation_api_v2_organization_invitations_invitation_id_get_with_http_info(self, invitation_id, **kwargs):  # noqa: E501
        """Get Invitation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_invitation_api_v2_organization_invitations_invitation_id_get_with_http_info(invitation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str invitation_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(OrganizationinvitationResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'invitation_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_invitation_api_v2_organization_invitations_invitation_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'invitation_id' is set
        if self.api_client.client_side_validation and ('invitation_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['invitation_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `invitation_id` when calling `get_invitation_api_v2_organization_invitations_invitation_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'invitation_id' in local_var_params:
            path_params['invitation_id'] = local_var_params['invitation_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organization_invitations/{invitation_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OrganizationinvitationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_job_api_v2_decorated_ha_jobs_production_job_id_get(self, production_job_id, **kwargs):  # noqa: E501
        """Get Job  # noqa: E501

        Get an HA Job  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_api_v2_decorated_ha_jobs_production_job_id_get(production_job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str production_job_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedproductionjobResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_job_api_v2_decorated_ha_jobs_production_job_id_get_with_http_info(production_job_id, **kwargs)  # noqa: E501

    def get_job_api_v2_decorated_ha_jobs_production_job_id_get_with_http_info(self, production_job_id, **kwargs):  # noqa: E501
        """Get Job  # noqa: E501

        Get an HA Job  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_api_v2_decorated_ha_jobs_production_job_id_get_with_http_info(production_job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str production_job_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedproductionjobResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'production_job_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_job_api_v2_decorated_ha_jobs_production_job_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'production_job_id' is set
        if self.api_client.client_side_validation and ('production_job_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['production_job_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `production_job_id` when calling `get_job_api_v2_decorated_ha_jobs_production_job_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'production_job_id' in local_var_params:
            path_params['production_job_id'] = local_var_params['production_job_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/decorated_ha_jobs/{production_job_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedproductionjobResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_job_api_v2_decorated_unified_jobs_job_id_get(self, job_id, **kwargs):  # noqa: E501
        """Get Job  # noqa: E501

        Retrieve a job.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_api_v2_decorated_unified_jobs_job_id_get(job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str job_id: The ID of the job. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedunifiedjobResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_job_api_v2_decorated_unified_jobs_job_id_get_with_http_info(job_id, **kwargs)  # noqa: E501

    def get_job_api_v2_decorated_unified_jobs_job_id_get_with_http_info(self, job_id, **kwargs):  # noqa: E501
        """Get Job  # noqa: E501

        Retrieve a job.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_api_v2_decorated_unified_jobs_job_id_get_with_http_info(job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str job_id: The ID of the job. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedunifiedjobResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'job_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_job_api_v2_decorated_unified_jobs_job_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'job_id' is set
        if self.api_client.client_side_validation and ('job_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['job_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `job_id` when calling `get_job_api_v2_decorated_unified_jobs_job_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'job_id' in local_var_params:
            path_params['job_id'] = local_var_params['job_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/decorated_unified_jobs/{job_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedunifiedjobResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_job_logs_download_api_v2_logs_job_logs_download_job_id_get(self, job_id, **kwargs):  # noqa: E501
        """Get Job Logs Download  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_logs_download_api_v2_logs_job_logs_download_job_id_get(job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str job_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: LogdownloadresultResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_job_logs_download_api_v2_logs_job_logs_download_job_id_get_with_http_info(job_id, **kwargs)  # noqa: E501

    def get_job_logs_download_api_v2_logs_job_logs_download_job_id_get_with_http_info(self, job_id, **kwargs):  # noqa: E501
        """Get Job Logs Download  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_logs_download_api_v2_logs_job_logs_download_job_id_get_with_http_info(job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str job_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(LogdownloadresultResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'job_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_job_logs_download_api_v2_logs_job_logs_download_job_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'job_id' is set
        if self.api_client.client_side_validation and ('job_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['job_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `job_id` when calling `get_job_logs_download_api_v2_logs_job_logs_download_job_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'job_id' in local_var_params:
            path_params['job_id'] = local_var_params['job_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/logs/job_logs_download/{job_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogdownloadresultResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_job_logs_download_v2_api_v2_logs_job_logs_download_v2_job_id_get(self, job_id, **kwargs):  # noqa: E501
        """Get Job Logs Download V2  # noqa: E501

        Fetches the job logs of a single job run. This is a single API that supports job logs no matter if the job is still running or not.  If the job is still running, the logs will be fetched from the streaming logs s3 path. If the job is not running, the logs will be fetched from downloaded logs s3 path. If a pagination token is provided, we use the streaming logs or downloaded logs path depending on the format of the pagination token.  TODO(aguo): Implement job alive or dead detection  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_logs_download_v2_api_v2_logs_job_logs_download_v2_job_id_get(job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str job_id: (required)
        :param int page_size: Number of chunks to fetch. Defaults to 400. Max of 1000.
        :param str next_page_token: Pagination token for getting newer logs.
        :param str previous_page_token: Pagination token for getting older logs.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: LogdownloadresultResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_job_logs_download_v2_api_v2_logs_job_logs_download_v2_job_id_get_with_http_info(job_id, **kwargs)  # noqa: E501

    def get_job_logs_download_v2_api_v2_logs_job_logs_download_v2_job_id_get_with_http_info(self, job_id, **kwargs):  # noqa: E501
        """Get Job Logs Download V2  # noqa: E501

        Fetches the job logs of a single job run. This is a single API that supports job logs no matter if the job is still running or not.  If the job is still running, the logs will be fetched from the streaming logs s3 path. If the job is not running, the logs will be fetched from downloaded logs s3 path. If a pagination token is provided, we use the streaming logs or downloaded logs path depending on the format of the pagination token.  TODO(aguo): Implement job alive or dead detection  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_logs_download_v2_api_v2_logs_job_logs_download_v2_job_id_get_with_http_info(job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str job_id: (required)
        :param int page_size: Number of chunks to fetch. Defaults to 400. Max of 1000.
        :param str next_page_token: Pagination token for getting newer logs.
        :param str previous_page_token: Pagination token for getting older logs.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(LogdownloadresultResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'job_id',
            'page_size',
            'next_page_token',
            'previous_page_token'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_job_logs_download_v2_api_v2_logs_job_logs_download_v2_job_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'job_id' is set
        if self.api_client.client_side_validation and ('job_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['job_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `job_id` when calling `get_job_logs_download_v2_api_v2_logs_job_logs_download_v2_job_id_get`")  # noqa: E501

        if self.api_client.client_side_validation and 'page_size' in local_var_params and local_var_params['page_size'] > 1000:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `page_size` when calling `get_job_logs_download_v2_api_v2_logs_job_logs_download_v2_job_id_get`, must be a value less than or equal to `1000`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'job_id' in local_var_params:
            path_params['job_id'] = local_var_params['job_id']  # noqa: E501

        query_params = []
        if 'page_size' in local_var_params and local_var_params['page_size'] is not None:  # noqa: E501
            query_params.append(('page_size', local_var_params['page_size']))  # noqa: E501
        if 'next_page_token' in local_var_params and local_var_params['next_page_token'] is not None:  # noqa: E501
            query_params.append(('next_page_token', local_var_params['next_page_token']))  # noqa: E501
        if 'previous_page_token' in local_var_params and local_var_params['previous_page_token'] is not None:  # noqa: E501
            query_params.append(('previous_page_token', local_var_params['previous_page_token']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/logs/job_logs_download_v2/{job_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogdownloadresultResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_job_logs_query_info_api_v2_decorated_ha_jobs_production_job_id_logs_query_get(self, production_job_id, **kwargs):  # noqa: E501
        """Get Job Logs Query Info  # noqa: E501

        Retrieves necessary info to query the latest job run's log.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_logs_query_info_api_v2_decorated_ha_jobs_production_job_id_logs_query_get(production_job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str production_job_id: ID of the production job to fetch logs for. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: JobslogsqueryinfoResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_job_logs_query_info_api_v2_decorated_ha_jobs_production_job_id_logs_query_get_with_http_info(production_job_id, **kwargs)  # noqa: E501

    def get_job_logs_query_info_api_v2_decorated_ha_jobs_production_job_id_logs_query_get_with_http_info(self, production_job_id, **kwargs):  # noqa: E501
        """Get Job Logs Query Info  # noqa: E501

        Retrieves necessary info to query the latest job run's log.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_logs_query_info_api_v2_decorated_ha_jobs_production_job_id_logs_query_get_with_http_info(production_job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str production_job_id: ID of the production job to fetch logs for. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(JobslogsqueryinfoResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'production_job_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_job_logs_query_info_api_v2_decorated_ha_jobs_production_job_id_logs_query_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'production_job_id' is set
        if self.api_client.client_side_validation and ('production_job_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['production_job_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `production_job_id` when calling `get_job_logs_query_info_api_v2_decorated_ha_jobs_production_job_id_logs_query_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'production_job_id' in local_var_params:
            path_params['production_job_id'] = local_var_params['production_job_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/decorated_ha_jobs/{production_job_id}/logs_query', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='JobslogsqueryinfoResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_job_logs_stream_api_v2_logs_job_logs_stream_job_id_get(self, job_id, **kwargs):  # noqa: E501
        """Get Job Logs Stream  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_logs_stream_api_v2_logs_job_logs_stream_job_id_get(job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str job_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: LogstreamResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_job_logs_stream_api_v2_logs_job_logs_stream_job_id_get_with_http_info(job_id, **kwargs)  # noqa: E501

    def get_job_logs_stream_api_v2_logs_job_logs_stream_job_id_get_with_http_info(self, job_id, **kwargs):  # noqa: E501
        """Get Job Logs Stream  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_logs_stream_api_v2_logs_job_logs_stream_job_id_get_with_http_info(job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str job_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(LogstreamResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'job_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_job_logs_stream_api_v2_logs_job_logs_stream_job_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'job_id' is set
        if self.api_client.client_side_validation and ('job_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['job_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `job_id` when calling `get_job_logs_stream_api_v2_logs_job_logs_stream_job_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'job_id' in local_var_params:
            path_params['job_id'] = local_var_params['job_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/logs/job_logs_stream/{job_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogstreamResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_lb_resource_api_v2_clouds_with_cloud_resource_gcp_router_cloud_id_get_lb_resource_post(self, cloud_id, **kwargs):  # noqa: E501
        """Get Lb Resource  # noqa: E501

        Get lb resources for the cloud.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_lb_resource_api_v2_clouds_with_cloud_resource_gcp_router_cloud_id_get_lb_resource_post(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: LbresourceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_lb_resource_api_v2_clouds_with_cloud_resource_gcp_router_cloud_id_get_lb_resource_post_with_http_info(cloud_id, **kwargs)  # noqa: E501

    def get_lb_resource_api_v2_clouds_with_cloud_resource_gcp_router_cloud_id_get_lb_resource_post_with_http_info(self, cloud_id, **kwargs):  # noqa: E501
        """Get Lb Resource  # noqa: E501

        Get lb resources for the cloud.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_lb_resource_api_v2_clouds_with_cloud_resource_gcp_router_cloud_id_get_lb_resource_post_with_http_info(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(LbresourceResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_lb_resource_api_v2_clouds_with_cloud_resource_gcp_router_cloud_id_get_lb_resource_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `get_lb_resource_api_v2_clouds_with_cloud_resource_gcp_router_cloud_id_get_lb_resource_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds_with_cloud_resource_gcp_router/{cloud_id}/get_lb_resource', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LbresourceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_log_files_api_v2_logs_get_log_files_post(self, **kwargs):  # noqa: E501
        """Get Log Files  # noqa: E501

        API for downloading logs of a session.   This is a paginated api, which means that a single call to this will result in one page of results (log files).  The page size and next page token (in LogDownloadRequest) can be used to list all log files, either iteratively or in a single go.   Parameters  ---------- log_download_request: LogDownloadRequest      Parameters to filter logs and control download. This is read from the request body.   Returns  -------  Response[LogDownloadResult]      List of logs files, with their presigned URL and next page token if there are more results.   Raises  ------  HTTPException(400)      If the user is using a cloud provider (currently non-AWS) that does not support this feature.   HTTPException(403)      If the user does not have access to the session.   HTTPException(404)      If the session or cloud could not be found in the DB.   HTTPException(500)      If there are any other errors while downloading logs.    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_log_files_api_v2_logs_get_log_files_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param LogDownloadRequest log_download_request:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: LogdownloadresultResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_log_files_api_v2_logs_get_log_files_post_with_http_info(**kwargs)  # noqa: E501

    def get_log_files_api_v2_logs_get_log_files_post_with_http_info(self, **kwargs):  # noqa: E501
        """Get Log Files  # noqa: E501

        API for downloading logs of a session.   This is a paginated api, which means that a single call to this will result in one page of results (log files).  The page size and next page token (in LogDownloadRequest) can be used to list all log files, either iteratively or in a single go.   Parameters  ---------- log_download_request: LogDownloadRequest      Parameters to filter logs and control download. This is read from the request body.   Returns  -------  Response[LogDownloadResult]      List of logs files, with their presigned URL and next page token if there are more results.   Raises  ------  HTTPException(400)      If the user is using a cloud provider (currently non-AWS) that does not support this feature.   HTTPException(403)      If the user does not have access to the session.   HTTPException(404)      If the session or cloud could not be found in the DB.   HTTPException(500)      If there are any other errors while downloading logs.    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_log_files_api_v2_logs_get_log_files_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param LogDownloadRequest log_download_request:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(LogdownloadresultResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'log_download_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_log_files_api_v2_logs_get_log_files_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'log_download_request' in local_var_params:
            body_params = local_var_params['log_download_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/logs/get_log_files', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogdownloadresultResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_log_files_api_v2_sessions_session_id_get_log_files_post(self, session_id, **kwargs):  # noqa: E501
        """Get Log Files  # noqa: E501

        API for downloading logs of a session.  This is a paginated api, which means that a single call to this will result in one page of results (log files). The page size and next page token (in LogDownloadRequest) can be used to list all log files, either iteratively or in a single go.  Parameters ---------- session_id: str     DB id of the session. This is a path parameter.     If session_id is 'latest', then atleast one of job_id or job_run must be provided in LogDownloadRequest.  log_download_request: Optional[LogDownloadRequest]     Parameters to filter logs and control download. This is read from the request body.  base_sessions_service: BaseSessionsService     The session service, which provides the necessary orchestration for downloading logs.  premission_service: SessionPermissionsService     The permission sercice. This is used to do authorization checks.  auth_context: AuthContext     The auth context of the user.  db_connections: Any     Connection to the DB.  Returns ------- Response[LogDetails]     List of logs files, with their presigned URL and next page token if there are more results.  Raises ------ HTTPException(401)     If the user does not have access to the session.  HTTPException(404)     If the session or cloud could not be found in the DB.  HTTPException(500)     If there are any other errors while downloading logs.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_log_files_api_v2_sessions_session_id_get_log_files_post(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: the session id or 'latest' (required)
        :param LogDownloadRequest log_download_request:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: LogdetailsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_log_files_api_v2_sessions_session_id_get_log_files_post_with_http_info(session_id, **kwargs)  # noqa: E501

    def get_log_files_api_v2_sessions_session_id_get_log_files_post_with_http_info(self, session_id, **kwargs):  # noqa: E501
        """Get Log Files  # noqa: E501

        API for downloading logs of a session.  This is a paginated api, which means that a single call to this will result in one page of results (log files). The page size and next page token (in LogDownloadRequest) can be used to list all log files, either iteratively or in a single go.  Parameters ---------- session_id: str     DB id of the session. This is a path parameter.     If session_id is 'latest', then atleast one of job_id or job_run must be provided in LogDownloadRequest.  log_download_request: Optional[LogDownloadRequest]     Parameters to filter logs and control download. This is read from the request body.  base_sessions_service: BaseSessionsService     The session service, which provides the necessary orchestration for downloading logs.  premission_service: SessionPermissionsService     The permission sercice. This is used to do authorization checks.  auth_context: AuthContext     The auth context of the user.  db_connections: Any     Connection to the DB.  Returns ------- Response[LogDetails]     List of logs files, with their presigned URL and next page token if there are more results.  Raises ------ HTTPException(401)     If the user does not have access to the session.  HTTPException(404)     If the session or cloud could not be found in the DB.  HTTPException(500)     If there are any other errors while downloading logs.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_log_files_api_v2_sessions_session_id_get_log_files_post_with_http_info(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: the session id or 'latest' (required)
        :param LogDownloadRequest log_download_request:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(LogdetailsResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'session_id',
            'log_download_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_log_files_api_v2_sessions_session_id_get_log_files_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'session_id' is set
        if self.api_client.client_side_validation and ('session_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_id` when calling `get_log_files_api_v2_sessions_session_id_get_log_files_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'session_id' in local_var_params:
            path_params['session_id'] = local_var_params['session_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'log_download_request' in local_var_params:
            body_params = local_var_params['log_download_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/sessions/{session_id}/get_log_files', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogdetailsResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_manage_billing_url_api_v2_organization_billing_manage_billing_url_get(self, **kwargs):  # noqa: E501
        """Get Manage Billing Url  # noqa: E501

        Returns URL to manage/edit billing information.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_manage_billing_url_api_v2_organization_billing_manage_billing_url_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_manage_billing_url_api_v2_organization_billing_manage_billing_url_get_with_http_info(**kwargs)  # noqa: E501

    def get_manage_billing_url_api_v2_organization_billing_manage_billing_url_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get Manage Billing Url  # noqa: E501

        Returns URL to manage/edit billing information.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_manage_billing_url_api_v2_organization_billing_manage_billing_url_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(str, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_manage_billing_url_api_v2_organization_billing_manage_billing_url_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organization_billing/manage_billing_url', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_metronome_embedded_usage_dashboard_api_v2_organization_billing_metronome_embedded_dashboard_url_dashboard_type_get(self, dashboard_type, **kwargs):  # noqa: E501
        """Get Metronome Embedded Usage Dashboard  # noqa: E501

        Returns the url to the Metronome embedded invoices dashboard if it exists.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_metronome_embedded_usage_dashboard_api_v2_organization_billing_metronome_embedded_dashboard_url_dashboard_type_get(dashboard_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param MetronomeDashboardType dashboard_type: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_metronome_embedded_usage_dashboard_api_v2_organization_billing_metronome_embedded_dashboard_url_dashboard_type_get_with_http_info(dashboard_type, **kwargs)  # noqa: E501

    def get_metronome_embedded_usage_dashboard_api_v2_organization_billing_metronome_embedded_dashboard_url_dashboard_type_get_with_http_info(self, dashboard_type, **kwargs):  # noqa: E501
        """Get Metronome Embedded Usage Dashboard  # noqa: E501

        Returns the url to the Metronome embedded invoices dashboard if it exists.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_metronome_embedded_usage_dashboard_api_v2_organization_billing_metronome_embedded_dashboard_url_dashboard_type_get_with_http_info(dashboard_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param MetronomeDashboardType dashboard_type: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(str, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'dashboard_type'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_metronome_embedded_usage_dashboard_api_v2_organization_billing_metronome_embedded_dashboard_url_dashboard_type_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'dashboard_type' is set
        if self.api_client.client_side_validation and ('dashboard_type' not in local_var_params or  # noqa: E501
                                                        local_var_params['dashboard_type'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `dashboard_type` when calling `get_metronome_embedded_usage_dashboard_api_v2_organization_billing_metronome_embedded_dashboard_url_dashboard_type_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dashboard_type' in local_var_params:
            path_params['dashboard_type'] = local_var_params['dashboard_type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organization_billing/metronome_embedded_dashboard_url/{dashboard_type}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_metronome_embedded_usage_dashboard_by_organization_api_v2_organization_billing_organization_id_metronome_embedded_dashboard_url_dashboard_type_get(self, organization_id, dashboard_type, **kwargs):  # noqa: E501
        """Get Metronome Embedded Usage Dashboard By Organization  # noqa: E501

        Returns the url to the Metronome embedded invoices dashboard if it exists.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_metronome_embedded_usage_dashboard_by_organization_api_v2_organization_billing_organization_id_metronome_embedded_dashboard_url_dashboard_type_get(organization_id, dashboard_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str organization_id: (required)
        :param MetronomeDashboardType dashboard_type: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_metronome_embedded_usage_dashboard_by_organization_api_v2_organization_billing_organization_id_metronome_embedded_dashboard_url_dashboard_type_get_with_http_info(organization_id, dashboard_type, **kwargs)  # noqa: E501

    def get_metronome_embedded_usage_dashboard_by_organization_api_v2_organization_billing_organization_id_metronome_embedded_dashboard_url_dashboard_type_get_with_http_info(self, organization_id, dashboard_type, **kwargs):  # noqa: E501
        """Get Metronome Embedded Usage Dashboard By Organization  # noqa: E501

        Returns the url to the Metronome embedded invoices dashboard if it exists.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_metronome_embedded_usage_dashboard_by_organization_api_v2_organization_billing_organization_id_metronome_embedded_dashboard_url_dashboard_type_get_with_http_info(organization_id, dashboard_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str organization_id: (required)
        :param MetronomeDashboardType dashboard_type: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(str, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'organization_id',
            'dashboard_type'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_metronome_embedded_usage_dashboard_by_organization_api_v2_organization_billing_organization_id_metronome_embedded_dashboard_url_dashboard_type_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_id' is set
        if self.api_client.client_side_validation and ('organization_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['organization_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_id` when calling `get_metronome_embedded_usage_dashboard_by_organization_api_v2_organization_billing_organization_id_metronome_embedded_dashboard_url_dashboard_type_get`")  # noqa: E501
        # verify the required parameter 'dashboard_type' is set
        if self.api_client.client_side_validation and ('dashboard_type' not in local_var_params or  # noqa: E501
                                                        local_var_params['dashboard_type'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `dashboard_type` when calling `get_metronome_embedded_usage_dashboard_by_organization_api_v2_organization_billing_organization_id_metronome_embedded_dashboard_url_dashboard_type_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_id' in local_var_params:
            path_params['organization_id'] = local_var_params['organization_id']  # noqa: E501
        if 'dashboard_type' in local_var_params:
            path_params['dashboard_type'] = local_var_params['dashboard_type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organization_billing/{organization_id}/metronome_embedded_dashboard_url/{dashboard_type}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_model_configuration_api_v2_aica_endpoints_model_config_get(self, aviary_version, model_name, **kwargs):  # noqa: E501
        """Get Model Configuration  # noqa: E501

        Get model configuration  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_model_configuration_api_v2_aica_endpoints_model_config_get(aviary_version, model_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str aviary_version: (required)
        :param str model_name: (required)
        :param str cloud_id:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AicaModelAcceleratorMap
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_model_configuration_api_v2_aica_endpoints_model_config_get_with_http_info(aviary_version, model_name, **kwargs)  # noqa: E501

    def get_model_configuration_api_v2_aica_endpoints_model_config_get_with_http_info(self, aviary_version, model_name, **kwargs):  # noqa: E501
        """Get Model Configuration  # noqa: E501

        Get model configuration  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_model_configuration_api_v2_aica_endpoints_model_config_get_with_http_info(aviary_version, model_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str aviary_version: (required)
        :param str model_name: (required)
        :param str cloud_id:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AicaModelAcceleratorMap, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'aviary_version',
            'model_name',
            'cloud_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_model_configuration_api_v2_aica_endpoints_model_config_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'aviary_version' is set
        if self.api_client.client_side_validation and ('aviary_version' not in local_var_params or  # noqa: E501
                                                        local_var_params['aviary_version'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `aviary_version` when calling `get_model_configuration_api_v2_aica_endpoints_model_config_get`")  # noqa: E501
        # verify the required parameter 'model_name' is set
        if self.api_client.client_side_validation and ('model_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['model_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `model_name` when calling `get_model_configuration_api_v2_aica_endpoints_model_config_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'aviary_version' in local_var_params and local_var_params['aviary_version'] is not None:  # noqa: E501
            query_params.append(('aviary_version', local_var_params['aviary_version']))  # noqa: E501
        if 'model_name' in local_var_params and local_var_params['model_name'] is not None:  # noqa: E501
            query_params.append(('model_name', local_var_params['model_name']))  # noqa: E501
        if 'cloud_id' in local_var_params and local_var_params['cloud_id'] is not None:  # noqa: E501
            query_params.append(('cloud_id', local_var_params['cloud_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/aica_endpoints/model_config', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AicaModelAcceleratorMap',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_model_schema_api_v2_aica_endpoints_model_schema_get(self, aviary_version, **kwargs):  # noqa: E501
        """Get Model Schema  # noqa: E501

        Get model schema  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_model_schema_api_v2_aica_endpoints_model_schema_get(aviary_version, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str aviary_version: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_model_schema_api_v2_aica_endpoints_model_schema_get_with_http_info(aviary_version, **kwargs)  # noqa: E501

    def get_model_schema_api_v2_aica_endpoints_model_schema_get_with_http_info(self, aviary_version, **kwargs):  # noqa: E501
        """Get Model Schema  # noqa: E501

        Get model schema  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_model_schema_api_v2_aica_endpoints_model_schema_get_with_http_info(aviary_version, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str aviary_version: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'aviary_version'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_model_schema_api_v2_aica_endpoints_model_schema_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'aviary_version' is set
        if self.api_client.client_side_validation and ('aviary_version' not in local_var_params or  # noqa: E501
                                                        local_var_params['aviary_version'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `aviary_version` when calling `get_model_schema_api_v2_aica_endpoints_model_schema_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'aviary_version' in local_var_params and local_var_params['aviary_version'] is not None:  # noqa: E501
            query_params.append(('aviary_version', local_var_params['aviary_version']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/aica_endpoints/model_schema', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_monitor_logs_api_v2_sessions_session_id_monitor_logs_get(self, session_id, start_line, end_line, **kwargs):  # noqa: E501
        """Get Monitor Logs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_monitor_logs_api_v2_sessions_session_id_monitor_logs_get(session_id, start_line, end_line, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param int start_line: (required)
        :param int end_line: (required)
        :param str extension:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: LogsoutputResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_monitor_logs_api_v2_sessions_session_id_monitor_logs_get_with_http_info(session_id, start_line, end_line, **kwargs)  # noqa: E501

    def get_monitor_logs_api_v2_sessions_session_id_monitor_logs_get_with_http_info(self, session_id, start_line, end_line, **kwargs):  # noqa: E501
        """Get Monitor Logs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_monitor_logs_api_v2_sessions_session_id_monitor_logs_get_with_http_info(session_id, start_line, end_line, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param int start_line: (required)
        :param int end_line: (required)
        :param str extension:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(LogsoutputResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'session_id',
            'start_line',
            'end_line',
            'extension'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_monitor_logs_api_v2_sessions_session_id_monitor_logs_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'session_id' is set
        if self.api_client.client_side_validation and ('session_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_id` when calling `get_monitor_logs_api_v2_sessions_session_id_monitor_logs_get`")  # noqa: E501
        # verify the required parameter 'start_line' is set
        if self.api_client.client_side_validation and ('start_line' not in local_var_params or  # noqa: E501
                                                        local_var_params['start_line'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `start_line` when calling `get_monitor_logs_api_v2_sessions_session_id_monitor_logs_get`")  # noqa: E501
        # verify the required parameter 'end_line' is set
        if self.api_client.client_side_validation and ('end_line' not in local_var_params or  # noqa: E501
                                                        local_var_params['end_line'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `end_line` when calling `get_monitor_logs_api_v2_sessions_session_id_monitor_logs_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'session_id' in local_var_params:
            path_params['session_id'] = local_var_params['session_id']  # noqa: E501

        query_params = []
        if 'start_line' in local_var_params and local_var_params['start_line'] is not None:  # noqa: E501
            query_params.append(('start_line', local_var_params['start_line']))  # noqa: E501
        if 'end_line' in local_var_params and local_var_params['end_line'] is not None:  # noqa: E501
            query_params.append(('end_line', local_var_params['end_line']))  # noqa: E501
        if 'extension' in local_var_params and local_var_params['extension'] is not None:  # noqa: E501
            query_params.append(('extension', local_var_params['extension']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/sessions/{session_id}/monitor_logs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogsoutputResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_monitor_logs_archived_api_v2_sessions_session_id_monitor_logs_archived_get(self, session_id, **kwargs):  # noqa: E501
        """Get Monitor Logs Archived  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_monitor_logs_archived_api_v2_sessions_session_id_monitor_logs_archived_get(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ArchivedlogsinfoResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_monitor_logs_archived_api_v2_sessions_session_id_monitor_logs_archived_get_with_http_info(session_id, **kwargs)  # noqa: E501

    def get_monitor_logs_archived_api_v2_sessions_session_id_monitor_logs_archived_get_with_http_info(self, session_id, **kwargs):  # noqa: E501
        """Get Monitor Logs Archived  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_monitor_logs_archived_api_v2_sessions_session_id_monitor_logs_archived_get_with_http_info(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ArchivedlogsinfoResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'session_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_monitor_logs_archived_api_v2_sessions_session_id_monitor_logs_archived_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'session_id' is set
        if self.api_client.client_side_validation and ('session_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_id` when calling `get_monitor_logs_archived_api_v2_sessions_session_id_monitor_logs_archived_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'session_id' in local_var_params:
            path_params['session_id'] = local_var_params['session_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/sessions/{session_id}/monitor_logs_archived', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ArchivedlogsinfoResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_monitor_logs_download_api_v2_logs_monitor_logs_download_session_id_get(self, session_id, **kwargs):  # noqa: E501
        """Get Monitor Logs Download  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_monitor_logs_download_api_v2_logs_monitor_logs_download_session_id_get(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param MonitorLogsExtension extension: Extension of monitor logs to return. Defaults to .log, which is for autoscaler status
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: LogdownloadresultResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_monitor_logs_download_api_v2_logs_monitor_logs_download_session_id_get_with_http_info(session_id, **kwargs)  # noqa: E501

    def get_monitor_logs_download_api_v2_logs_monitor_logs_download_session_id_get_with_http_info(self, session_id, **kwargs):  # noqa: E501
        """Get Monitor Logs Download  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_monitor_logs_download_api_v2_logs_monitor_logs_download_session_id_get_with_http_info(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param MonitorLogsExtension extension: Extension of monitor logs to return. Defaults to .log, which is for autoscaler status
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(LogdownloadresultResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'session_id',
            'extension'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_monitor_logs_download_api_v2_logs_monitor_logs_download_session_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'session_id' is set
        if self.api_client.client_side_validation and ('session_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_id` when calling `get_monitor_logs_download_api_v2_logs_monitor_logs_download_session_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'session_id' in local_var_params:
            path_params['session_id'] = local_var_params['session_id']  # noqa: E501

        query_params = []
        if 'extension' in local_var_params and local_var_params['extension'] is not None:  # noqa: E501
            query_params.append(('extension', local_var_params['extension']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/logs/monitor_logs_download/{session_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogdownloadresultResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_monitor_logs_stream_api_v2_logs_monitor_logs_stream_session_id_get(self, session_id, **kwargs):  # noqa: E501
        """Get Monitor Logs Stream  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_monitor_logs_stream_api_v2_logs_monitor_logs_stream_session_id_get(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param int lines: Number of lines to return. Defaults to 1000. Set to -1 to return all lines.
        :param MonitorLogsExtension extension: Extension of monitor logs to return. Defaults to .log, which is for autoscaler status
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: LogstreamResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_monitor_logs_stream_api_v2_logs_monitor_logs_stream_session_id_get_with_http_info(session_id, **kwargs)  # noqa: E501

    def get_monitor_logs_stream_api_v2_logs_monitor_logs_stream_session_id_get_with_http_info(self, session_id, **kwargs):  # noqa: E501
        """Get Monitor Logs Stream  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_monitor_logs_stream_api_v2_logs_monitor_logs_stream_session_id_get_with_http_info(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param int lines: Number of lines to return. Defaults to 1000. Set to -1 to return all lines.
        :param MonitorLogsExtension extension: Extension of monitor logs to return. Defaults to .log, which is for autoscaler status
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(LogstreamResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'session_id',
            'lines',
            'extension'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_monitor_logs_stream_api_v2_logs_monitor_logs_stream_session_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'session_id' is set
        if self.api_client.client_side_validation and ('session_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_id` when calling `get_monitor_logs_stream_api_v2_logs_monitor_logs_stream_session_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'session_id' in local_var_params:
            path_params['session_id'] = local_var_params['session_id']  # noqa: E501

        query_params = []
        if 'lines' in local_var_params and local_var_params['lines'] is not None:  # noqa: E501
            query_params.append(('lines', local_var_params['lines']))  # noqa: E501
        if 'extension' in local_var_params and local_var_params['extension'] is not None:  # noqa: E501
            query_params.append(('extension', local_var_params['extension']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/logs/monitor_logs_stream/{session_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogstreamResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_organization_metronome_usage_alerts_api_v2_organization_billing_alerts_get(self, **kwargs):  # noqa: E501
        """Get Organization Metronome Usage Alerts  # noqa: E501

        Return the current status of alerts regarding organization's usage  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_organization_metronome_usage_alerts_api_v2_organization_billing_alerts_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: OrganizationusagealertListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_organization_metronome_usage_alerts_api_v2_organization_billing_alerts_get_with_http_info(**kwargs)  # noqa: E501

    def get_organization_metronome_usage_alerts_api_v2_organization_billing_alerts_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get Organization Metronome Usage Alerts  # noqa: E501

        Return the current status of alerts regarding organization's usage  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_organization_metronome_usage_alerts_api_v2_organization_billing_alerts_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(OrganizationusagealertListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_organization_metronome_usage_alerts_api_v2_organization_billing_alerts_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organization_billing/alerts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OrganizationusagealertListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_ping_external_services_api_v2_sessions_session_id_ping_external_services_get(self, session_id, **kwargs):  # noqa: E501
        """Get Ping External Services  # noqa: E501

        Ping external session services to see if SSL negotiations have completed. SSL errors will throw URLErrors and will not have a status code. Using this endpoint is preferred over directly pinging these services on the web client because CORS is restricted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ping_external_services_api_v2_sessions_session_id_ping_external_services_get(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ExternalservicestatusresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_ping_external_services_api_v2_sessions_session_id_ping_external_services_get_with_http_info(session_id, **kwargs)  # noqa: E501

    def get_ping_external_services_api_v2_sessions_session_id_ping_external_services_get_with_http_info(self, session_id, **kwargs):  # noqa: E501
        """Get Ping External Services  # noqa: E501

        Ping external session services to see if SSL negotiations have completed. SSL errors will throw URLErrors and will not have a status code. Using this endpoint is preferred over directly pinging these services on the web client because CORS is restricted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ping_external_services_api_v2_sessions_session_id_ping_external_services_get_with_http_info(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ExternalservicestatusresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'session_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_ping_external_services_api_v2_sessions_session_id_ping_external_services_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'session_id' is set
        if self.api_client.client_side_validation and ('session_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_id` when calling `get_ping_external_services_api_v2_sessions_session_id_ping_external_services_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'session_id' in local_var_params:
            path_params['session_id'] = local_var_params['session_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/sessions/{session_id}/ping_external_services', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ExternalservicestatusresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_project_api_v2_projects_project_id_get(self, project_id, **kwargs):  # noqa: E501
        """Get Project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_project_api_v2_projects_project_id_get(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ProjectResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_project_api_v2_projects_project_id_get_with_http_info(project_id, **kwargs)  # noqa: E501

    def get_project_api_v2_projects_project_id_get_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """Get Project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_project_api_v2_projects_project_id_get_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ProjectResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_project_api_v2_projects_project_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `get_project_api_v2_projects_project_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in local_var_params:
            path_params['project_id'] = local_var_params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/projects/{project_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ProjectResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_project_default_session_name_api_v2_projects_project_id_default_session_name_get(self, project_id, **kwargs):  # noqa: E501
        """Get Project Default Session Name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_project_default_session_name_api_v2_projects_project_id_default_session_name_get(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ProjectdefaultsessionnameResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_project_default_session_name_api_v2_projects_project_id_default_session_name_get_with_http_info(project_id, **kwargs)  # noqa: E501

    def get_project_default_session_name_api_v2_projects_project_id_default_session_name_get_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """Get Project Default Session Name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_project_default_session_name_api_v2_projects_project_id_default_session_name_get_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ProjectdefaultsessionnameResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_project_default_session_name_api_v2_projects_project_id_default_session_name_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `get_project_default_session_name_api_v2_projects_project_id_default_session_name_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in local_var_params:
            path_params['project_id'] = local_var_params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/projects/{project_id}/default_session_name', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ProjectdefaultsessionnameResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_project_latest_cluster_config_api_v2_projects_project_id_latest_cluster_config_get(self, project_id, **kwargs):  # noqa: E501
        """Get Project Latest Cluster Config  # noqa: E501

        Returns the cluster_config saved at the project level.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_project_latest_cluster_config_api_v2_projects_project_id_latest_cluster_config_get(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ClusterconfigResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_project_latest_cluster_config_api_v2_projects_project_id_latest_cluster_config_get_with_http_info(project_id, **kwargs)  # noqa: E501

    def get_project_latest_cluster_config_api_v2_projects_project_id_latest_cluster_config_get_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """Get Project Latest Cluster Config  # noqa: E501

        Returns the cluster_config saved at the project level.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_project_latest_cluster_config_api_v2_projects_project_id_latest_cluster_config_get_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ClusterconfigResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_project_latest_cluster_config_api_v2_projects_project_id_latest_cluster_config_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `get_project_latest_cluster_config_api_v2_projects_project_id_latest_cluster_config_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in local_var_params:
            path_params['project_id'] = local_var_params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/projects/{project_id}/latest_cluster_config', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClusterconfigResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_provider_metadata_api_v2_clouds_provider_metadata_cloud_id_get(self, cloud_id, max_staleness, **kwargs):  # noqa: E501
        """Get Provider Metadata  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_provider_metadata_api_v2_clouds_provider_metadata_cloud_id_get(cloud_id, max_staleness, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param float max_staleness: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ProvidermetadataResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_provider_metadata_api_v2_clouds_provider_metadata_cloud_id_get_with_http_info(cloud_id, max_staleness, **kwargs)  # noqa: E501

    def get_provider_metadata_api_v2_clouds_provider_metadata_cloud_id_get_with_http_info(self, cloud_id, max_staleness, **kwargs):  # noqa: E501
        """Get Provider Metadata  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_provider_metadata_api_v2_clouds_provider_metadata_cloud_id_get_with_http_info(cloud_id, max_staleness, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param float max_staleness: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ProvidermetadataResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id',
            'max_staleness'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_provider_metadata_api_v2_clouds_provider_metadata_cloud_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `get_provider_metadata_api_v2_clouds_provider_metadata_cloud_id_get`")  # noqa: E501
        # verify the required parameter 'max_staleness' is set
        if self.api_client.client_side_validation and ('max_staleness' not in local_var_params or  # noqa: E501
                                                        local_var_params['max_staleness'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `max_staleness` when calling `get_provider_metadata_api_v2_clouds_provider_metadata_cloud_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501

        query_params = []
        if 'max_staleness' in local_var_params and local_var_params['max_staleness'] is not None:  # noqa: E501
            query_params.append(('max_staleness', local_var_params['max_staleness']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds/provider_metadata/{cloud_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ProvidermetadataResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_public_identifier_api_v2_organizations_public_identifier_get(self, organization_name, **kwargs):  # noqa: E501
        """Get Public Identifier  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_public_identifier_api_v2_organizations_public_identifier_get(organization_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str organization_name: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: OrganizationpublicidentifierResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_public_identifier_api_v2_organizations_public_identifier_get_with_http_info(organization_name, **kwargs)  # noqa: E501

    def get_public_identifier_api_v2_organizations_public_identifier_get_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """Get Public Identifier  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_public_identifier_api_v2_organizations_public_identifier_get_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str organization_name: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(OrganizationpublicidentifierResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'organization_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_public_identifier_api_v2_organizations_public_identifier_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and ('organization_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['organization_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `get_public_identifier_api_v2_organizations_public_identifier_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'organization_name' in local_var_params and local_var_params['organization_name'] is not None:  # noqa: E501
            query_params.append(('organization_name', local_var_params['organization_name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organizations/public_identifier', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OrganizationpublicidentifierResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_ray_result_files_api_v2_sessions_session_id_get_ray_result_files_get(self, session_id, **kwargs):  # noqa: E501
        """Get Ray Result Files  # noqa: E501

        API for downloading ray tune results of a session.  Parameters ---------- session_id: str     DB id of the session. This is a path parameter.     If session_id is 'latest', then atleast one of production_job_id or ray_job_submission_id must be provided in the query parameters.  job_id: Optional[str]     DB id of the production job. This is a query parameter.  job_run: Optional[str]     Ray job submission id of the job run, also known as job run name in the UI.     This is a query parameter.  base_sessions_service: BaseSessionsService     The session service, which provides the necessary orchestration for downloading logs.  premission_service: SessionPermissionsService     The permission sercice. This is used to do authorization checks.  auth_context: AuthContext     The auth context of the user.  db_connections: Any     Connection to the DB.  Returns ------- Response[LogDetails]     The ray tune results files, with their presigned URL.  Raises ------ HTTPException(401)     If the user does not have access to the session.  HTTPException(404)     If the session or cloud could not be found in the DB.  HTTPException(500)     If there are any other errors while downloading ray tune results.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ray_result_files_api_v2_sessions_session_id_get_ray_result_files_get(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: the session id or 'latest' (required)
        :param str job_id: job id to download ray results.
        :param str job_run: job run name to download ray results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: LogdetailsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_ray_result_files_api_v2_sessions_session_id_get_ray_result_files_get_with_http_info(session_id, **kwargs)  # noqa: E501

    def get_ray_result_files_api_v2_sessions_session_id_get_ray_result_files_get_with_http_info(self, session_id, **kwargs):  # noqa: E501
        """Get Ray Result Files  # noqa: E501

        API for downloading ray tune results of a session.  Parameters ---------- session_id: str     DB id of the session. This is a path parameter.     If session_id is 'latest', then atleast one of production_job_id or ray_job_submission_id must be provided in the query parameters.  job_id: Optional[str]     DB id of the production job. This is a query parameter.  job_run: Optional[str]     Ray job submission id of the job run, also known as job run name in the UI.     This is a query parameter.  base_sessions_service: BaseSessionsService     The session service, which provides the necessary orchestration for downloading logs.  premission_service: SessionPermissionsService     The permission sercice. This is used to do authorization checks.  auth_context: AuthContext     The auth context of the user.  db_connections: Any     Connection to the DB.  Returns ------- Response[LogDetails]     The ray tune results files, with their presigned URL.  Raises ------ HTTPException(401)     If the user does not have access to the session.  HTTPException(404)     If the session or cloud could not be found in the DB.  HTTPException(500)     If there are any other errors while downloading ray tune results.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ray_result_files_api_v2_sessions_session_id_get_ray_result_files_get_with_http_info(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: the session id or 'latest' (required)
        :param str job_id: job id to download ray results.
        :param str job_run: job run name to download ray results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(LogdetailsResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'session_id',
            'job_id',
            'job_run'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_ray_result_files_api_v2_sessions_session_id_get_ray_result_files_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'session_id' is set
        if self.api_client.client_side_validation and ('session_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_id` when calling `get_ray_result_files_api_v2_sessions_session_id_get_ray_result_files_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'session_id' in local_var_params:
            path_params['session_id'] = local_var_params['session_id']  # noqa: E501

        query_params = []
        if 'job_id' in local_var_params and local_var_params['job_id'] is not None:  # noqa: E501
            query_params.append(('job_id', local_var_params['job_id']))  # noqa: E501
        if 'job_run' in local_var_params and local_var_params['job_run'] is not None:  # noqa: E501
            query_params.append(('job_run', local_var_params['job_run']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/sessions/{session_id}/get_ray_result_files', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogdetailsResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_recent_cluster_compute_configs_api_v2_recent_activity_cluster_compute_configs_get(self, **kwargs):  # noqa: E501
        """Get Recent Cluster Compute Configs  # noqa: E501

        Retrieves recently used cluster compute configs for the current logged in user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_recent_cluster_compute_configs_api_v2_recent_activity_cluster_compute_configs_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int count: the number of recent activity elements to fetch
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: MinicomputetemplateListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_recent_cluster_compute_configs_api_v2_recent_activity_cluster_compute_configs_get_with_http_info(**kwargs)  # noqa: E501

    def get_recent_cluster_compute_configs_api_v2_recent_activity_cluster_compute_configs_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get Recent Cluster Compute Configs  # noqa: E501

        Retrieves recently used cluster compute configs for the current logged in user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_recent_cluster_compute_configs_api_v2_recent_activity_cluster_compute_configs_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int count: the number of recent activity elements to fetch
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(MinicomputetemplateListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_recent_cluster_compute_configs_api_v2_recent_activity_cluster_compute_configs_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/recent_activity/cluster_compute_configs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MinicomputetemplateListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_recent_cluster_environments_api_v2_recent_activity_cluster_environment_builds_get(self, **kwargs):  # noqa: E501
        """Get Recent Cluster Environments  # noqa: E501

        Retrieves recently used cluster environment for the current logged in user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_recent_cluster_environments_api_v2_recent_activity_cluster_environment_builds_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int count: the number of recent activity elements to fetch
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: MinibuildListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_recent_cluster_environments_api_v2_recent_activity_cluster_environment_builds_get_with_http_info(**kwargs)  # noqa: E501

    def get_recent_cluster_environments_api_v2_recent_activity_cluster_environment_builds_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get Recent Cluster Environments  # noqa: E501

        Retrieves recently used cluster environment for the current logged in user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_recent_cluster_environments_api_v2_recent_activity_cluster_environment_builds_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int count: the number of recent activity elements to fetch
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(MinibuildListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_recent_cluster_environments_api_v2_recent_activity_cluster_environment_builds_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/recent_activity/cluster_environment_builds', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MinibuildListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_recent_projects_api_v2_recent_activity_projects_get(self, **kwargs):  # noqa: E501
        """Get Recent Projects  # noqa: E501

        Retrieves recently used projects for the current logged in user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_recent_projects_api_v2_recent_activity_projects_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int count: the number of recent activity elements to fetch
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: MiniprojectListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_recent_projects_api_v2_recent_activity_projects_get_with_http_info(**kwargs)  # noqa: E501

    def get_recent_projects_api_v2_recent_activity_projects_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get Recent Projects  # noqa: E501

        Retrieves recently used projects for the current logged in user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_recent_projects_api_v2_recent_activity_projects_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int count: the number of recent activity elements to fetch
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(MiniprojectListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_recent_projects_api_v2_recent_activity_projects_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/recent_activity/projects', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MiniprojectListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_regions_and_zones_api_v2_aws_info_regions_and_zones_get(self, **kwargs):  # noqa: E501
        """Get Regions And Zones  # noqa: E501

        Retrieve the available regions and availability zones for AWS  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_regions_and_zones_api_v2_aws_info_regions_and_zones_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AwsregionandzonesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_regions_and_zones_api_v2_aws_info_regions_and_zones_get_with_http_info(**kwargs)  # noqa: E501

    def get_regions_and_zones_api_v2_aws_info_regions_and_zones_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get Regions And Zones  # noqa: E501

        Retrieve the available regions and availability zones for AWS  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_regions_and_zones_api_v2_aws_info_regions_and_zones_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AwsregionandzonesResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_regions_and_zones_api_v2_aws_info_regions_and_zones_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/aws_info/regions_and_zones', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AwsregionandzonesResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_regions_and_zones_api_v2_clouds_gcp_regions_and_zones_get(self, **kwargs):  # noqa: E501
        """Get Regions And Zones  # noqa: E501

        Retrieve the available regions and availability zones for GCP  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_regions_and_zones_api_v2_clouds_gcp_regions_and_zones_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CloudregionandzonesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_regions_and_zones_api_v2_clouds_gcp_regions_and_zones_get_with_http_info(**kwargs)  # noqa: E501

    def get_regions_and_zones_api_v2_clouds_gcp_regions_and_zones_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get Regions And Zones  # noqa: E501

        Retrieve the available regions and availability zones for GCP  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_regions_and_zones_api_v2_clouds_gcp_regions_and_zones_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CloudregionandzonesResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_regions_and_zones_api_v2_clouds_gcp_regions_and_zones_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds/gcp/regions_and_zones', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CloudregionandzonesResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_runtime_env_logs_api_v2_sessions_session_id_runtime_env_logs_get(self, session_id, **kwargs):  # noqa: E501
        """Get Runtime Env Logs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_runtime_env_logs_api_v2_sessions_session_id_runtime_env_logs_get(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param int start_timestamp_ns: The start timestamp in nanosecond for the log query search.
        :param int timeout_seconds: Timeout in seconds for the log query request.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: TimestampedlogsoutputResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_runtime_env_logs_api_v2_sessions_session_id_runtime_env_logs_get_with_http_info(session_id, **kwargs)  # noqa: E501

    def get_runtime_env_logs_api_v2_sessions_session_id_runtime_env_logs_get_with_http_info(self, session_id, **kwargs):  # noqa: E501
        """Get Runtime Env Logs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_runtime_env_logs_api_v2_sessions_session_id_runtime_env_logs_get_with_http_info(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param int start_timestamp_ns: The start timestamp in nanosecond for the log query search.
        :param int timeout_seconds: Timeout in seconds for the log query request.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(TimestampedlogsoutputResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'session_id',
            'start_timestamp_ns',
            'timeout_seconds'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_runtime_env_logs_api_v2_sessions_session_id_runtime_env_logs_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'session_id' is set
        if self.api_client.client_side_validation and ('session_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_id` when calling `get_runtime_env_logs_api_v2_sessions_session_id_runtime_env_logs_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'session_id' in local_var_params:
            path_params['session_id'] = local_var_params['session_id']  # noqa: E501

        query_params = []
        if 'start_timestamp_ns' in local_var_params and local_var_params['start_timestamp_ns'] is not None:  # noqa: E501
            query_params.append(('start_timestamp_ns', local_var_params['start_timestamp_ns']))  # noqa: E501
        if 'timeout_seconds' in local_var_params and local_var_params['timeout_seconds'] is not None:  # noqa: E501
            query_params.append(('timeout_seconds', local_var_params['timeout_seconds']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/sessions/{session_id}/runtime_env_logs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TimestampedlogsoutputResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_runtime_env_logs_download_api_v2_logs_runtime_env_logs_download_session_id_get(self, session_id, **kwargs):  # noqa: E501
        """Get Runtime Env Logs Download  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_runtime_env_logs_download_api_v2_logs_runtime_env_logs_download_session_id_get(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: LogdownloadresultResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_runtime_env_logs_download_api_v2_logs_runtime_env_logs_download_session_id_get_with_http_info(session_id, **kwargs)  # noqa: E501

    def get_runtime_env_logs_download_api_v2_logs_runtime_env_logs_download_session_id_get_with_http_info(self, session_id, **kwargs):  # noqa: E501
        """Get Runtime Env Logs Download  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_runtime_env_logs_download_api_v2_logs_runtime_env_logs_download_session_id_get_with_http_info(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(LogdownloadresultResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'session_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_runtime_env_logs_download_api_v2_logs_runtime_env_logs_download_session_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'session_id' is set
        if self.api_client.client_side_validation and ('session_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_id` when calling `get_runtime_env_logs_download_api_v2_logs_runtime_env_logs_download_session_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'session_id' in local_var_params:
            path_params['session_id'] = local_var_params['session_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/logs/runtime_env_logs_download/{session_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogdownloadresultResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_runtime_env_logs_stream_api_v2_logs_runtime_env_logs_stream_session_id_get(self, session_id, **kwargs):  # noqa: E501
        """Get Runtime Env Logs Stream  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_runtime_env_logs_stream_api_v2_logs_runtime_env_logs_stream_session_id_get(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param int lines: Number of lines to return. Defaults to 1000. Set to -1 to return all lines.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: LogstreamResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_runtime_env_logs_stream_api_v2_logs_runtime_env_logs_stream_session_id_get_with_http_info(session_id, **kwargs)  # noqa: E501

    def get_runtime_env_logs_stream_api_v2_logs_runtime_env_logs_stream_session_id_get_with_http_info(self, session_id, **kwargs):  # noqa: E501
        """Get Runtime Env Logs Stream  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_runtime_env_logs_stream_api_v2_logs_runtime_env_logs_stream_session_id_get_with_http_info(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param int lines: Number of lines to return. Defaults to 1000. Set to -1 to return all lines.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(LogstreamResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'session_id',
            'lines'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_runtime_env_logs_stream_api_v2_logs_runtime_env_logs_stream_session_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'session_id' is set
        if self.api_client.client_side_validation and ('session_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_id` when calling `get_runtime_env_logs_stream_api_v2_logs_runtime_env_logs_stream_session_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'session_id' in local_var_params:
            path_params['session_id'] = local_var_params['session_id']  # noqa: E501

        query_params = []
        if 'lines' in local_var_params and local_var_params['lines'] is not None:  # noqa: E501
            query_params.append(('lines', local_var_params['lines']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/logs/runtime_env_logs_stream/{session_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogstreamResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_serve_logs_download_api_v2_logs_serve_logs_download_cluster_id_get(self, cluster_id, **kwargs):  # noqa: E501
        """Get Serve Logs Download  # noqa: E501

        Fetches the serve controller logs of the cluster. The logs will be fetched from the streaming logs s3 bucket.  If a pagination token is provided, we use the streaming logs or downloaded logs bucket depending on the format of the pagination token.  TODO(aguo): Implement job alive or dead detection  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_serve_logs_download_api_v2_logs_serve_logs_download_cluster_id_get(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param int page_size: Number of chunks to fetch. Defaults to 400. Max of 1000.
        :param str next_page_token: Pagination token for getting newer logs.
        :param str previous_page_token: Pagination token for getting older logs.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: LogdownloadresultResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_serve_logs_download_api_v2_logs_serve_logs_download_cluster_id_get_with_http_info(cluster_id, **kwargs)  # noqa: E501

    def get_serve_logs_download_api_v2_logs_serve_logs_download_cluster_id_get_with_http_info(self, cluster_id, **kwargs):  # noqa: E501
        """Get Serve Logs Download  # noqa: E501

        Fetches the serve controller logs of the cluster. The logs will be fetched from the streaming logs s3 bucket.  If a pagination token is provided, we use the streaming logs or downloaded logs bucket depending on the format of the pagination token.  TODO(aguo): Implement job alive or dead detection  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_serve_logs_download_api_v2_logs_serve_logs_download_cluster_id_get_with_http_info(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param int page_size: Number of chunks to fetch. Defaults to 400. Max of 1000.
        :param str next_page_token: Pagination token for getting newer logs.
        :param str previous_page_token: Pagination token for getting older logs.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(LogdownloadresultResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cluster_id',
            'page_size',
            'next_page_token',
            'previous_page_token'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_serve_logs_download_api_v2_logs_serve_logs_download_cluster_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and ('cluster_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cluster_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `get_serve_logs_download_api_v2_logs_serve_logs_download_cluster_id_get`")  # noqa: E501

        if self.api_client.client_side_validation and 'page_size' in local_var_params and local_var_params['page_size'] > 1000:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `page_size` when calling `get_serve_logs_download_api_v2_logs_serve_logs_download_cluster_id_get`, must be a value less than or equal to `1000`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'cluster_id' in local_var_params:
            path_params['cluster_id'] = local_var_params['cluster_id']  # noqa: E501

        query_params = []
        if 'page_size' in local_var_params and local_var_params['page_size'] is not None:  # noqa: E501
            query_params.append(('page_size', local_var_params['page_size']))  # noqa: E501
        if 'next_page_token' in local_var_params and local_var_params['next_page_token'] is not None:  # noqa: E501
            query_params.append(('next_page_token', local_var_params['next_page_token']))  # noqa: E501
        if 'previous_page_token' in local_var_params and local_var_params['previous_page_token'] is not None:  # noqa: E501
            query_params.append(('previous_page_token', local_var_params['previous_page_token']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/logs/serve_logs_download/{cluster_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogdownloadresultResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_service_api_v2_services_v2_service_id_get(self, service_id, **kwargs):  # noqa: E501
        """Get Service  # noqa: E501

        Get a Service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_service_api_v2_services_v2_service_id_get(service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str service_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Decoratedproductionservicev2ApimodelResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_service_api_v2_services_v2_service_id_get_with_http_info(service_id, **kwargs)  # noqa: E501

    def get_service_api_v2_services_v2_service_id_get_with_http_info(self, service_id, **kwargs):  # noqa: E501
        """Get Service  # noqa: E501

        Get a Service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_service_api_v2_services_v2_service_id_get_with_http_info(service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str service_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Decoratedproductionservicev2ApimodelResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'service_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_service_api_v2_services_v2_service_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'service_id' is set
        if self.api_client.client_side_validation and ('service_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['service_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `service_id` when calling `get_service_api_v2_services_v2_service_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in local_var_params:
            path_params['service_id'] = local_var_params['service_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/services-v2/{service_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Decoratedproductionservicev2ApimodelResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_service_event_verbose_message_api_v2_services_v2_events_event_id_verbose_message_get(self, event_id, origin, **kwargs):  # noqa: E501
        """Get Service Event Verbose Message  # noqa: E501

        Get verbose message details of a service event.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_service_event_verbose_message_api_v2_services_v2_events_event_id_verbose_message_get(event_id, origin, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str event_id: (required)
        :param ServiceEventScope origin: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ServiceeventverbosemessagemodelListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_service_event_verbose_message_api_v2_services_v2_events_event_id_verbose_message_get_with_http_info(event_id, origin, **kwargs)  # noqa: E501

    def get_service_event_verbose_message_api_v2_services_v2_events_event_id_verbose_message_get_with_http_info(self, event_id, origin, **kwargs):  # noqa: E501
        """Get Service Event Verbose Message  # noqa: E501

        Get verbose message details of a service event.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_service_event_verbose_message_api_v2_services_v2_events_event_id_verbose_message_get_with_http_info(event_id, origin, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str event_id: (required)
        :param ServiceEventScope origin: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ServiceeventverbosemessagemodelListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'event_id',
            'origin'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_service_event_verbose_message_api_v2_services_v2_events_event_id_verbose_message_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'event_id' is set
        if self.api_client.client_side_validation and ('event_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['event_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `event_id` when calling `get_service_event_verbose_message_api_v2_services_v2_events_event_id_verbose_message_get`")  # noqa: E501
        # verify the required parameter 'origin' is set
        if self.api_client.client_side_validation and ('origin' not in local_var_params or  # noqa: E501
                                                        local_var_params['origin'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `origin` when calling `get_service_event_verbose_message_api_v2_services_v2_events_event_id_verbose_message_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'event_id' in local_var_params:
            path_params['event_id'] = local_var_params['event_id']  # noqa: E501

        query_params = []
        if 'origin' in local_var_params and local_var_params['origin'] is not None:  # noqa: E501
            query_params.append(('origin', local_var_params['origin']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/services-v2/events/{event_id}/verbose_message', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ServiceeventverbosemessagemodelListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_service_events_api_v2_services_v2_service_id_events_get(self, service_id, **kwargs):  # noqa: E501
        """Get Service Events  # noqa: E501

        Get Service events  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_service_events_api_v2_services_v2_service_id_events_get(service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str service_id: (required)
        :param list[ServiceEventScopeFilter] origin: Filter if origin of event is included in this list. If \"\" in this list, no origin will be included in filter, so no results will be returned. Default behavior is to include all origin values in filter.
        :param ServiceEventLevel level: Filter by level of event
        :param str message: Filter by message of event
        :param datetime start_time: The start time for the query. If  start_time is not set, the query will use beginning of time.
        :param datetime end_time: The end time for the query. If end_time is not set, the query will use the time now.
        :param bool include_verbose_events: Show all verbose service events without truncation if set to True.
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedserviceeventapimodelListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_service_events_api_v2_services_v2_service_id_events_get_with_http_info(service_id, **kwargs)  # noqa: E501

    def get_service_events_api_v2_services_v2_service_id_events_get_with_http_info(self, service_id, **kwargs):  # noqa: E501
        """Get Service Events  # noqa: E501

        Get Service events  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_service_events_api_v2_services_v2_service_id_events_get_with_http_info(service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str service_id: (required)
        :param list[ServiceEventScopeFilter] origin: Filter if origin of event is included in this list. If \"\" in this list, no origin will be included in filter, so no results will be returned. Default behavior is to include all origin values in filter.
        :param ServiceEventLevel level: Filter by level of event
        :param str message: Filter by message of event
        :param datetime start_time: The start time for the query. If  start_time is not set, the query will use beginning of time.
        :param datetime end_time: The end time for the query. If end_time is not set, the query will use the time now.
        :param bool include_verbose_events: Show all verbose service events without truncation if set to True.
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedserviceeventapimodelListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'service_id',
            'origin',
            'level',
            'message',
            'start_time',
            'end_time',
            'include_verbose_events',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_service_events_api_v2_services_v2_service_id_events_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'service_id' is set
        if self.api_client.client_side_validation and ('service_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['service_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `service_id` when calling `get_service_events_api_v2_services_v2_service_id_events_get`")  # noqa: E501

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 1000:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `get_service_events_api_v2_services_v2_service_id_events_get`, must be a value less than or equal to `1000`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `get_service_events_api_v2_services_v2_service_id_events_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'service_id' in local_var_params:
            path_params['service_id'] = local_var_params['service_id']  # noqa: E501

        query_params = []
        if 'origin' in local_var_params and local_var_params['origin'] is not None:  # noqa: E501
            query_params.append(('origin', local_var_params['origin']))  # noqa: E501
            collection_formats['origin'] = 'multi'  # noqa: E501
        if 'level' in local_var_params and local_var_params['level'] is not None:  # noqa: E501
            query_params.append(('level', local_var_params['level']))  # noqa: E501
        if 'message' in local_var_params and local_var_params['message'] is not None:  # noqa: E501
            query_params.append(('message', local_var_params['message']))  # noqa: E501
        if 'start_time' in local_var_params and local_var_params['start_time'] is not None:  # noqa: E501
            query_params.append(('start_time', local_var_params['start_time']))  # noqa: E501
        if 'end_time' in local_var_params and local_var_params['end_time'] is not None:  # noqa: E501
            query_params.append(('end_time', local_var_params['end_time']))  # noqa: E501
        if 'include_verbose_events' in local_var_params and local_var_params['include_verbose_events'] is not None:  # noqa: E501
            query_params.append(('include_verbose_events', local_var_params['include_verbose_events']))  # noqa: E501
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/services-v2/{service_id}/events', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedserviceeventapimodelListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_service_versions_api_v2_services_v2_service_id_versions_get(self, service_id, **kwargs):  # noqa: E501
        """Get Service Versions  # noqa: E501

        Returns up to 10 (most recent) versions for the given Service (ordered by most to least recent).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_service_versions_api_v2_services_v2_service_id_versions_get(service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str service_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Decoratedproductionservicev2VersionapimodelListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_service_versions_api_v2_services_v2_service_id_versions_get_with_http_info(service_id, **kwargs)  # noqa: E501

    def get_service_versions_api_v2_services_v2_service_id_versions_get_with_http_info(self, service_id, **kwargs):  # noqa: E501
        """Get Service Versions  # noqa: E501

        Returns up to 10 (most recent) versions for the given Service (ordered by most to least recent).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_service_versions_api_v2_services_v2_service_id_versions_get_with_http_info(service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str service_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Decoratedproductionservicev2VersionapimodelListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'service_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_service_versions_api_v2_services_v2_service_id_versions_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'service_id' is set
        if self.api_client.client_side_validation and ('service_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['service_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `service_id` when calling `get_service_versions_api_v2_services_v2_service_id_versions_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in local_var_params:
            path_params['service_id'] = local_var_params['service_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/services-v2/{service_id}/versions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Decoratedproductionservicev2VersionapimodelListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_session_api_v2_sessions_session_id_get(self, session_id, **kwargs):  # noqa: E501
        """Get Session  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_session_api_v2_sessions_session_id_get(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: SessionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_session_api_v2_sessions_session_id_get_with_http_info(session_id, **kwargs)  # noqa: E501

    def get_session_api_v2_sessions_session_id_get_with_http_info(self, session_id, **kwargs):  # noqa: E501
        """Get Session  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_session_api_v2_sessions_session_id_get_with_http_info(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(SessionResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'session_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_session_api_v2_sessions_session_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'session_id' is set
        if self.api_client.client_side_validation and ('session_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_id` when calling `get_session_api_v2_sessions_session_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'session_id' in local_var_params:
            path_params['session_id'] = local_var_params['session_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/sessions/{session_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SessionResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_session_autoscaler_credentials_api_v2_sessions_session_id_autoscaler_credentials_get(self, session_id, **kwargs):  # noqa: E501
        """Get Session Autoscaler Credentials  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_session_autoscaler_credentials_api_v2_sessions_session_id_autoscaler_credentials_get(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AutoscalercredentialsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_session_autoscaler_credentials_api_v2_sessions_session_id_autoscaler_credentials_get_with_http_info(session_id, **kwargs)  # noqa: E501

    def get_session_autoscaler_credentials_api_v2_sessions_session_id_autoscaler_credentials_get_with_http_info(self, session_id, **kwargs):  # noqa: E501
        """Get Session Autoscaler Credentials  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_session_autoscaler_credentials_api_v2_sessions_session_id_autoscaler_credentials_get_with_http_info(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AutoscalercredentialsResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'session_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_session_autoscaler_credentials_api_v2_sessions_session_id_autoscaler_credentials_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'session_id' is set
        if self.api_client.client_side_validation and ('session_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_id` when calling `get_session_autoscaler_credentials_api_v2_sessions_session_id_autoscaler_credentials_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'session_id' in local_var_params:
            path_params['session_id'] = local_var_params['session_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/sessions/{session_id}/autoscaler_credentials', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AutoscalercredentialsResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_session_cluster_config_api_v2_sessions_session_id_cluster_config_get(self, session_id, **kwargs):  # noqa: E501
        """Get Session Cluster Config  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_session_cluster_config_api_v2_sessions_session_id_cluster_config_get(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ClusterconfigResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_session_cluster_config_api_v2_sessions_session_id_cluster_config_get_with_http_info(session_id, **kwargs)  # noqa: E501

    def get_session_cluster_config_api_v2_sessions_session_id_cluster_config_get_with_http_info(self, session_id, **kwargs):  # noqa: E501
        """Get Session Cluster Config  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_session_cluster_config_api_v2_sessions_session_id_cluster_config_get_with_http_info(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ClusterconfigResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'session_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_session_cluster_config_api_v2_sessions_session_id_cluster_config_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'session_id' is set
        if self.api_client.client_side_validation and ('session_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_id` when calling `get_session_cluster_config_api_v2_sessions_session_id_cluster_config_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'session_id' in local_var_params:
            path_params['session_id'] = local_var_params['session_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/sessions/{session_id}/cluster_config', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClusterconfigResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_session_cluster_config_with_session_idle_timeout_api_v2_sessions_session_id_cluster_config_with_session_idle_timeout_get(self, session_id, **kwargs):  # noqa: E501
        """Get Session Cluster Config With Session Idle Timeout  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_session_cluster_config_with_session_idle_timeout_api_v2_sessions_session_id_cluster_config_with_session_idle_timeout_get(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ClusterconfigwithsessionidletimeoutResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_session_cluster_config_with_session_idle_timeout_api_v2_sessions_session_id_cluster_config_with_session_idle_timeout_get_with_http_info(session_id, **kwargs)  # noqa: E501

    def get_session_cluster_config_with_session_idle_timeout_api_v2_sessions_session_id_cluster_config_with_session_idle_timeout_get_with_http_info(self, session_id, **kwargs):  # noqa: E501
        """Get Session Cluster Config With Session Idle Timeout  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_session_cluster_config_with_session_idle_timeout_api_v2_sessions_session_id_cluster_config_with_session_idle_timeout_get_with_http_info(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ClusterconfigwithsessionidletimeoutResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'session_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_session_cluster_config_with_session_idle_timeout_api_v2_sessions_session_id_cluster_config_with_session_idle_timeout_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'session_id' is set
        if self.api_client.client_side_validation and ('session_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_id` when calling `get_session_cluster_config_with_session_idle_timeout_api_v2_sessions_session_id_cluster_config_with_session_idle_timeout_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'session_id' in local_var_params:
            path_params['session_id'] = local_var_params['session_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/sessions/{session_id}/cluster_config_with_session_idle_timeout', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClusterconfigwithsessionidletimeoutResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_session_command_logs_download_api_v2_logs_session_command_logs_session_id_session_command_id_get(self, session_id, session_command_id, **kwargs):  # noqa: E501
        """Get Session Command Logs Download  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_session_command_logs_download_api_v2_logs_session_command_logs_session_id_session_command_id_get(session_id, session_command_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param str session_command_id: (required)
        :param bool use_bearer_token: Whether to use the more performant bearer-token based log downloading for GCP. Defaults to false for backwards compatibility.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: LogdownloadresultResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_session_command_logs_download_api_v2_logs_session_command_logs_session_id_session_command_id_get_with_http_info(session_id, session_command_id, **kwargs)  # noqa: E501

    def get_session_command_logs_download_api_v2_logs_session_command_logs_session_id_session_command_id_get_with_http_info(self, session_id, session_command_id, **kwargs):  # noqa: E501
        """Get Session Command Logs Download  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_session_command_logs_download_api_v2_logs_session_command_logs_session_id_session_command_id_get_with_http_info(session_id, session_command_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param str session_command_id: (required)
        :param bool use_bearer_token: Whether to use the more performant bearer-token based log downloading for GCP. Defaults to false for backwards compatibility.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(LogdownloadresultResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'session_id',
            'session_command_id',
            'use_bearer_token'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_session_command_logs_download_api_v2_logs_session_command_logs_session_id_session_command_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'session_id' is set
        if self.api_client.client_side_validation and ('session_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_id` when calling `get_session_command_logs_download_api_v2_logs_session_command_logs_session_id_session_command_id_get`")  # noqa: E501
        # verify the required parameter 'session_command_id' is set
        if self.api_client.client_side_validation and ('session_command_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_command_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_command_id` when calling `get_session_command_logs_download_api_v2_logs_session_command_logs_session_id_session_command_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'session_id' in local_var_params:
            path_params['session_id'] = local_var_params['session_id']  # noqa: E501
        if 'session_command_id' in local_var_params:
            path_params['session_command_id'] = local_var_params['session_command_id']  # noqa: E501

        query_params = []
        if 'use_bearer_token' in local_var_params and local_var_params['use_bearer_token'] is not None:  # noqa: E501
            query_params.append(('use_bearer_token', local_var_params['use_bearer_token']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/logs/session_command_logs/{session_id}/{session_command_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogdownloadresultResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_session_commands_history_api_v2_session_commands_get(self, session_id, **kwargs):  # noqa: E501
        """Get Session Commands History  # noqa: E501

        List all commands that have been run on a session.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_session_commands_history_api_v2_session_commands_get(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param str shell_command: shell command to filter by
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: SessioncommandListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_session_commands_history_api_v2_session_commands_get_with_http_info(session_id, **kwargs)  # noqa: E501

    def get_session_commands_history_api_v2_session_commands_get_with_http_info(self, session_id, **kwargs):  # noqa: E501
        """Get Session Commands History  # noqa: E501

        List all commands that have been run on a session.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_session_commands_history_api_v2_session_commands_get_with_http_info(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param str shell_command: shell command to filter by
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(SessioncommandListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'session_id',
            'shell_command',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_session_commands_history_api_v2_session_commands_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'session_id' is set
        if self.api_client.client_side_validation and ('session_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_id` when calling `get_session_commands_history_api_v2_session_commands_get`")  # noqa: E501

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 50:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `get_session_commands_history_api_v2_session_commands_get`, must be a value less than or equal to `50`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `get_session_commands_history_api_v2_session_commands_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'session_id' in local_var_params and local_var_params['session_id'] is not None:  # noqa: E501
            query_params.append(('session_id', local_var_params['session_id']))  # noqa: E501
        if 'shell_command' in local_var_params and local_var_params['shell_command'] is not None:  # noqa: E501
            query_params.append(('shell_command', local_var_params['shell_command']))  # noqa: E501
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/session_commands/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SessioncommandListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_session_details_api_v2_sessions_session_id_details_get(self, session_id, **kwargs):  # noqa: E501
        """Get Session Details  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_session_details_api_v2_sessions_session_id_details_get(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: SessiondetailsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_session_details_api_v2_sessions_session_id_details_get_with_http_info(session_id, **kwargs)  # noqa: E501

    def get_session_details_api_v2_sessions_session_id_details_get_with_http_info(self, session_id, **kwargs):  # noqa: E501
        """Get Session Details  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_session_details_api_v2_sessions_session_id_details_get_with_http_info(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(SessiondetailsResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'session_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_session_details_api_v2_sessions_session_id_details_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'session_id' is set
        if self.api_client.client_side_validation and ('session_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_id` when calling `get_session_details_api_v2_sessions_session_id_details_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'session_id' in local_var_params:
            path_params['session_id'] = local_var_params['session_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/sessions/{session_id}/details', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SessiondetailsResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_session_event_log_api_v2_session_events_get(self, session_id, **kwargs):  # noqa: E501
        """Get Session Event Log  # noqa: E501

        Retrieves a session's event log.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_session_event_log_api_v2_session_events_get(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param datetime before:
        :param datetime after:
        :param list[SessionEventTypes] event_types:
        :param list[LogLevelTypes] log_level_types:
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: SessioneventListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_session_event_log_api_v2_session_events_get_with_http_info(session_id, **kwargs)  # noqa: E501

    def get_session_event_log_api_v2_session_events_get_with_http_info(self, session_id, **kwargs):  # noqa: E501
        """Get Session Event Log  # noqa: E501

        Retrieves a session's event log.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_session_event_log_api_v2_session_events_get_with_http_info(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param datetime before:
        :param datetime after:
        :param list[SessionEventTypes] event_types:
        :param list[LogLevelTypes] log_level_types:
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(SessioneventListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'session_id',
            'before',
            'after',
            'event_types',
            'log_level_types',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_session_event_log_api_v2_session_events_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'session_id' is set
        if self.api_client.client_side_validation and ('session_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_id` when calling `get_session_event_log_api_v2_session_events_get`")  # noqa: E501

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 1000:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `get_session_event_log_api_v2_session_events_get`, must be a value less than or equal to `1000`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `get_session_event_log_api_v2_session_events_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'session_id' in local_var_params and local_var_params['session_id'] is not None:  # noqa: E501
            query_params.append(('session_id', local_var_params['session_id']))  # noqa: E501
        if 'before' in local_var_params and local_var_params['before'] is not None:  # noqa: E501
            query_params.append(('before', local_var_params['before']))  # noqa: E501
        if 'after' in local_var_params and local_var_params['after'] is not None:  # noqa: E501
            query_params.append(('after', local_var_params['after']))  # noqa: E501
        if 'event_types' in local_var_params and local_var_params['event_types'] is not None:  # noqa: E501
            query_params.append(('event_types', local_var_params['event_types']))  # noqa: E501
            collection_formats['event_types'] = 'multi'  # noqa: E501
        if 'log_level_types' in local_var_params and local_var_params['log_level_types'] is not None:  # noqa: E501
            query_params.append(('log_level_types', local_var_params['log_level_types']))  # noqa: E501
            collection_formats['log_level_types'] = 'multi'  # noqa: E501
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/session_events/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SessioneventListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_session_head_ip_api_v2_sessions_session_id_head_ip_get(self, session_id, **kwargs):  # noqa: E501
        """Get Session Head Ip  # noqa: E501

        Fetches the ip of the head node of the session.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_session_head_ip_api_v2_sessions_session_id_head_ip_get(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: HeadipResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_session_head_ip_api_v2_sessions_session_id_head_ip_get_with_http_info(session_id, **kwargs)  # noqa: E501

    def get_session_head_ip_api_v2_sessions_session_id_head_ip_get_with_http_info(self, session_id, **kwargs):  # noqa: E501
        """Get Session Head Ip  # noqa: E501

        Fetches the ip of the head node of the session.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_session_head_ip_api_v2_sessions_session_id_head_ip_get_with_http_info(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(HeadipResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'session_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_session_head_ip_api_v2_sessions_session_id_head_ip_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'session_id' is set
        if self.api_client.client_side_validation and ('session_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_id` when calling `get_session_head_ip_api_v2_sessions_session_id_head_ip_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'session_id' in local_var_params:
            path_params['session_id'] = local_var_params['session_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/sessions/{session_id}/head_ip', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='HeadipResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_session_history_api_v2_sessions_session_id_history_get(self, session_id, **kwargs):  # noqa: E501
        """Get Session History  # noqa: E501

        Describe all actions applied to a particular session.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_session_history_api_v2_sessions_session_id_history_get(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: SessionhistoryitemListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_session_history_api_v2_sessions_session_id_history_get_with_http_info(session_id, **kwargs)  # noqa: E501

    def get_session_history_api_v2_sessions_session_id_history_get_with_http_info(self, session_id, **kwargs):  # noqa: E501
        """Get Session History  # noqa: E501

        Describe all actions applied to a particular session.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_session_history_api_v2_sessions_session_id_history_get_with_http_info(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(SessionhistoryitemListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'session_id',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_session_history_api_v2_sessions_session_id_history_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'session_id' is set
        if self.api_client.client_side_validation and ('session_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_id` when calling `get_session_history_api_v2_sessions_session_id_history_get`")  # noqa: E501

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 50:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `get_session_history_api_v2_sessions_session_id_history_get`, must be a value less than or equal to `50`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `get_session_history_api_v2_sessions_session_id_history_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'session_id' in local_var_params:
            path_params['session_id'] = local_var_params['session_id']  # noqa: E501

        query_params = []
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/sessions/{session_id}/history', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SessionhistoryitemListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_session_ssh_key_api_v2_sessions_session_id_ssh_key_get(self, session_id, **kwargs):  # noqa: E501
        """Get Session Ssh Key  # noqa: E501

        Download SSH needed to log into a given session.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_session_ssh_key_api_v2_sessions_session_id_ssh_key_get(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: SessionsshkeyResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_session_ssh_key_api_v2_sessions_session_id_ssh_key_get_with_http_info(session_id, **kwargs)  # noqa: E501

    def get_session_ssh_key_api_v2_sessions_session_id_ssh_key_get_with_http_info(self, session_id, **kwargs):  # noqa: E501
        """Get Session Ssh Key  # noqa: E501

        Download SSH needed to log into a given session.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_session_ssh_key_api_v2_sessions_session_id_ssh_key_get_with_http_info(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(SessionsshkeyResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'session_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_session_ssh_key_api_v2_sessions_session_id_ssh_key_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'session_id' is set
        if self.api_client.client_side_validation and ('session_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_id` when calling `get_session_ssh_key_api_v2_sessions_session_id_ssh_key_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'session_id' in local_var_params:
            path_params['session_id'] = local_var_params['session_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/sessions/{session_id}/ssh_key', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SessionsshkeyResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_socket_message_types_api_v2_userinfo_socket_messages_type_get(self, **kwargs):  # noqa: E501
        """Get Socket Message Types  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_socket_message_types_api_v2_userinfo_socket_messages_type_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: SocketmessageschemasResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_socket_message_types_api_v2_userinfo_socket_messages_type_get_with_http_info(**kwargs)  # noqa: E501

    def get_socket_message_types_api_v2_userinfo_socket_messages_type_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get Socket Message Types  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_socket_message_types_api_v2_userinfo_socket_messages_type_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(SocketmessageschemasResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_socket_message_types_api_v2_userinfo_socket_messages_type_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/userinfo/socket_messages_type', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SocketmessageschemasResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_socket_types_type_api_v2_userinfo_socket_types_type_get(self, **kwargs):  # noqa: E501
        """Get Socket Types Type  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_socket_types_type_api_v2_userinfo_socket_types_type_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: SocketmessagetypesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_socket_types_type_api_v2_userinfo_socket_types_type_get_with_http_info(**kwargs)  # noqa: E501

    def get_socket_types_type_api_v2_userinfo_socket_types_type_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get Socket Types Type  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_socket_types_type_api_v2_userinfo_socket_types_type_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(SocketmessagetypesResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_socket_types_type_api_v2_userinfo_socket_types_type_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/userinfo/socket_types_type', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SocketmessagetypesResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_startup_logs_api_v2_sessions_session_id_startup_logs_get(self, session_id, start_line, end_line, **kwargs):  # noqa: E501
        """Get Startup Logs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_startup_logs_api_v2_sessions_session_id_startup_logs_get(session_id, start_line, end_line, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param int start_line: (required)
        :param int end_line: (required)
        :param str extension:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: LogsoutputResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_startup_logs_api_v2_sessions_session_id_startup_logs_get_with_http_info(session_id, start_line, end_line, **kwargs)  # noqa: E501

    def get_startup_logs_api_v2_sessions_session_id_startup_logs_get_with_http_info(self, session_id, start_line, end_line, **kwargs):  # noqa: E501
        """Get Startup Logs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_startup_logs_api_v2_sessions_session_id_startup_logs_get_with_http_info(session_id, start_line, end_line, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param int start_line: (required)
        :param int end_line: (required)
        :param str extension:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(LogsoutputResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'session_id',
            'start_line',
            'end_line',
            'extension'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_startup_logs_api_v2_sessions_session_id_startup_logs_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'session_id' is set
        if self.api_client.client_side_validation and ('session_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_id` when calling `get_startup_logs_api_v2_sessions_session_id_startup_logs_get`")  # noqa: E501
        # verify the required parameter 'start_line' is set
        if self.api_client.client_side_validation and ('start_line' not in local_var_params or  # noqa: E501
                                                        local_var_params['start_line'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `start_line` when calling `get_startup_logs_api_v2_sessions_session_id_startup_logs_get`")  # noqa: E501
        # verify the required parameter 'end_line' is set
        if self.api_client.client_side_validation and ('end_line' not in local_var_params or  # noqa: E501
                                                        local_var_params['end_line'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `end_line` when calling `get_startup_logs_api_v2_sessions_session_id_startup_logs_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'session_id' in local_var_params:
            path_params['session_id'] = local_var_params['session_id']  # noqa: E501

        query_params = []
        if 'start_line' in local_var_params and local_var_params['start_line'] is not None:  # noqa: E501
            query_params.append(('start_line', local_var_params['start_line']))  # noqa: E501
        if 'end_line' in local_var_params and local_var_params['end_line'] is not None:  # noqa: E501
            query_params.append(('end_line', local_var_params['end_line']))  # noqa: E501
        if 'extension' in local_var_params and local_var_params['extension'] is not None:  # noqa: E501
            query_params.append(('extension', local_var_params['extension']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/sessions/{session_id}/startup_logs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogsoutputResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_startup_logs_archived_api_v2_sessions_session_id_startup_logs_archived_get(self, session_id, **kwargs):  # noqa: E501
        """Get Startup Logs Archived  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_startup_logs_archived_api_v2_sessions_session_id_startup_logs_archived_get(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ArchivedlogsinfoResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_startup_logs_archived_api_v2_sessions_session_id_startup_logs_archived_get_with_http_info(session_id, **kwargs)  # noqa: E501

    def get_startup_logs_archived_api_v2_sessions_session_id_startup_logs_archived_get_with_http_info(self, session_id, **kwargs):  # noqa: E501
        """Get Startup Logs Archived  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_startup_logs_archived_api_v2_sessions_session_id_startup_logs_archived_get_with_http_info(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ArchivedlogsinfoResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'session_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_startup_logs_archived_api_v2_sessions_session_id_startup_logs_archived_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'session_id' is set
        if self.api_client.client_side_validation and ('session_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_id` when calling `get_startup_logs_archived_api_v2_sessions_session_id_startup_logs_archived_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'session_id' in local_var_params:
            path_params['session_id'] = local_var_params['session_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/sessions/{session_id}/startup_logs_archived', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ArchivedlogsinfoResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_template_readme_api_v2_experimental_workspaces_template_readme_template_id_get(self, template_id, **kwargs):  # noqa: E501
        """Get Template Readme  # noqa: E501

        Retrieves a template's README.md file.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_template_readme_api_v2_experimental_workspaces_template_readme_template_id_get(template_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str template_id: ID of the template. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: WorkspacereadmeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_template_readme_api_v2_experimental_workspaces_template_readme_template_id_get_with_http_info(template_id, **kwargs)  # noqa: E501

    def get_template_readme_api_v2_experimental_workspaces_template_readme_template_id_get_with_http_info(self, template_id, **kwargs):  # noqa: E501
        """Get Template Readme  # noqa: E501

        Retrieves a template's README.md file.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_template_readme_api_v2_experimental_workspaces_template_readme_template_id_get_with_http_info(template_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str template_id: ID of the template. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(WorkspacereadmeResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'template_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_template_readme_api_v2_experimental_workspaces_template_readme_template_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'template_id' is set
        if self.api_client.client_side_validation and ('template_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['template_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `template_id` when calling `get_template_readme_api_v2_experimental_workspaces_template_readme_template_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'template_id' in local_var_params:
            path_params['template_id'] = local_var_params['template_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/experimental_workspaces/template/readme/{template_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='WorkspacereadmeResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_templatized_cluster_environments_api_v2_application_templates_templatized_get(self, **kwargs):  # noqa: E501
        """Get Templatized Cluster Environments  # noqa: E501

        Returns all templatized cluster environments.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_templatized_cluster_environments_api_v2_application_templates_templatized_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: TemplatizeddecoratedapplicationtemplatesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_templatized_cluster_environments_api_v2_application_templates_templatized_get_with_http_info(**kwargs)  # noqa: E501

    def get_templatized_cluster_environments_api_v2_application_templates_templatized_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get Templatized Cluster Environments  # noqa: E501

        Returns all templatized cluster environments.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_templatized_cluster_environments_api_v2_application_templates_templatized_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(TemplatizeddecoratedapplicationtemplatesResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_templatized_cluster_environments_api_v2_application_templates_templatized_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/application_templates/templatized/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TemplatizeddecoratedapplicationtemplatesResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_templatized_compute_configs_api_v2_compute_templates_templatized_cloud_id_get(self, cloud_id, **kwargs):  # noqa: E501
        """Get Templatized Compute Configs  # noqa: E501

        Returns all templatized compute configurations for this cloud.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_templatized_compute_configs_api_v2_compute_templates_templatized_cloud_id_get(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: TemplatizedcomputeconfigsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_templatized_compute_configs_api_v2_compute_templates_templatized_cloud_id_get_with_http_info(cloud_id, **kwargs)  # noqa: E501

    def get_templatized_compute_configs_api_v2_compute_templates_templatized_cloud_id_get_with_http_info(self, cloud_id, **kwargs):  # noqa: E501
        """Get Templatized Compute Configs  # noqa: E501

        Returns all templatized compute configurations for this cloud.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_templatized_compute_configs_api_v2_compute_templates_templatized_cloud_id_get_with_http_info(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(TemplatizedcomputeconfigsResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_templatized_compute_configs_api_v2_compute_templates_templatized_cloud_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `get_templatized_compute_configs_api_v2_compute_templates_templatized_cloud_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/compute_templates/templatized/{cloud_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TemplatizedcomputeconfigsResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_user_info_api_v2_userinfo_get(self, **kwargs):  # noqa: E501
        """Get User Info  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user_info_api_v2_userinfo_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: UserinfoResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_user_info_api_v2_userinfo_get_with_http_info(**kwargs)  # noqa: E501

    def get_user_info_api_v2_userinfo_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get User Info  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user_info_api_v2_userinfo_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(UserinfoResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_user_info_api_v2_userinfo_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/userinfo/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UserinfoResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_workspace_api_v2_experimental_workspaces_workspace_id_get(self, workspace_id, **kwargs):  # noqa: E501
        """Get Workspace  # noqa: E501

        Retrieves a Workspace.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_workspace_api_v2_experimental_workspaces_workspace_id_get(workspace_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str workspace_id: ID of the Workspace to retreive. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ExperimentalworkspaceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_workspace_api_v2_experimental_workspaces_workspace_id_get_with_http_info(workspace_id, **kwargs)  # noqa: E501

    def get_workspace_api_v2_experimental_workspaces_workspace_id_get_with_http_info(self, workspace_id, **kwargs):  # noqa: E501
        """Get Workspace  # noqa: E501

        Retrieves a Workspace.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_workspace_api_v2_experimental_workspaces_workspace_id_get_with_http_info(workspace_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str workspace_id: ID of the Workspace to retreive. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ExperimentalworkspaceResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'workspace_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_workspace_api_v2_experimental_workspaces_workspace_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'workspace_id' is set
        if self.api_client.client_side_validation and ('workspace_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_id` when calling `get_workspace_api_v2_experimental_workspaces_workspace_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'workspace_id' in local_var_params:
            path_params['workspace_id'] = local_var_params['workspace_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/experimental_workspaces/{workspace_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ExperimentalworkspaceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_workspace_dataplane_artifacts_api_v2_experimental_workspaces_workspace_id_dataplane_artifacts_get(self, workspace_id, **kwargs):  # noqa: E501
        """Get Workspace Dataplane Artifacts  # noqa: E501

        Retrieve workspace dataplane artifacts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_workspace_dataplane_artifacts_api_v2_experimental_workspaces_workspace_id_dataplane_artifacts_get(workspace_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str workspace_id: ID of the Workspace to retrieve. (required)
        :param AccessMode access_mode: Access mode for the workspace artifacts.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: WorkspacedataplaneartifactsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_workspace_dataplane_artifacts_api_v2_experimental_workspaces_workspace_id_dataplane_artifacts_get_with_http_info(workspace_id, **kwargs)  # noqa: E501

    def get_workspace_dataplane_artifacts_api_v2_experimental_workspaces_workspace_id_dataplane_artifacts_get_with_http_info(self, workspace_id, **kwargs):  # noqa: E501
        """Get Workspace Dataplane Artifacts  # noqa: E501

        Retrieve workspace dataplane artifacts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_workspace_dataplane_artifacts_api_v2_experimental_workspaces_workspace_id_dataplane_artifacts_get_with_http_info(workspace_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str workspace_id: ID of the Workspace to retrieve. (required)
        :param AccessMode access_mode: Access mode for the workspace artifacts.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(WorkspacedataplaneartifactsResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'workspace_id',
            'access_mode'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_workspace_dataplane_artifacts_api_v2_experimental_workspaces_workspace_id_dataplane_artifacts_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'workspace_id' is set
        if self.api_client.client_side_validation and ('workspace_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_id` when calling `get_workspace_dataplane_artifacts_api_v2_experimental_workspaces_workspace_id_dataplane_artifacts_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'workspace_id' in local_var_params:
            path_params['workspace_id'] = local_var_params['workspace_id']  # noqa: E501

        query_params = []
        if 'access_mode' in local_var_params and local_var_params['access_mode'] is not None:  # noqa: E501
            query_params.append(('access_mode', local_var_params['access_mode']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/experimental_workspaces/{workspace_id}/dataplane_artifacts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='WorkspacedataplaneartifactsResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_workspace_events_api_v2_experimental_workspaces_workspace_id_events_get(self, workspace_id, **kwargs):  # noqa: E501
        """Get Workspace Events  # noqa: E501

        Retrieves events for a Workspace.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_workspace_events_api_v2_experimental_workspaces_workspace_id_events_get(workspace_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str workspace_id: ID of the Workspace to retreive. (required)
        :param list[WorkspaceEventSourceFilter] origin: Filter if origin of event is included in this list. If \"\" in this list, no origin will be included in filter, so no results will be returned. Default behavior is to include all origin values in filter.
        :param EventLevel level: Filter by level of event. If level is not set, query will return all level values
        :param str message: Filter by message of event. If message is not set, query will not filter for message
        :param datetime start_time: The start time for the query. If  start_time is not set, the query will use beginning of time.
        :param datetime end_time: The end time for the query. If end_time is not set, the query will use the time now.
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: WorkspaceeventListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_workspace_events_api_v2_experimental_workspaces_workspace_id_events_get_with_http_info(workspace_id, **kwargs)  # noqa: E501

    def get_workspace_events_api_v2_experimental_workspaces_workspace_id_events_get_with_http_info(self, workspace_id, **kwargs):  # noqa: E501
        """Get Workspace Events  # noqa: E501

        Retrieves events for a Workspace.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_workspace_events_api_v2_experimental_workspaces_workspace_id_events_get_with_http_info(workspace_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str workspace_id: ID of the Workspace to retreive. (required)
        :param list[WorkspaceEventSourceFilter] origin: Filter if origin of event is included in this list. If \"\" in this list, no origin will be included in filter, so no results will be returned. Default behavior is to include all origin values in filter.
        :param EventLevel level: Filter by level of event. If level is not set, query will return all level values
        :param str message: Filter by message of event. If message is not set, query will not filter for message
        :param datetime start_time: The start time for the query. If  start_time is not set, the query will use beginning of time.
        :param datetime end_time: The end time for the query. If end_time is not set, the query will use the time now.
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(WorkspaceeventListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'workspace_id',
            'origin',
            'level',
            'message',
            'start_time',
            'end_time',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_workspace_events_api_v2_experimental_workspaces_workspace_id_events_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'workspace_id' is set
        if self.api_client.client_side_validation and ('workspace_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_id` when calling `get_workspace_events_api_v2_experimental_workspaces_workspace_id_events_get`")  # noqa: E501

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 1000:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `get_workspace_events_api_v2_experimental_workspaces_workspace_id_events_get`, must be a value less than or equal to `1000`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `get_workspace_events_api_v2_experimental_workspaces_workspace_id_events_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'workspace_id' in local_var_params:
            path_params['workspace_id'] = local_var_params['workspace_id']  # noqa: E501

        query_params = []
        if 'origin' in local_var_params and local_var_params['origin'] is not None:  # noqa: E501
            query_params.append(('origin', local_var_params['origin']))  # noqa: E501
            collection_formats['origin'] = 'multi'  # noqa: E501
        if 'level' in local_var_params and local_var_params['level'] is not None:  # noqa: E501
            query_params.append(('level', local_var_params['level']))  # noqa: E501
        if 'message' in local_var_params and local_var_params['message'] is not None:  # noqa: E501
            query_params.append(('message', local_var_params['message']))  # noqa: E501
        if 'start_time' in local_var_params and local_var_params['start_time'] is not None:  # noqa: E501
            query_params.append(('start_time', local_var_params['start_time']))  # noqa: E501
        if 'end_time' in local_var_params and local_var_params['end_time'] is not None:  # noqa: E501
            query_params.append(('end_time', local_var_params['end_time']))  # noqa: E501
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/experimental_workspaces/{workspace_id}/events', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='WorkspaceeventListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_workspace_proxied_dataplane_artifacts_api_v2_experimental_workspaces_workspace_id_proxied_dataplane_artifacts_get(self, workspace_id, **kwargs):  # noqa: E501
        """Get Workspace Proxied Dataplane Artifacts  # noqa: E501

        Retrieve workspace dataplane artifacts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_workspace_proxied_dataplane_artifacts_api_v2_experimental_workspaces_workspace_id_proxied_dataplane_artifacts_get(workspace_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str workspace_id: ID of the Workspace to retrieve. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: WorkspacedataplaneproxiedartifactsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_workspace_proxied_dataplane_artifacts_api_v2_experimental_workspaces_workspace_id_proxied_dataplane_artifacts_get_with_http_info(workspace_id, **kwargs)  # noqa: E501

    def get_workspace_proxied_dataplane_artifacts_api_v2_experimental_workspaces_workspace_id_proxied_dataplane_artifacts_get_with_http_info(self, workspace_id, **kwargs):  # noqa: E501
        """Get Workspace Proxied Dataplane Artifacts  # noqa: E501

        Retrieve workspace dataplane artifacts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_workspace_proxied_dataplane_artifacts_api_v2_experimental_workspaces_workspace_id_proxied_dataplane_artifacts_get_with_http_info(workspace_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str workspace_id: ID of the Workspace to retrieve. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(WorkspacedataplaneproxiedartifactsResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'workspace_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_workspace_proxied_dataplane_artifacts_api_v2_experimental_workspaces_workspace_id_proxied_dataplane_artifacts_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'workspace_id' is set
        if self.api_client.client_side_validation and ('workspace_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_id` when calling `get_workspace_proxied_dataplane_artifacts_api_v2_experimental_workspaces_workspace_id_proxied_dataplane_artifacts_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'workspace_id' in local_var_params:
            path_params['workspace_id'] = local_var_params['workspace_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/experimental_workspaces/{workspace_id}/proxied_dataplane_artifacts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='WorkspacedataplaneproxiedartifactsResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_workspace_readme_api_v2_experimental_workspaces_workspace_id_readme_get(self, workspace_id, **kwargs):  # noqa: E501
        """Get Workspace Readme  # noqa: E501

        Retrieves a Workspace's README.md file.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_workspace_readme_api_v2_experimental_workspaces_workspace_id_readme_get(workspace_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str workspace_id: ID of the Workspace to retrieve. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: WorkspacereadmeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_workspace_readme_api_v2_experimental_workspaces_workspace_id_readme_get_with_http_info(workspace_id, **kwargs)  # noqa: E501

    def get_workspace_readme_api_v2_experimental_workspaces_workspace_id_readme_get_with_http_info(self, workspace_id, **kwargs):  # noqa: E501
        """Get Workspace Readme  # noqa: E501

        Retrieves a Workspace's README.md file.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_workspace_readme_api_v2_experimental_workspaces_workspace_id_readme_get_with_http_info(workspace_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str workspace_id: ID of the Workspace to retrieve. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(WorkspacereadmeResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'workspace_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_workspace_readme_api_v2_experimental_workspaces_workspace_id_readme_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'workspace_id' is set
        if self.api_client.client_side_validation and ('workspace_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_id` when calling `get_workspace_readme_api_v2_experimental_workspaces_workspace_id_readme_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'workspace_id' in local_var_params:
            path_params['workspace_id'] = local_var_params['workspace_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/experimental_workspaces/{workspace_id}/readme', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='WorkspacereadmeResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_workspace_template_cluster_environment_api_v2_experimental_workspaces_template_template_id_cluster_environment_get(self, template_id, **kwargs):  # noqa: E501
        """Get Workspace Template Cluster Environment  # noqa: E501

        Get the default cluster environment for a workspace template  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_workspace_template_cluster_environment_api_v2_experimental_workspaces_template_template_id_cluster_environment_get(template_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str template_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: WorkspacetemplateclusterenvironmentmetadataResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_workspace_template_cluster_environment_api_v2_experimental_workspaces_template_template_id_cluster_environment_get_with_http_info(template_id, **kwargs)  # noqa: E501

    def get_workspace_template_cluster_environment_api_v2_experimental_workspaces_template_template_id_cluster_environment_get_with_http_info(self, template_id, **kwargs):  # noqa: E501
        """Get Workspace Template Cluster Environment  # noqa: E501

        Get the default cluster environment for a workspace template  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_workspace_template_cluster_environment_api_v2_experimental_workspaces_template_template_id_cluster_environment_get_with_http_info(template_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str template_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(WorkspacetemplateclusterenvironmentmetadataResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'template_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_workspace_template_cluster_environment_api_v2_experimental_workspaces_template_template_id_cluster_environment_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'template_id' is set
        if self.api_client.client_side_validation and ('template_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['template_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `template_id` when calling `get_workspace_template_cluster_environment_api_v2_experimental_workspaces_template_template_id_cluster_environment_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'template_id' in local_var_params:
            path_params['template_id'] = local_var_params['template_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/experimental_workspaces/template/{template_id}/cluster_environment', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='WorkspacetemplateclusterenvironmentmetadataResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_workspace_template_compute_config_api_v2_experimental_workspaces_template_template_id_compute_config_get(self, template_id, cloud_id, **kwargs):  # noqa: E501
        """Get Workspace Template Compute Config  # noqa: E501

        Get the default compute config for a workspace template  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_workspace_template_compute_config_api_v2_experimental_workspaces_template_template_id_compute_config_get(template_id, cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str template_id: (required)
        :param str cloud_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CreatecomputetemplateconfigResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_workspace_template_compute_config_api_v2_experimental_workspaces_template_template_id_compute_config_get_with_http_info(template_id, cloud_id, **kwargs)  # noqa: E501

    def get_workspace_template_compute_config_api_v2_experimental_workspaces_template_template_id_compute_config_get_with_http_info(self, template_id, cloud_id, **kwargs):  # noqa: E501
        """Get Workspace Template Compute Config  # noqa: E501

        Get the default compute config for a workspace template  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_workspace_template_compute_config_api_v2_experimental_workspaces_template_template_id_compute_config_get_with_http_info(template_id, cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str template_id: (required)
        :param str cloud_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CreatecomputetemplateconfigResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'template_id',
            'cloud_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_workspace_template_compute_config_api_v2_experimental_workspaces_template_template_id_compute_config_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'template_id' is set
        if self.api_client.client_side_validation and ('template_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['template_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `template_id` when calling `get_workspace_template_compute_config_api_v2_experimental_workspaces_template_template_id_compute_config_get`")  # noqa: E501
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `get_workspace_template_compute_config_api_v2_experimental_workspaces_template_template_id_compute_config_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'template_id' in local_var_params:
            path_params['template_id'] = local_var_params['template_id']  # noqa: E501

        query_params = []
        if 'cloud_id' in local_var_params and local_var_params['cloud_id'] is not None:  # noqa: E501
            query_params.append(('cloud_id', local_var_params['cloud_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/experimental_workspaces/template/{template_id}/compute_config', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreatecomputetemplateconfigResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def handle_cloud_metrics_auth_api_v2_authentication_cloud_id_cloud_persistent_metrics_get(self, cloud_id, **kwargs):  # noqa: E501
        """Handle Cloud Metrics Auth  # noqa: E501

        Helps a browser set an authentication cookie for a given session.  This returns an HTML page that POSTS the token to the session.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.handle_cloud_metrics_auth_api_v2_authentication_cloud_id_cloud_persistent_metrics_get(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ClusterauthresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.handle_cloud_metrics_auth_api_v2_authentication_cloud_id_cloud_persistent_metrics_get_with_http_info(cloud_id, **kwargs)  # noqa: E501

    def handle_cloud_metrics_auth_api_v2_authentication_cloud_id_cloud_persistent_metrics_get_with_http_info(self, cloud_id, **kwargs):  # noqa: E501
        """Handle Cloud Metrics Auth  # noqa: E501

        Helps a browser set an authentication cookie for a given session.  This returns an HTML page that POSTS the token to the session.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.handle_cloud_metrics_auth_api_v2_authentication_cloud_id_cloud_persistent_metrics_get_with_http_info(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ClusterauthresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method handle_cloud_metrics_auth_api_v2_authentication_cloud_id_cloud_persistent_metrics_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `handle_cloud_metrics_auth_api_v2_authentication_cloud_id_cloud_persistent_metrics_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/authentication/{cloud_id}/cloud_persistent_metrics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClusterauthresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def handle_cluster_auth_api_v2_authentication_cluster_id_cluster_get(self, cluster_id, **kwargs):  # noqa: E501
        """Handle Cluster Auth  # noqa: E501

        Helps a browser set an authentication cookie for a given session.  This returns an HTML page that POSTS the token to the session.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.handle_cluster_auth_api_v2_authentication_cluster_id_cluster_get(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param str original_href:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ClusterauthresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.handle_cluster_auth_api_v2_authentication_cluster_id_cluster_get_with_http_info(cluster_id, **kwargs)  # noqa: E501

    def handle_cluster_auth_api_v2_authentication_cluster_id_cluster_get_with_http_info(self, cluster_id, **kwargs):  # noqa: E501
        """Handle Cluster Auth  # noqa: E501

        Helps a browser set an authentication cookie for a given session.  This returns an HTML page that POSTS the token to the session.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.handle_cluster_auth_api_v2_authentication_cluster_id_cluster_get_with_http_info(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param str original_href:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ClusterauthresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cluster_id',
            'original_href'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method handle_cluster_auth_api_v2_authentication_cluster_id_cluster_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and ('cluster_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cluster_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `handle_cluster_auth_api_v2_authentication_cluster_id_cluster_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in local_var_params:
            path_params['cluster_id'] = local_var_params['cluster_id']  # noqa: E501

        query_params = []
        if 'original_href' in local_var_params and local_var_params['original_href'] is not None:  # noqa: E501
            query_params.append(('original_href', local_var_params['original_href']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/authentication/{cluster_id}/cluster', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClusterauthresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def handle_webhook_api_v2_metronome_webhooks_handle_webhook_post(self, create_metronome_webhook_notification, **kwargs):  # noqa: E501
        """Handle Webhook  # noqa: E501

        Records a Metronome webhook notification and immediately returns.       # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.handle_webhook_api_v2_metronome_webhooks_handle_webhook_post(create_metronome_webhook_notification, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateMetronomeWebhookNotification create_metronome_webhook_notification: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.handle_webhook_api_v2_metronome_webhooks_handle_webhook_post_with_http_info(create_metronome_webhook_notification, **kwargs)  # noqa: E501

    def handle_webhook_api_v2_metronome_webhooks_handle_webhook_post_with_http_info(self, create_metronome_webhook_notification, **kwargs):  # noqa: E501
        """Handle Webhook  # noqa: E501

        Records a Metronome webhook notification and immediately returns.       # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.handle_webhook_api_v2_metronome_webhooks_handle_webhook_post_with_http_info(create_metronome_webhook_notification, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateMetronomeWebhookNotification create_metronome_webhook_notification: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'create_metronome_webhook_notification'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method handle_webhook_api_v2_metronome_webhooks_handle_webhook_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'create_metronome_webhook_notification' is set
        if self.api_client.client_side_validation and ('create_metronome_webhook_notification' not in local_var_params or  # noqa: E501
                                                        local_var_params['create_metronome_webhook_notification'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `create_metronome_webhook_notification` when calling `handle_webhook_api_v2_metronome_webhooks_handle_webhook_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_metronome_webhook_notification' in local_var_params:
            body_params = local_var_params['create_metronome_webhook_notification']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/metronome_webhooks/handle_webhook', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def health_check_api_v2_health_get(self, **kwargs):  # noqa: E501
        """Health Check  # noqa: E501

        Health check router used to make sure the pod is ready to serve traffic.       # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.health_check_api_v2_health_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.health_check_api_v2_health_get_with_http_info(**kwargs)  # noqa: E501

    def health_check_api_v2_health_get_with_http_info(self, **kwargs):  # noqa: E501
        """Health Check  # noqa: E501

        Health check router used to make sure the pod is ready to serve traffic.       # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.health_check_api_v2_health_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method health_check_api_v2_health_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/health/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def import_model_api_v2_aica_endpoints_import_model_post(self, import_aica_model, **kwargs):  # noqa: E501
        """Import Model  # noqa: E501

        Imports a model.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_model_api_v2_aica_endpoints_import_model_post(import_aica_model, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ImportAicaModel import_aica_model: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AicamodelResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.import_model_api_v2_aica_endpoints_import_model_post_with_http_info(import_aica_model, **kwargs)  # noqa: E501

    def import_model_api_v2_aica_endpoints_import_model_post_with_http_info(self, import_aica_model, **kwargs):  # noqa: E501
        """Import Model  # noqa: E501

        Imports a model.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_model_api_v2_aica_endpoints_import_model_post_with_http_info(import_aica_model, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ImportAicaModel import_aica_model: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AicamodelResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'import_aica_model'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method import_model_api_v2_aica_endpoints_import_model_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'import_aica_model' is set
        if self.api_client.client_side_validation and ('import_aica_model' not in local_var_params or  # noqa: E501
                                                        local_var_params['import_aica_model'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `import_aica_model` when calling `import_model_api_v2_aica_endpoints_import_model_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'import_aica_model' in local_var_params:
            body_params = local_var_params['import_aica_model']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/aica_endpoints/import_model', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AicamodelResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def invalidate_invitation_api_v2_organization_invitations_invitation_id_invalidate_post(self, invitation_id, **kwargs):  # noqa: E501
        """Invalidate Invitation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.invalidate_invitation_api_v2_organization_invitations_invitation_id_invalidate_post(invitation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str invitation_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: OrganizationinvitationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.invalidate_invitation_api_v2_organization_invitations_invitation_id_invalidate_post_with_http_info(invitation_id, **kwargs)  # noqa: E501

    def invalidate_invitation_api_v2_organization_invitations_invitation_id_invalidate_post_with_http_info(self, invitation_id, **kwargs):  # noqa: E501
        """Invalidate Invitation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.invalidate_invitation_api_v2_organization_invitations_invitation_id_invalidate_post_with_http_info(invitation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str invitation_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(OrganizationinvitationResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'invitation_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method invalidate_invitation_api_v2_organization_invitations_invitation_id_invalidate_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'invitation_id' is set
        if self.api_client.client_side_validation and ('invitation_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['invitation_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `invitation_id` when calling `invalidate_invitation_api_v2_organization_invitations_invitation_id_invalidate_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'invitation_id' in local_var_params:
            path_params['invitation_id'] = local_var_params['invitation_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organization_invitations/{invitation_id}/invalidate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OrganizationinvitationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def is_valid_api_v2_authentication_hex_token_id_is_valid_post(self, hex_token_id, **kwargs):  # noqa: E501
        """Is Valid  # noqa: E501

        Checks if a given token (specified by the Token ID) is valid.  NOTE: This is a POST method to prevent caching.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.is_valid_api_v2_authentication_hex_token_id_is_valid_post(hex_token_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str hex_token_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.is_valid_api_v2_authentication_hex_token_id_is_valid_post_with_http_info(hex_token_id, **kwargs)  # noqa: E501

    def is_valid_api_v2_authentication_hex_token_id_is_valid_post_with_http_info(self, hex_token_id, **kwargs):  # noqa: E501
        """Is Valid  # noqa: E501

        Checks if a given token (specified by the Token ID) is valid.  NOTE: This is a POST method to prevent caching.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.is_valid_api_v2_authentication_hex_token_id_is_valid_post_with_http_info(hex_token_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str hex_token_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'hex_token_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method is_valid_api_v2_authentication_hex_token_id_is_valid_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'hex_token_id' is set
        if self.api_client.client_side_validation and ('hex_token_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['hex_token_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `hex_token_id` when calling `is_valid_api_v2_authentication_hex_token_id_is_valid_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'hex_token_id' in local_var_params:
            path_params['hex_token_id'] = local_var_params['hex_token_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/authentication/{hex_token_id}/is_valid', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def kill_session_command_api_v2_session_commands_session_command_id_kill_post(self, session_command_id, **kwargs):  # noqa: E501
        """Kill Session Command  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.kill_session_command_api_v2_session_commands_session_command_id_kill_post(session_command_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_command_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.kill_session_command_api_v2_session_commands_session_command_id_kill_post_with_http_info(session_command_id, **kwargs)  # noqa: E501

    def kill_session_command_api_v2_session_commands_session_command_id_kill_post_with_http_info(self, session_command_id, **kwargs):  # noqa: E501
        """Kill Session Command  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.kill_session_command_api_v2_session_commands_session_command_id_kill_post_with_http_info(session_command_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_command_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'session_command_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method kill_session_command_api_v2_session_commands_session_command_id_kill_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'session_command_id' is set
        if self.api_client.client_side_validation and ('session_command_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_command_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_command_id` when calling `kill_session_command_api_v2_session_commands_session_command_id_kill_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'session_command_id' in local_var_params:
            path_params['session_command_id'] = local_var_params['session_command_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/session_commands/{session_command_id}/kill', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_aica_endpoint_events_api_v2_aica_endpoints_endpoint_id_events_get(self, endpoint_id, **kwargs):  # noqa: E501
        """List Aica Endpoint Events  # noqa: E501

        Lists up to 1000 events of the AICA endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_aica_endpoint_events_api_v2_aica_endpoints_endpoint_id_events_get(endpoint_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str endpoint_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AicaendpointeventListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_aica_endpoint_events_api_v2_aica_endpoints_endpoint_id_events_get_with_http_info(endpoint_id, **kwargs)  # noqa: E501

    def list_aica_endpoint_events_api_v2_aica_endpoints_endpoint_id_events_get_with_http_info(self, endpoint_id, **kwargs):  # noqa: E501
        """List Aica Endpoint Events  # noqa: E501

        Lists up to 1000 events of the AICA endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_aica_endpoint_events_api_v2_aica_endpoints_endpoint_id_events_get_with_http_info(endpoint_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str endpoint_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AicaendpointeventListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'endpoint_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_aica_endpoint_events_api_v2_aica_endpoints_endpoint_id_events_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'endpoint_id' is set
        if self.api_client.client_side_validation and ('endpoint_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['endpoint_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `endpoint_id` when calling `list_aica_endpoint_events_api_v2_aica_endpoints_endpoint_id_events_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'endpoint_id' in local_var_params:
            path_params['endpoint_id'] = local_var_params['endpoint_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/aica_endpoints/{endpoint_id}/events', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AicaendpointeventListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_aica_endpoints_api_v2_aica_endpoints_get(self, **kwargs):  # noqa: E501
        """List Aica Endpoints  # noqa: E501

        Lists all endpoints the user has access to  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_aica_endpoints_api_v2_aica_endpoints_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str name: Search for endpoints with a name that equals the provided value
        :param str name_contains: Search for endpoints with a name that contains the provided value
        :param str creator_id: List endpoints created by a given user
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AicaendpointListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_aica_endpoints_api_v2_aica_endpoints_get_with_http_info(**kwargs)  # noqa: E501

    def list_aica_endpoints_api_v2_aica_endpoints_get_with_http_info(self, **kwargs):  # noqa: E501
        """List Aica Endpoints  # noqa: E501

        Lists all endpoints the user has access to  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_aica_endpoints_api_v2_aica_endpoints_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str name: Search for endpoints with a name that equals the provided value
        :param str name_contains: Search for endpoints with a name that contains the provided value
        :param str creator_id: List endpoints created by a given user
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AicaendpointListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'name',
            'name_contains',
            'creator_id',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_aica_endpoints_api_v2_aica_endpoints_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 50:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_aica_endpoints_api_v2_aica_endpoints_get`, must be a value less than or equal to `50`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_aica_endpoints_api_v2_aica_endpoints_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
            query_params.append(('name', local_var_params['name']))  # noqa: E501
        if 'name_contains' in local_var_params and local_var_params['name_contains'] is not None:  # noqa: E501
            query_params.append(('name_contains', local_var_params['name_contains']))  # noqa: E501
        if 'creator_id' in local_var_params and local_var_params['creator_id'] is not None:  # noqa: E501
            query_params.append(('creator_id', local_var_params['creator_id']))  # noqa: E501
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/aica_endpoints/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AicaendpointListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_application_templates_api_v2_application_templates_get(self, **kwargs):  # noqa: E501
        """List Application Templates  # noqa: E501

        Lists all Cluster Environments belonging to a Project. Note: cluster_environment is called app_config on the backend api.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_application_templates_api_v2_application_templates_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id:
        :param str creator_id:
        :param str name_contains:
        :param bool include_archived: Whether to include archived cluster environments in the response.
        :param bool defaults_first: If True, we always return default cluster envs before user created cluster envs. If False, we always return default cluster envs after user created cluster envs. If absent, default to True. Note that we never intersperse default cluster envs with user created cluster envs.
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedapplicationtemplateListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_application_templates_api_v2_application_templates_get_with_http_info(**kwargs)  # noqa: E501

    def list_application_templates_api_v2_application_templates_get_with_http_info(self, **kwargs):  # noqa: E501
        """List Application Templates  # noqa: E501

        Lists all Cluster Environments belonging to a Project. Note: cluster_environment is called app_config on the backend api.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_application_templates_api_v2_application_templates_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id:
        :param str creator_id:
        :param str name_contains:
        :param bool include_archived: Whether to include archived cluster environments in the response.
        :param bool defaults_first: If True, we always return default cluster envs before user created cluster envs. If False, we always return default cluster envs after user created cluster envs. If absent, default to True. Note that we never intersperse default cluster envs with user created cluster envs.
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedapplicationtemplateListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project_id',
            'creator_id',
            'name_contains',
            'include_archived',
            'defaults_first',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_application_templates_api_v2_application_templates_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 1000:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_application_templates_api_v2_application_templates_get`, must be a value less than or equal to `1000`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_application_templates_api_v2_application_templates_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'project_id' in local_var_params and local_var_params['project_id'] is not None:  # noqa: E501
            query_params.append(('project_id', local_var_params['project_id']))  # noqa: E501
        if 'creator_id' in local_var_params and local_var_params['creator_id'] is not None:  # noqa: E501
            query_params.append(('creator_id', local_var_params['creator_id']))  # noqa: E501
        if 'name_contains' in local_var_params and local_var_params['name_contains'] is not None:  # noqa: E501
            query_params.append(('name_contains', local_var_params['name_contains']))  # noqa: E501
        if 'include_archived' in local_var_params and local_var_params['include_archived'] is not None:  # noqa: E501
            query_params.append(('include_archived', local_var_params['include_archived']))  # noqa: E501
        if 'defaults_first' in local_var_params and local_var_params['defaults_first'] is not None:  # noqa: E501
            query_params.append(('defaults_first', local_var_params['defaults_first']))  # noqa: E501
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/application_templates/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedapplicationtemplateListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_builds_api_v2_builds_get(self, application_template_id, **kwargs):  # noqa: E501
        """List Builds  # noqa: E501

        Lists all Builds belonging to an App Config.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_builds_api_v2_builds_get(application_template_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str application_template_id: (required)
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedbuildListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_builds_api_v2_builds_get_with_http_info(application_template_id, **kwargs)  # noqa: E501

    def list_builds_api_v2_builds_get_with_http_info(self, application_template_id, **kwargs):  # noqa: E501
        """List Builds  # noqa: E501

        Lists all Builds belonging to an App Config.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_builds_api_v2_builds_get_with_http_info(application_template_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str application_template_id: (required)
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedbuildListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'application_template_id',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_builds_api_v2_builds_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_template_id' is set
        if self.api_client.client_side_validation and ('application_template_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_template_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_template_id` when calling `list_builds_api_v2_builds_get`")  # noqa: E501

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 1000:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_builds_api_v2_builds_get`, must be a value less than or equal to `1000`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_builds_api_v2_builds_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'application_template_id' in local_var_params and local_var_params['application_template_id'] is not None:  # noqa: E501
            query_params.append(('application_template_id', local_var_params['application_template_id']))  # noqa: E501
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/builds/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedbuildListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_clouds_api_v2_clouds_get(self, **kwargs):  # noqa: E501
        """List Clouds  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_clouds_api_v2_clouds_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CloudListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_clouds_api_v2_clouds_get_with_http_info(**kwargs)  # noqa: E501

    def list_clouds_api_v2_clouds_get_with_http_info(self, **kwargs):  # noqa: E501
        """List Clouds  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_clouds_api_v2_clouds_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CloudListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_clouds_api_v2_clouds_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 1000:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_clouds_api_v2_clouds_get`, must be a value less than or equal to `1000`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_clouds_api_v2_clouds_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CloudListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_cron_jobs_api_v2_experimental_cron_jobs_get(self, **kwargs):  # noqa: E501
        """List Cron Jobs  # noqa: E501

        List CRON Job  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_cron_jobs_api_v2_experimental_cron_jobs_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: project_id to filter by
        :param str name: name to filter by
        :param str creator_id: filter by creator id
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedscheduleListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_cron_jobs_api_v2_experimental_cron_jobs_get_with_http_info(**kwargs)  # noqa: E501

    def list_cron_jobs_api_v2_experimental_cron_jobs_get_with_http_info(self, **kwargs):  # noqa: E501
        """List Cron Jobs  # noqa: E501

        List CRON Job  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_cron_jobs_api_v2_experimental_cron_jobs_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: project_id to filter by
        :param str name: name to filter by
        :param str creator_id: filter by creator id
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedscheduleListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project_id',
            'name',
            'creator_id',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_cron_jobs_api_v2_experimental_cron_jobs_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 50:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_cron_jobs_api_v2_experimental_cron_jobs_get`, must be a value less than or equal to `50`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_cron_jobs_api_v2_experimental_cron_jobs_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'project_id' in local_var_params and local_var_params['project_id'] is not None:  # noqa: E501
            query_params.append(('project_id', local_var_params['project_id']))  # noqa: E501
        if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
            query_params.append(('name', local_var_params['name']))  # noqa: E501
        if 'creator_id' in local_var_params and local_var_params['creator_id'] is not None:  # noqa: E501
            query_params.append(('creator_id', local_var_params['creator_id']))  # noqa: E501
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/experimental_cron_jobs/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedscheduleListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_decorated_clusters_api_v2_decorated_sessions_get(self, **kwargs):  # noqa: E501
        """List Decorated Clusters  # noqa: E501

        List all sessions for a project  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_decorated_clusters_api_v2_decorated_sessions_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: project_id to filter by
        :param str name_match: a wildcard match for session names. This endpoint will raise an error if both name and name_match is provided.
        :param str creator_id: creator_id to filter by
        :param list[SessionState] state_filter: A list of session states to filter by
        :param ArchiveStatus archive_status: The archive status to filter by. Defaults to unarchived.
        :param SessionsSortField sort_field: If absent, the sort order will be determined according to the type_filter.
        :param SortOrder sort_order: If sort_field is absent, this field is ignored.If absent, this field defaults to ascending.
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedsessionListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_decorated_clusters_api_v2_decorated_sessions_get_with_http_info(**kwargs)  # noqa: E501

    def list_decorated_clusters_api_v2_decorated_sessions_get_with_http_info(self, **kwargs):  # noqa: E501
        """List Decorated Clusters  # noqa: E501

        List all sessions for a project  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_decorated_clusters_api_v2_decorated_sessions_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: project_id to filter by
        :param str name_match: a wildcard match for session names. This endpoint will raise an error if both name and name_match is provided.
        :param str creator_id: creator_id to filter by
        :param list[SessionState] state_filter: A list of session states to filter by
        :param ArchiveStatus archive_status: The archive status to filter by. Defaults to unarchived.
        :param SessionsSortField sort_field: If absent, the sort order will be determined according to the type_filter.
        :param SortOrder sort_order: If sort_field is absent, this field is ignored.If absent, this field defaults to ascending.
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedsessionListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project_id',
            'name_match',
            'creator_id',
            'state_filter',
            'archive_status',
            'sort_field',
            'sort_order',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_decorated_clusters_api_v2_decorated_sessions_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 50:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_decorated_clusters_api_v2_decorated_sessions_get`, must be a value less than or equal to `50`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_decorated_clusters_api_v2_decorated_sessions_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'project_id' in local_var_params and local_var_params['project_id'] is not None:  # noqa: E501
            query_params.append(('project_id', local_var_params['project_id']))  # noqa: E501
        if 'name_match' in local_var_params and local_var_params['name_match'] is not None:  # noqa: E501
            query_params.append(('name_match', local_var_params['name_match']))  # noqa: E501
        if 'creator_id' in local_var_params and local_var_params['creator_id'] is not None:  # noqa: E501
            query_params.append(('creator_id', local_var_params['creator_id']))  # noqa: E501
        if 'state_filter' in local_var_params and local_var_params['state_filter'] is not None:  # noqa: E501
            query_params.append(('state_filter', local_var_params['state_filter']))  # noqa: E501
            collection_formats['state_filter'] = 'multi'  # noqa: E501
        if 'archive_status' in local_var_params and local_var_params['archive_status'] is not None:  # noqa: E501
            query_params.append(('archive_status', local_var_params['archive_status']))  # noqa: E501
        if 'sort_field' in local_var_params and local_var_params['sort_field'] is not None:  # noqa: E501
            query_params.append(('sort_field', local_var_params['sort_field']))  # noqa: E501
        if 'sort_order' in local_var_params and local_var_params['sort_order'] is not None:  # noqa: E501
            query_params.append(('sort_order', local_var_params['sort_order']))  # noqa: E501
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/decorated_sessions/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedsessionListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_decorated_interactive_sessions_api_v2_decorated_interactive_sessions_get(self, **kwargs):  # noqa: E501
        """List Decorated Interactive Sessions  # noqa: E501

        Optionally filter by project and runtime_env_id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_decorated_interactive_sessions_api_v2_decorated_interactive_sessions_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: project_id to filter by
        :param str runtime_env_id: runtime_env_id to filter by
        :param str cluster_id: cluster_id to filter by
        :param str creator_id: creator_id to filter by
        :param str name: name to filter by
        :param str ha_job_id: ha_job_id to filter by
        :param bool show_ray_client_runs_only: DEPRECATED: Shows only ray client runs. Orthogonaol to passing ha_job_id
        :param list[JobRunType] type_filter: Filter Jobs by their type. Their type is determined by their usage within the product e.g. Interactive sessions, job runs
        :param list[BaseJobStatus] state_filter: A list of session states to filter by
        :param str order: 'asc' for ascending, 'desc' for descending. Entirely ignored.
        :param JobsSortField sort_field: If absent, the sort order will be determined according to the type_filter.
        :param SortOrder sort_order: If sort_field is absent, this field is ignored.If absent, this field defaults to ascending.
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedinteractivesessionListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_decorated_interactive_sessions_api_v2_decorated_interactive_sessions_get_with_http_info(**kwargs)  # noqa: E501

    def list_decorated_interactive_sessions_api_v2_decorated_interactive_sessions_get_with_http_info(self, **kwargs):  # noqa: E501
        """List Decorated Interactive Sessions  # noqa: E501

        Optionally filter by project and runtime_env_id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_decorated_interactive_sessions_api_v2_decorated_interactive_sessions_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: project_id to filter by
        :param str runtime_env_id: runtime_env_id to filter by
        :param str cluster_id: cluster_id to filter by
        :param str creator_id: creator_id to filter by
        :param str name: name to filter by
        :param str ha_job_id: ha_job_id to filter by
        :param bool show_ray_client_runs_only: DEPRECATED: Shows only ray client runs. Orthogonaol to passing ha_job_id
        :param list[JobRunType] type_filter: Filter Jobs by their type. Their type is determined by their usage within the product e.g. Interactive sessions, job runs
        :param list[BaseJobStatus] state_filter: A list of session states to filter by
        :param str order: 'asc' for ascending, 'desc' for descending. Entirely ignored.
        :param JobsSortField sort_field: If absent, the sort order will be determined according to the type_filter.
        :param SortOrder sort_order: If sort_field is absent, this field is ignored.If absent, this field defaults to ascending.
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedinteractivesessionListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project_id',
            'runtime_env_id',
            'cluster_id',
            'creator_id',
            'name',
            'ha_job_id',
            'show_ray_client_runs_only',
            'type_filter',
            'state_filter',
            'order',
            'sort_field',
            'sort_order',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_decorated_interactive_sessions_api_v2_decorated_interactive_sessions_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 50:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_decorated_interactive_sessions_api_v2_decorated_interactive_sessions_get`, must be a value less than or equal to `50`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_decorated_interactive_sessions_api_v2_decorated_interactive_sessions_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'project_id' in local_var_params and local_var_params['project_id'] is not None:  # noqa: E501
            query_params.append(('project_id', local_var_params['project_id']))  # noqa: E501
        if 'runtime_env_id' in local_var_params and local_var_params['runtime_env_id'] is not None:  # noqa: E501
            query_params.append(('runtime_env_id', local_var_params['runtime_env_id']))  # noqa: E501
        if 'cluster_id' in local_var_params and local_var_params['cluster_id'] is not None:  # noqa: E501
            query_params.append(('cluster_id', local_var_params['cluster_id']))  # noqa: E501
        if 'creator_id' in local_var_params and local_var_params['creator_id'] is not None:  # noqa: E501
            query_params.append(('creator_id', local_var_params['creator_id']))  # noqa: E501
        if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
            query_params.append(('name', local_var_params['name']))  # noqa: E501
        if 'ha_job_id' in local_var_params and local_var_params['ha_job_id'] is not None:  # noqa: E501
            query_params.append(('ha_job_id', local_var_params['ha_job_id']))  # noqa: E501
        if 'show_ray_client_runs_only' in local_var_params and local_var_params['show_ray_client_runs_only'] is not None:  # noqa: E501
            query_params.append(('show_ray_client_runs_only', local_var_params['show_ray_client_runs_only']))  # noqa: E501
        if 'type_filter' in local_var_params and local_var_params['type_filter'] is not None:  # noqa: E501
            query_params.append(('type_filter', local_var_params['type_filter']))  # noqa: E501
            collection_formats['type_filter'] = 'multi'  # noqa: E501
        if 'state_filter' in local_var_params and local_var_params['state_filter'] is not None:  # noqa: E501
            query_params.append(('state_filter', local_var_params['state_filter']))  # noqa: E501
            collection_formats['state_filter'] = 'multi'  # noqa: E501
        if 'order' in local_var_params and local_var_params['order'] is not None:  # noqa: E501
            query_params.append(('order', local_var_params['order']))  # noqa: E501
        if 'sort_field' in local_var_params and local_var_params['sort_field'] is not None:  # noqa: E501
            query_params.append(('sort_field', local_var_params['sort_field']))  # noqa: E501
        if 'sort_order' in local_var_params and local_var_params['sort_order'] is not None:  # noqa: E501
            query_params.append(('sort_order', local_var_params['sort_order']))  # noqa: E501
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/decorated_interactive_sessions/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedinteractivesessionListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_decorated_job_submissions_api_v2_decorated_job_submissions_get(self, **kwargs):  # noqa: E501
        """List Decorated Job Submissions  # noqa: E501

        Get all the job submissions based on the passed in criteria.  Returns ------- ListResponse[DecoratedJobSubmission]     selected DecoratedJobSubmission based on the passed in criteria, or empty ListResponse if there is nothing found  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_decorated_job_submissions_api_v2_decorated_job_submissions_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str creator_id: creator_id to filter by
        :param str name: ray_job_submission_id to filter by
        :param str ha_job_id: ha_job_id to filter by
        :param list[JobStatus] state_filter: A list of job submission states to filter by
        :param JobSubmissionsSortField sort_field: If absent, the sort order will be determined according to the type_filter.
        :param SortOrder sort_order: If sort_field is absent, this field is ignored.If absent, this field defaults to ascending.
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedjobsubmissionListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_decorated_job_submissions_api_v2_decorated_job_submissions_get_with_http_info(**kwargs)  # noqa: E501

    def list_decorated_job_submissions_api_v2_decorated_job_submissions_get_with_http_info(self, **kwargs):  # noqa: E501
        """List Decorated Job Submissions  # noqa: E501

        Get all the job submissions based on the passed in criteria.  Returns ------- ListResponse[DecoratedJobSubmission]     selected DecoratedJobSubmission based on the passed in criteria, or empty ListResponse if there is nothing found  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_decorated_job_submissions_api_v2_decorated_job_submissions_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str creator_id: creator_id to filter by
        :param str name: ray_job_submission_id to filter by
        :param str ha_job_id: ha_job_id to filter by
        :param list[JobStatus] state_filter: A list of job submission states to filter by
        :param JobSubmissionsSortField sort_field: If absent, the sort order will be determined according to the type_filter.
        :param SortOrder sort_order: If sort_field is absent, this field is ignored.If absent, this field defaults to ascending.
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedjobsubmissionListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'creator_id',
            'name',
            'ha_job_id',
            'state_filter',
            'sort_field',
            'sort_order',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_decorated_job_submissions_api_v2_decorated_job_submissions_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 50:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_decorated_job_submissions_api_v2_decorated_job_submissions_get`, must be a value less than or equal to `50`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_decorated_job_submissions_api_v2_decorated_job_submissions_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'creator_id' in local_var_params and local_var_params['creator_id'] is not None:  # noqa: E501
            query_params.append(('creator_id', local_var_params['creator_id']))  # noqa: E501
        if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
            query_params.append(('name', local_var_params['name']))  # noqa: E501
        if 'ha_job_id' in local_var_params and local_var_params['ha_job_id'] is not None:  # noqa: E501
            query_params.append(('ha_job_id', local_var_params['ha_job_id']))  # noqa: E501
        if 'state_filter' in local_var_params and local_var_params['state_filter'] is not None:  # noqa: E501
            query_params.append(('state_filter', local_var_params['state_filter']))  # noqa: E501
            collection_formats['state_filter'] = 'multi'  # noqa: E501
        if 'sort_field' in local_var_params and local_var_params['sort_field'] is not None:  # noqa: E501
            query_params.append(('sort_field', local_var_params['sort_field']))  # noqa: E501
        if 'sort_order' in local_var_params and local_var_params['sort_order'] is not None:  # noqa: E501
            query_params.append(('sort_order', local_var_params['sort_order']))  # noqa: E501
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/decorated_job_submissions/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedjobsubmissionListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_decorated_jobs_api_v2_decorated_ha_jobs_get(self, **kwargs):  # noqa: E501
        """List Decorated Jobs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_decorated_jobs_api_v2_decorated_ha_jobs_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: project_id to filter by
        :param str workspace_id: workspace_id to filter by
        :param str name: name to filter by
        :param list[HaJobStates] state_filter: A list of session states to filter by
        :param HaJobType type_filter: The job type to filter by
        :param str creator_id: filter by creator id
        :param str source_cron_job_id: filter by cron_job_id id
        :param ArchiveStatus archive_status: The archive status to filter by. Defaults to unarchived.
        :param HaJobsSortField sort_field: If absent, the sort order will be determined according to the type_filter.
        :param SortOrder sort_order: If sort_field is absent, this field is ignored.If absent, this field defaults to ascending.
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedproductionjobListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_decorated_jobs_api_v2_decorated_ha_jobs_get_with_http_info(**kwargs)  # noqa: E501

    def list_decorated_jobs_api_v2_decorated_ha_jobs_get_with_http_info(self, **kwargs):  # noqa: E501
        """List Decorated Jobs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_decorated_jobs_api_v2_decorated_ha_jobs_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: project_id to filter by
        :param str workspace_id: workspace_id to filter by
        :param str name: name to filter by
        :param list[HaJobStates] state_filter: A list of session states to filter by
        :param HaJobType type_filter: The job type to filter by
        :param str creator_id: filter by creator id
        :param str source_cron_job_id: filter by cron_job_id id
        :param ArchiveStatus archive_status: The archive status to filter by. Defaults to unarchived.
        :param HaJobsSortField sort_field: If absent, the sort order will be determined according to the type_filter.
        :param SortOrder sort_order: If sort_field is absent, this field is ignored.If absent, this field defaults to ascending.
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedproductionjobListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project_id',
            'workspace_id',
            'name',
            'state_filter',
            'type_filter',
            'creator_id',
            'source_cron_job_id',
            'archive_status',
            'sort_field',
            'sort_order',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_decorated_jobs_api_v2_decorated_ha_jobs_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 50:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_decorated_jobs_api_v2_decorated_ha_jobs_get`, must be a value less than or equal to `50`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_decorated_jobs_api_v2_decorated_ha_jobs_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'project_id' in local_var_params and local_var_params['project_id'] is not None:  # noqa: E501
            query_params.append(('project_id', local_var_params['project_id']))  # noqa: E501
        if 'workspace_id' in local_var_params and local_var_params['workspace_id'] is not None:  # noqa: E501
            query_params.append(('workspace_id', local_var_params['workspace_id']))  # noqa: E501
        if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
            query_params.append(('name', local_var_params['name']))  # noqa: E501
        if 'state_filter' in local_var_params and local_var_params['state_filter'] is not None:  # noqa: E501
            query_params.append(('state_filter', local_var_params['state_filter']))  # noqa: E501
            collection_formats['state_filter'] = 'multi'  # noqa: E501
        if 'type_filter' in local_var_params and local_var_params['type_filter'] is not None:  # noqa: E501
            query_params.append(('type_filter', local_var_params['type_filter']))  # noqa: E501
        if 'creator_id' in local_var_params and local_var_params['creator_id'] is not None:  # noqa: E501
            query_params.append(('creator_id', local_var_params['creator_id']))  # noqa: E501
        if 'source_cron_job_id' in local_var_params and local_var_params['source_cron_job_id'] is not None:  # noqa: E501
            query_params.append(('source_cron_job_id', local_var_params['source_cron_job_id']))  # noqa: E501
        if 'archive_status' in local_var_params and local_var_params['archive_status'] is not None:  # noqa: E501
            query_params.append(('archive_status', local_var_params['archive_status']))  # noqa: E501
        if 'sort_field' in local_var_params and local_var_params['sort_field'] is not None:  # noqa: E501
            query_params.append(('sort_field', local_var_params['sort_field']))  # noqa: E501
        if 'sort_order' in local_var_params and local_var_params['sort_order'] is not None:  # noqa: E501
            query_params.append(('sort_order', local_var_params['sort_order']))  # noqa: E501
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/decorated_ha_jobs/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedproductionjobListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_decorated_jobs_api_v2_decorated_jobs_get(self, **kwargs):  # noqa: E501
        """List Decorated Jobs  # noqa: E501

        DEPRECATED: Use list_decorated_interactive_sessions. List all decorated jobs. Optionally filter by project and runtime_env_id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_decorated_jobs_api_v2_decorated_jobs_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: project_id to filter by
        :param str runtime_env_id: runtime_env_id to filter by
        :param str cluster_id: cluster_id to filter by
        :param str creator_id: creator_id to filter by
        :param str name: name to filter by
        :param str ha_job_id: ha_job_id to filter by
        :param bool show_ray_client_runs_only: DEPRECATED: Shows only ray client runs. Orthogonaol to passing ha_job_id
        :param list[JobRunType] type_filter: Filter Jobs by their type. Their type is determined by their usage within the product e.g. Interactive sessions, job runs
        :param list[BaseJobStatus] state_filter: A list of session states to filter by
        :param str order: 'asc' for ascending, 'desc' for descending
        :param bool include_child_jobs: Whether to include child jobs
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedjobListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_decorated_jobs_api_v2_decorated_jobs_get_with_http_info(**kwargs)  # noqa: E501

    def list_decorated_jobs_api_v2_decorated_jobs_get_with_http_info(self, **kwargs):  # noqa: E501
        """List Decorated Jobs  # noqa: E501

        DEPRECATED: Use list_decorated_interactive_sessions. List all decorated jobs. Optionally filter by project and runtime_env_id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_decorated_jobs_api_v2_decorated_jobs_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: project_id to filter by
        :param str runtime_env_id: runtime_env_id to filter by
        :param str cluster_id: cluster_id to filter by
        :param str creator_id: creator_id to filter by
        :param str name: name to filter by
        :param str ha_job_id: ha_job_id to filter by
        :param bool show_ray_client_runs_only: DEPRECATED: Shows only ray client runs. Orthogonaol to passing ha_job_id
        :param list[JobRunType] type_filter: Filter Jobs by their type. Their type is determined by their usage within the product e.g. Interactive sessions, job runs
        :param list[BaseJobStatus] state_filter: A list of session states to filter by
        :param str order: 'asc' for ascending, 'desc' for descending
        :param bool include_child_jobs: Whether to include child jobs
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedjobListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project_id',
            'runtime_env_id',
            'cluster_id',
            'creator_id',
            'name',
            'ha_job_id',
            'show_ray_client_runs_only',
            'type_filter',
            'state_filter',
            'order',
            'include_child_jobs',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_decorated_jobs_api_v2_decorated_jobs_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 50:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_decorated_jobs_api_v2_decorated_jobs_get`, must be a value less than or equal to `50`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_decorated_jobs_api_v2_decorated_jobs_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'project_id' in local_var_params and local_var_params['project_id'] is not None:  # noqa: E501
            query_params.append(('project_id', local_var_params['project_id']))  # noqa: E501
        if 'runtime_env_id' in local_var_params and local_var_params['runtime_env_id'] is not None:  # noqa: E501
            query_params.append(('runtime_env_id', local_var_params['runtime_env_id']))  # noqa: E501
        if 'cluster_id' in local_var_params and local_var_params['cluster_id'] is not None:  # noqa: E501
            query_params.append(('cluster_id', local_var_params['cluster_id']))  # noqa: E501
        if 'creator_id' in local_var_params and local_var_params['creator_id'] is not None:  # noqa: E501
            query_params.append(('creator_id', local_var_params['creator_id']))  # noqa: E501
        if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
            query_params.append(('name', local_var_params['name']))  # noqa: E501
        if 'ha_job_id' in local_var_params and local_var_params['ha_job_id'] is not None:  # noqa: E501
            query_params.append(('ha_job_id', local_var_params['ha_job_id']))  # noqa: E501
        if 'show_ray_client_runs_only' in local_var_params and local_var_params['show_ray_client_runs_only'] is not None:  # noqa: E501
            query_params.append(('show_ray_client_runs_only', local_var_params['show_ray_client_runs_only']))  # noqa: E501
        if 'type_filter' in local_var_params and local_var_params['type_filter'] is not None:  # noqa: E501
            query_params.append(('type_filter', local_var_params['type_filter']))  # noqa: E501
            collection_formats['type_filter'] = 'multi'  # noqa: E501
        if 'state_filter' in local_var_params and local_var_params['state_filter'] is not None:  # noqa: E501
            query_params.append(('state_filter', local_var_params['state_filter']))  # noqa: E501
            collection_formats['state_filter'] = 'multi'  # noqa: E501
        if 'order' in local_var_params and local_var_params['order'] is not None:  # noqa: E501
            query_params.append(('order', local_var_params['order']))  # noqa: E501
        if 'include_child_jobs' in local_var_params and local_var_params['include_child_jobs'] is not None:  # noqa: E501
            query_params.append(('include_child_jobs', local_var_params['include_child_jobs']))  # noqa: E501
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/decorated_jobs/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedjobListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_decorated_runtime_envs_api_v2_decorated_runtime_envs_get(self, **kwargs):  # noqa: E501
        """List Decorated Runtime Envs  # noqa: E501

        List all decorated runtime envs   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_decorated_runtime_envs_api_v2_decorated_runtime_envs_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedruntimeenvListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_decorated_runtime_envs_api_v2_decorated_runtime_envs_get_with_http_info(**kwargs)  # noqa: E501

    def list_decorated_runtime_envs_api_v2_decorated_runtime_envs_get_with_http_info(self, **kwargs):  # noqa: E501
        """List Decorated Runtime Envs  # noqa: E501

        List all decorated runtime envs   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_decorated_runtime_envs_api_v2_decorated_runtime_envs_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedruntimeenvListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_decorated_runtime_envs_api_v2_decorated_runtime_envs_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 50:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_decorated_runtime_envs_api_v2_decorated_runtime_envs_get`, must be a value less than or equal to `50`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_decorated_runtime_envs_api_v2_decorated_runtime_envs_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/decorated_runtime_envs/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedruntimeenvListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_decorated_serve_deployments_api_v2_decorated_serve_deployments_get(self, **kwargs):  # noqa: E501
        """List Decorated Serve Deployments  # noqa: E501

        List decorated serve deployments. Filter by cluster   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_decorated_serve_deployments_api_v2_decorated_serve_deployments_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: A cluster id to filter by
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedservedeploymentListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_decorated_serve_deployments_api_v2_decorated_serve_deployments_get_with_http_info(**kwargs)  # noqa: E501

    def list_decorated_serve_deployments_api_v2_decorated_serve_deployments_get_with_http_info(self, **kwargs):  # noqa: E501
        """List Decorated Serve Deployments  # noqa: E501

        List decorated serve deployments. Filter by cluster   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_decorated_serve_deployments_api_v2_decorated_serve_deployments_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: A cluster id to filter by
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedservedeploymentListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cluster_id',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_decorated_serve_deployments_api_v2_decorated_serve_deployments_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 50:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_decorated_serve_deployments_api_v2_decorated_serve_deployments_get`, must be a value less than or equal to `50`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_decorated_serve_deployments_api_v2_decorated_serve_deployments_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cluster_id' in local_var_params and local_var_params['cluster_id'] is not None:  # noqa: E501
            query_params.append(('cluster_id', local_var_params['cluster_id']))  # noqa: E501
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/decorated_serve_deployments/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedservedeploymentListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_fine_tuning_jobs_api_v2_fine_tuning_jobs_get(self, **kwargs):  # noqa: E501
        """List Fine Tuning Jobs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_fine_tuning_jobs_api_v2_fine_tuning_jobs_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str ft_job_id_contains: id to filter by
        :param str creator_id: filter by creator id
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PlatformfinetuningjobListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_fine_tuning_jobs_api_v2_fine_tuning_jobs_get_with_http_info(**kwargs)  # noqa: E501

    def list_fine_tuning_jobs_api_v2_fine_tuning_jobs_get_with_http_info(self, **kwargs):  # noqa: E501
        """List Fine Tuning Jobs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_fine_tuning_jobs_api_v2_fine_tuning_jobs_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str ft_job_id_contains: id to filter by
        :param str creator_id: filter by creator id
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PlatformfinetuningjobListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'ft_job_id_contains',
            'creator_id',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_fine_tuning_jobs_api_v2_fine_tuning_jobs_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 50:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_fine_tuning_jobs_api_v2_fine_tuning_jobs_get`, must be a value less than or equal to `50`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_fine_tuning_jobs_api_v2_fine_tuning_jobs_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'ft_job_id_contains' in local_var_params and local_var_params['ft_job_id_contains'] is not None:  # noqa: E501
            query_params.append(('ft_job_id_contains', local_var_params['ft_job_id_contains']))  # noqa: E501
        if 'creator_id' in local_var_params and local_var_params['creator_id'] is not None:  # noqa: E501
            query_params.append(('creator_id', local_var_params['creator_id']))  # noqa: E501
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/fine_tuning/jobs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PlatformfinetuningjobListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_invitations_api_v2_organization_invitations_get(self, **kwargs):  # noqa: E501
        """List Invitations  # noqa: E501

        Fetches active, unaccepted organization invitations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_invitations_api_v2_organization_invitations_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: OrganizationinvitationListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_invitations_api_v2_organization_invitations_get_with_http_info(**kwargs)  # noqa: E501

    def list_invitations_api_v2_organization_invitations_get_with_http_info(self, **kwargs):  # noqa: E501
        """List Invitations  # noqa: E501

        Fetches active, unaccepted organization invitations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_invitations_api_v2_organization_invitations_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(OrganizationinvitationListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_invitations_api_v2_organization_invitations_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 50:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_invitations_api_v2_organization_invitations_get`, must be a value less than or equal to `50`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_invitations_api_v2_organization_invitations_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organization_invitations/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OrganizationinvitationListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_job_states_api_v2_decorated_ha_job_states_get(self, ha_job_id, **kwargs):  # noqa: E501
        """List Job States  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_job_states_api_v2_decorated_ha_job_states_get(ha_job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str ha_job_id: The production job to fetch state transitions for (required)
        :param list[JobStateLogLevelTypes] log_filter: Log level to filter state transitions by
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedproductionjobstatetransitionListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_job_states_api_v2_decorated_ha_job_states_get_with_http_info(ha_job_id, **kwargs)  # noqa: E501

    def list_job_states_api_v2_decorated_ha_job_states_get_with_http_info(self, ha_job_id, **kwargs):  # noqa: E501
        """List Job States  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_job_states_api_v2_decorated_ha_job_states_get_with_http_info(ha_job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str ha_job_id: The production job to fetch state transitions for (required)
        :param list[JobStateLogLevelTypes] log_filter: Log level to filter state transitions by
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedproductionjobstatetransitionListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'ha_job_id',
            'log_filter',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_job_states_api_v2_decorated_ha_job_states_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'ha_job_id' is set
        if self.api_client.client_side_validation and ('ha_job_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['ha_job_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `ha_job_id` when calling `list_job_states_api_v2_decorated_ha_job_states_get`")  # noqa: E501

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 1000:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_job_states_api_v2_decorated_ha_job_states_get`, must be a value less than or equal to `1000`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_job_states_api_v2_decorated_ha_job_states_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'log_filter' in local_var_params and local_var_params['log_filter'] is not None:  # noqa: E501
            query_params.append(('log_filter', local_var_params['log_filter']))  # noqa: E501
            collection_formats['log_filter'] = 'multi'  # noqa: E501
        if 'ha_job_id' in local_var_params and local_var_params['ha_job_id'] is not None:  # noqa: E501
            query_params.append(('ha_job_id', local_var_params['ha_job_id']))  # noqa: E501
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/decorated_ha_job_states/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedproductionjobstatetransitionListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_jobs_api_v2_decorated_unified_jobs_get(self, **kwargs):  # noqa: E501
        """List Jobs  # noqa: E501

        List all Jobs the user has access to.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_jobs_api_v2_decorated_unified_jobs_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str name_contains: Name that contains the provided value, to filter by. If absent, no filtering is done.
        :param list[UnifiedJobStatus] status: Statuses to filter by. If absent, no filtering is done.
        :param str creator_id: User to filter by. If absent, no filtering is done.
        :param ArchiveStatus archive_status: Archive status to filter by. If absent, archived jobs are excluded.
        :param str project_id: Project to filter by. If absent, no filtering is done.
        :param str workspace_id: Workspace to filter by. If absent, no filtering is done.
        :param str cloud_id: Search for job with cloud_id
        :param UnifiedJobSortField sort_field: If absent, jobs will be ordered by status (active first). See order declared in `UnifiedJobSortField`
        :param SortOrder sort_order: If sort_field is absent, this field is ignored.If sort_order is absent, this field defaults to descending.
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedunifiedjobListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_jobs_api_v2_decorated_unified_jobs_get_with_http_info(**kwargs)  # noqa: E501

    def list_jobs_api_v2_decorated_unified_jobs_get_with_http_info(self, **kwargs):  # noqa: E501
        """List Jobs  # noqa: E501

        List all Jobs the user has access to.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_jobs_api_v2_decorated_unified_jobs_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str name_contains: Name that contains the provided value, to filter by. If absent, no filtering is done.
        :param list[UnifiedJobStatus] status: Statuses to filter by. If absent, no filtering is done.
        :param str creator_id: User to filter by. If absent, no filtering is done.
        :param ArchiveStatus archive_status: Archive status to filter by. If absent, archived jobs are excluded.
        :param str project_id: Project to filter by. If absent, no filtering is done.
        :param str workspace_id: Workspace to filter by. If absent, no filtering is done.
        :param str cloud_id: Search for job with cloud_id
        :param UnifiedJobSortField sort_field: If absent, jobs will be ordered by status (active first). See order declared in `UnifiedJobSortField`
        :param SortOrder sort_order: If sort_field is absent, this field is ignored.If sort_order is absent, this field defaults to descending.
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedunifiedjobListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'name_contains',
            'status',
            'creator_id',
            'archive_status',
            'project_id',
            'workspace_id',
            'cloud_id',
            'sort_field',
            'sort_order',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_jobs_api_v2_decorated_unified_jobs_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 50:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_jobs_api_v2_decorated_unified_jobs_get`, must be a value less than or equal to `50`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_jobs_api_v2_decorated_unified_jobs_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name_contains' in local_var_params and local_var_params['name_contains'] is not None:  # noqa: E501
            query_params.append(('name_contains', local_var_params['name_contains']))  # noqa: E501
        if 'status' in local_var_params and local_var_params['status'] is not None:  # noqa: E501
            query_params.append(('status', local_var_params['status']))  # noqa: E501
            collection_formats['status'] = 'multi'  # noqa: E501
        if 'creator_id' in local_var_params and local_var_params['creator_id'] is not None:  # noqa: E501
            query_params.append(('creator_id', local_var_params['creator_id']))  # noqa: E501
        if 'archive_status' in local_var_params and local_var_params['archive_status'] is not None:  # noqa: E501
            query_params.append(('archive_status', local_var_params['archive_status']))  # noqa: E501
        if 'project_id' in local_var_params and local_var_params['project_id'] is not None:  # noqa: E501
            query_params.append(('project_id', local_var_params['project_id']))  # noqa: E501
        if 'workspace_id' in local_var_params and local_var_params['workspace_id'] is not None:  # noqa: E501
            query_params.append(('workspace_id', local_var_params['workspace_id']))  # noqa: E501
        if 'cloud_id' in local_var_params and local_var_params['cloud_id'] is not None:  # noqa: E501
            query_params.append(('cloud_id', local_var_params['cloud_id']))  # noqa: E501
        if 'sort_field' in local_var_params and local_var_params['sort_field'] is not None:  # noqa: E501
            query_params.append(('sort_field', local_var_params['sort_field']))  # noqa: E501
        if 'sort_order' in local_var_params and local_var_params['sort_order'] is not None:  # noqa: E501
            query_params.append(('sort_order', local_var_params['sort_order']))  # noqa: E501
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/decorated_unified_jobs/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedunifiedjobListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_machine_pools_api_v2_machine_pools_get(self, **kwargs):  # noqa: E501
        """List Machine Pools  # noqa: E501

        Lists machine pools.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_machine_pools_api_v2_machine_pools_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ListmachinepoolsresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_machine_pools_api_v2_machine_pools_get_with_http_info(**kwargs)  # noqa: E501

    def list_machine_pools_api_v2_machine_pools_get_with_http_info(self, **kwargs):  # noqa: E501
        """List Machine Pools  # noqa: E501

        Lists machine pools.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_machine_pools_api_v2_machine_pools_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ListmachinepoolsresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_machine_pools_api_v2_machine_pools_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/machine_pools/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ListmachinepoolsresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_machines_api_v2_machines_get(self, **kwargs):  # noqa: E501
        """List Machines  # noqa: E501

        List machines registered to the corresponding Anyscale Cloud.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_machines_api_v2_machines_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id:
        :param str machine_pool_name:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ListmachinesresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_machines_api_v2_machines_get_with_http_info(**kwargs)  # noqa: E501

    def list_machines_api_v2_machines_get_with_http_info(self, **kwargs):  # noqa: E501
        """List Machines  # noqa: E501

        List machines registered to the corresponding Anyscale Cloud.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_machines_api_v2_machines_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id:
        :param str machine_pool_name:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ListmachinesresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id',
            'machine_pool_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_machines_api_v2_machines_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cloud_id' in local_var_params and local_var_params['cloud_id'] is not None:  # noqa: E501
            query_params.append(('cloud_id', local_var_params['cloud_id']))  # noqa: E501
        if 'machine_pool_name' in local_var_params and local_var_params['machine_pool_name'] is not None:  # noqa: E501
            query_params.append(('machine_pool_name', local_var_params['machine_pool_name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/machines/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ListmachinesresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_models_api_v2_aica_endpoints_models_get(self, **kwargs):  # noqa: E501
        """List Models  # noqa: E501

        Lists all models  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_models_api_v2_aica_endpoints_models_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str id_contains: Search for models with a name that contains the provided value
        :param str cloud_id: Search for models under the specified cloud. Note that base models are supported under all clouds.
        :param str aviary_version: Search for models available under the specified aviary version.
        :param bool exclude_base_models: Exclude base models from the results.
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AicamodelListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_models_api_v2_aica_endpoints_models_get_with_http_info(**kwargs)  # noqa: E501

    def list_models_api_v2_aica_endpoints_models_get_with_http_info(self, **kwargs):  # noqa: E501
        """List Models  # noqa: E501

        Lists all models  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_models_api_v2_aica_endpoints_models_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str id_contains: Search for models with a name that contains the provided value
        :param str cloud_id: Search for models under the specified cloud. Note that base models are supported under all clouds.
        :param str aviary_version: Search for models available under the specified aviary version.
        :param bool exclude_base_models: Exclude base models from the results.
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AicamodelListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id_contains',
            'cloud_id',
            'aviary_version',
            'exclude_base_models',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_models_api_v2_aica_endpoints_models_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 1000:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_models_api_v2_aica_endpoints_models_get`, must be a value less than or equal to `1000`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_models_api_v2_aica_endpoints_models_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id_contains' in local_var_params and local_var_params['id_contains'] is not None:  # noqa: E501
            query_params.append(('id_contains', local_var_params['id_contains']))  # noqa: E501
        if 'cloud_id' in local_var_params and local_var_params['cloud_id'] is not None:  # noqa: E501
            query_params.append(('cloud_id', local_var_params['cloud_id']))  # noqa: E501
        if 'aviary_version' in local_var_params and local_var_params['aviary_version'] is not None:  # noqa: E501
            query_params.append(('aviary_version', local_var_params['aviary_version']))  # noqa: E501
        if 'exclude_base_models' in local_var_params and local_var_params['exclude_base_models'] is not None:  # noqa: E501
            query_params.append(('exclude_base_models', local_var_params['exclude_base_models']))  # noqa: E501
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/aica_endpoints/models', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AicamodelListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_organization_collaborators_api_v2_organization_collaborators_get(self, **kwargs):  # noqa: E501
        """List Organization Collaborators  # noqa: E501

        Retrieves collaborators belonging to the logged in user's organization  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_organization_collaborators_api_v2_organization_collaborators_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str email:
        :param bool is_service_account:
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: OrganizationcollaboratorListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_organization_collaborators_api_v2_organization_collaborators_get_with_http_info(**kwargs)  # noqa: E501

    def list_organization_collaborators_api_v2_organization_collaborators_get_with_http_info(self, **kwargs):  # noqa: E501
        """List Organization Collaborators  # noqa: E501

        Retrieves collaborators belonging to the logged in user's organization  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_organization_collaborators_api_v2_organization_collaborators_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str email:
        :param bool is_service_account:
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(OrganizationcollaboratorListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'email',
            'is_service_account',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_organization_collaborators_api_v2_organization_collaborators_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 50:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_organization_collaborators_api_v2_organization_collaborators_get`, must be a value less than or equal to `50`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_organization_collaborators_api_v2_organization_collaborators_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'email' in local_var_params and local_var_params['email'] is not None:  # noqa: E501
            query_params.append(('email', local_var_params['email']))  # noqa: E501
        if 'is_service_account' in local_var_params and local_var_params['is_service_account'] is not None:  # noqa: E501
            query_params.append(('is_service_account', local_var_params['is_service_account']))  # noqa: E501
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organization_collaborators/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OrganizationcollaboratorListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_organization_project_collaborators_api_v2_projects_project_id_collaborators_organizations_get(self, project_id, **kwargs):  # noqa: E501
        """List Organization Project Collaborators  # noqa: E501

        Get a list of all organization with permission for a given project  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_organization_project_collaborators_api_v2_projects_project_id_collaborators_organizations_get(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: (required)
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: OrganizationprojectcollaboratorListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_organization_project_collaborators_api_v2_projects_project_id_collaborators_organizations_get_with_http_info(project_id, **kwargs)  # noqa: E501

    def list_organization_project_collaborators_api_v2_projects_project_id_collaborators_organizations_get_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """List Organization Project Collaborators  # noqa: E501

        Get a list of all organization with permission for a given project  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_organization_project_collaborators_api_v2_projects_project_id_collaborators_organizations_get_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: (required)
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(OrganizationprojectcollaboratorListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project_id',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_organization_project_collaborators_api_v2_projects_project_id_collaborators_organizations_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `list_organization_project_collaborators_api_v2_projects_project_id_collaborators_organizations_get`")  # noqa: E501

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 50:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_organization_project_collaborators_api_v2_projects_project_id_collaborators_organizations_get`, must be a value less than or equal to `50`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_organization_project_collaborators_api_v2_projects_project_id_collaborators_organizations_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'project_id' in local_var_params:
            path_params['project_id'] = local_var_params['project_id']  # noqa: E501

        query_params = []
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/projects/{project_id}/collaborators/organizations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OrganizationprojectcollaboratorListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_project_collaborators_api_v2_projects_project_id_collaborators_users_get(self, project_id, **kwargs):  # noqa: E501
        """List Project Collaborators  # noqa: E501

        Get a list of all collaborators for a given project  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_project_collaborators_api_v2_projects_project_id_collaborators_users_get(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: (required)
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ProjectcollaboratorListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_project_collaborators_api_v2_projects_project_id_collaborators_users_get_with_http_info(project_id, **kwargs)  # noqa: E501

    def list_project_collaborators_api_v2_projects_project_id_collaborators_users_get_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """List Project Collaborators  # noqa: E501

        Get a list of all collaborators for a given project  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_project_collaborators_api_v2_projects_project_id_collaborators_users_get_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: (required)
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ProjectcollaboratorListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project_id',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_project_collaborators_api_v2_projects_project_id_collaborators_users_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `list_project_collaborators_api_v2_projects_project_id_collaborators_users_get`")  # noqa: E501

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 50:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_project_collaborators_api_v2_projects_project_id_collaborators_users_get`, must be a value less than or equal to `50`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_project_collaborators_api_v2_projects_project_id_collaborators_users_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'project_id' in local_var_params:
            path_params['project_id'] = local_var_params['project_id']  # noqa: E501

        query_params = []
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/projects/{project_id}/collaborators/users', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ProjectcollaboratorListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_projects_api_v2_projects_get(self, **kwargs):  # noqa: E501
        """List Projects  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_projects_api_v2_projects_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str name_contains: filter by name of project
        :param str creator_id: filter by creator id
        :param str parent_cloud_id: filter by cloud this project is associated with
        :param bool include_defaults: include default projects
        :param ProjectsSortField sort_field: If absent, the sort order will be determined according to the entity type.
        :param SortOrder sort_order: If sort_field is absent, this field is ignored.If absent, this field defaults to ascending.
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ProjectListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_projects_api_v2_projects_get_with_http_info(**kwargs)  # noqa: E501

    def list_projects_api_v2_projects_get_with_http_info(self, **kwargs):  # noqa: E501
        """List Projects  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_projects_api_v2_projects_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str name_contains: filter by name of project
        :param str creator_id: filter by creator id
        :param str parent_cloud_id: filter by cloud this project is associated with
        :param bool include_defaults: include default projects
        :param ProjectsSortField sort_field: If absent, the sort order will be determined according to the entity type.
        :param SortOrder sort_order: If sort_field is absent, this field is ignored.If absent, this field defaults to ascending.
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ProjectListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'name_contains',
            'creator_id',
            'parent_cloud_id',
            'include_defaults',
            'sort_field',
            'sort_order',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_projects_api_v2_projects_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 50:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_projects_api_v2_projects_get`, must be a value less than or equal to `50`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_projects_api_v2_projects_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name_contains' in local_var_params and local_var_params['name_contains'] is not None:  # noqa: E501
            query_params.append(('name_contains', local_var_params['name_contains']))  # noqa: E501
        if 'creator_id' in local_var_params and local_var_params['creator_id'] is not None:  # noqa: E501
            query_params.append(('creator_id', local_var_params['creator_id']))  # noqa: E501
        if 'parent_cloud_id' in local_var_params and local_var_params['parent_cloud_id'] is not None:  # noqa: E501
            query_params.append(('parent_cloud_id', local_var_params['parent_cloud_id']))  # noqa: E501
        if 'include_defaults' in local_var_params and local_var_params['include_defaults'] is not None:  # noqa: E501
            query_params.append(('include_defaults', local_var_params['include_defaults']))  # noqa: E501
        if 'sort_field' in local_var_params and local_var_params['sort_field'] is not None:  # noqa: E501
            query_params.append(('sort_field', local_var_params['sort_field']))  # noqa: E501
        if 'sort_order' in local_var_params and local_var_params['sort_order'] is not None:  # noqa: E501
            query_params.append(('sort_order', local_var_params['sort_order']))  # noqa: E501
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/projects/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ProjectListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_services_api_v2_services_v2_get(self, **kwargs):  # noqa: E501
        """List Services  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_services_api_v2_services_v2_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: project_id to filter by
        :param str name: name to filter by
        :param list[ServiceEventCurrentState] state_filter: A list of Service states to filter by
        :param str creator_id: creator_id to filter by
        :param str cloud_id: cloud_id to filter by
        :param ServiceSortField sort_field: If absent, the default sorting order is 1. status (active first).2. Last updated at (desc). 3. Name (asc).
        :param SortOrder sort_order: If sort_field is absent, this field is ignored.If absent, this field defaults to ascending.
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedlistserviceapimodelListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_services_api_v2_services_v2_get_with_http_info(**kwargs)  # noqa: E501

    def list_services_api_v2_services_v2_get_with_http_info(self, **kwargs):  # noqa: E501
        """List Services  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_services_api_v2_services_v2_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: project_id to filter by
        :param str name: name to filter by
        :param list[ServiceEventCurrentState] state_filter: A list of Service states to filter by
        :param str creator_id: creator_id to filter by
        :param str cloud_id: cloud_id to filter by
        :param ServiceSortField sort_field: If absent, the default sorting order is 1. status (active first).2. Last updated at (desc). 3. Name (asc).
        :param SortOrder sort_order: If sort_field is absent, this field is ignored.If absent, this field defaults to ascending.
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedlistserviceapimodelListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project_id',
            'name',
            'state_filter',
            'creator_id',
            'cloud_id',
            'sort_field',
            'sort_order',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_services_api_v2_services_v2_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 50:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_services_api_v2_services_v2_get`, must be a value less than or equal to `50`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_services_api_v2_services_v2_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'project_id' in local_var_params and local_var_params['project_id'] is not None:  # noqa: E501
            query_params.append(('project_id', local_var_params['project_id']))  # noqa: E501
        if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
            query_params.append(('name', local_var_params['name']))  # noqa: E501
        if 'state_filter' in local_var_params and local_var_params['state_filter'] is not None:  # noqa: E501
            query_params.append(('state_filter', local_var_params['state_filter']))  # noqa: E501
            collection_formats['state_filter'] = 'multi'  # noqa: E501
        if 'creator_id' in local_var_params and local_var_params['creator_id'] is not None:  # noqa: E501
            query_params.append(('creator_id', local_var_params['creator_id']))  # noqa: E501
        if 'cloud_id' in local_var_params and local_var_params['cloud_id'] is not None:  # noqa: E501
            query_params.append(('cloud_id', local_var_params['cloud_id']))  # noqa: E501
        if 'sort_field' in local_var_params and local_var_params['sort_field'] is not None:  # noqa: E501
            query_params.append(('sort_field', local_var_params['sort_field']))  # noqa: E501
        if 'sort_order' in local_var_params and local_var_params['sort_order'] is not None:  # noqa: E501
            query_params.append(('sort_order', local_var_params['sort_order']))  # noqa: E501
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/services-v2/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedlistserviceapimodelListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_sessions_api_v2_sessions_get(self, project_id, **kwargs):  # noqa: E501
        """List Sessions  # noqa: E501

        DEPRECATED: Use list_decorated_sessions in decorated_sessions_router instead.  List all sessions for a project  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_sessions_api_v2_sessions_get(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: (required)
        :param str name:
        :param str name_match: a wildcard match for session names. This endpoint will raise an error if both name and name_match is provided.
        :param bool active_only: DEPRECATED. Use state_filter instead.
        :param list[SessionState] state_filter:
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: SessionListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_sessions_api_v2_sessions_get_with_http_info(project_id, **kwargs)  # noqa: E501

    def list_sessions_api_v2_sessions_get_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """List Sessions  # noqa: E501

        DEPRECATED: Use list_decorated_sessions in decorated_sessions_router instead.  List all sessions for a project  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_sessions_api_v2_sessions_get_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: (required)
        :param str name:
        :param str name_match: a wildcard match for session names. This endpoint will raise an error if both name and name_match is provided.
        :param bool active_only: DEPRECATED. Use state_filter instead.
        :param list[SessionState] state_filter:
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(SessionListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project_id',
            'name',
            'name_match',
            'active_only',
            'state_filter',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_sessions_api_v2_sessions_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `list_sessions_api_v2_sessions_get`")  # noqa: E501

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 50:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_sessions_api_v2_sessions_get`, must be a value less than or equal to `50`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_sessions_api_v2_sessions_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'project_id' in local_var_params and local_var_params['project_id'] is not None:  # noqa: E501
            query_params.append(('project_id', local_var_params['project_id']))  # noqa: E501
        if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
            query_params.append(('name', local_var_params['name']))  # noqa: E501
        if 'name_match' in local_var_params and local_var_params['name_match'] is not None:  # noqa: E501
            query_params.append(('name_match', local_var_params['name_match']))  # noqa: E501
        if 'active_only' in local_var_params and local_var_params['active_only'] is not None:  # noqa: E501
            query_params.append(('active_only', local_var_params['active_only']))  # noqa: E501
        if 'state_filter' in local_var_params and local_var_params['state_filter'] is not None:  # noqa: E501
            query_params.append(('state_filter', local_var_params['state_filter']))  # noqa: E501
            collection_formats['state_filter'] = 'multi'  # noqa: E501
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/sessions/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SessionListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_versions_api_v2_aica_endpoints_versions_get(self, **kwargs):  # noqa: E501
        """List Versions  # noqa: E501

        Lists all aviary versions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_versions_api_v2_aica_endpoints_versions_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[str]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_versions_api_v2_aica_endpoints_versions_get_with_http_info(**kwargs)  # noqa: E501

    def list_versions_api_v2_aica_endpoints_versions_get_with_http_info(self, **kwargs):  # noqa: E501
        """List Versions  # noqa: E501

        Lists all aviary versions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_versions_api_v2_aica_endpoints_versions_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[str], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_versions_api_v2_aica_endpoints_versions_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/aica_endpoints/versions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[str]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_web_terminals_api_v2_sessions_session_id_web_terminals_get(self, session_id, **kwargs):  # noqa: E501
        """List Web Terminals  # noqa: E501

        DEPRECATED: This API is no deprecated and will not be supported in Anyscale 2.0  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_web_terminals_api_v2_sessions_session_id_web_terminals_get(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: WebterminalListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_web_terminals_api_v2_sessions_session_id_web_terminals_get_with_http_info(session_id, **kwargs)  # noqa: E501

    def list_web_terminals_api_v2_sessions_session_id_web_terminals_get_with_http_info(self, session_id, **kwargs):  # noqa: E501
        """List Web Terminals  # noqa: E501

        DEPRECATED: This API is no deprecated and will not be supported in Anyscale 2.0  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_web_terminals_api_v2_sessions_session_id_web_terminals_get_with_http_info(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(WebterminalListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'session_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_web_terminals_api_v2_sessions_session_id_web_terminals_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'session_id' is set
        if self.api_client.client_side_validation and ('session_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_id` when calling `list_web_terminals_api_v2_sessions_session_id_web_terminals_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'session_id' in local_var_params:
            path_params['session_id'] = local_var_params['session_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/sessions/{session_id}/web_terminals', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='WebterminalListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_workspace_templates_api_v2_experimental_workspaces_templates_get(self, **kwargs):  # noqa: E501
        """List Workspace Templates  # noqa: E501

        Lists all workspace templates  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_workspace_templates_api_v2_experimental_workspaces_templates_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param bool for_private_endpoints_homepage: Filters the list to be ones expected for private endpoints home page
        :param bool for_fine_tuning: Filters the list to be ones expected for fine tuning tutorial section
        :param bool for_ai_apps_section: Filters the list to show the ones expected for ai apps section
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: WorkspacetemplateListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_workspace_templates_api_v2_experimental_workspaces_templates_get_with_http_info(**kwargs)  # noqa: E501

    def list_workspace_templates_api_v2_experimental_workspaces_templates_get_with_http_info(self, **kwargs):  # noqa: E501
        """List Workspace Templates  # noqa: E501

        Lists all workspace templates  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_workspace_templates_api_v2_experimental_workspaces_templates_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param bool for_private_endpoints_homepage: Filters the list to be ones expected for private endpoints home page
        :param bool for_fine_tuning: Filters the list to be ones expected for fine tuning tutorial section
        :param bool for_ai_apps_section: Filters the list to show the ones expected for ai apps section
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(WorkspacetemplateListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'for_private_endpoints_homepage',
            'for_fine_tuning',
            'for_ai_apps_section'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_workspace_templates_api_v2_experimental_workspaces_templates_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'for_private_endpoints_homepage' in local_var_params and local_var_params['for_private_endpoints_homepage'] is not None:  # noqa: E501
            query_params.append(('for_private_endpoints_homepage', local_var_params['for_private_endpoints_homepage']))  # noqa: E501
        if 'for_fine_tuning' in local_var_params and local_var_params['for_fine_tuning'] is not None:  # noqa: E501
            query_params.append(('for_fine_tuning', local_var_params['for_fine_tuning']))  # noqa: E501
        if 'for_ai_apps_section' in local_var_params and local_var_params['for_ai_apps_section'] is not None:  # noqa: E501
            query_params.append(('for_ai_apps_section', local_var_params['for_ai_apps_section']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/experimental_workspaces/templates', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='WorkspacetemplateListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_workspaces_api_v2_experimental_workspaces_get(self, **kwargs):  # noqa: E501
        """List Workspaces  # noqa: E501

        Lists all Workspace the user has access to  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_workspaces_api_v2_experimental_workspaces_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str name: Search for workspace with a name that equals the provided value
        :param str name_contains: Search for workspace with a name that contains the provided value
        :param str creator_id: List workspaces created by a given user
        :param str project_id: Search for workspace with project_id
        :param str cloud_id: Search for workspace with cloud_id
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ExperimentalworkspaceListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_workspaces_api_v2_experimental_workspaces_get_with_http_info(**kwargs)  # noqa: E501

    def list_workspaces_api_v2_experimental_workspaces_get_with_http_info(self, **kwargs):  # noqa: E501
        """List Workspaces  # noqa: E501

        Lists all Workspace the user has access to  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_workspaces_api_v2_experimental_workspaces_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str name: Search for workspace with a name that equals the provided value
        :param str name_contains: Search for workspace with a name that contains the provided value
        :param str creator_id: List workspaces created by a given user
        :param str project_id: Search for workspace with project_id
        :param str cloud_id: Search for workspace with cloud_id
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ExperimentalworkspaceListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'name',
            'name_contains',
            'creator_id',
            'project_id',
            'cloud_id',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_workspaces_api_v2_experimental_workspaces_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 50:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_workspaces_api_v2_experimental_workspaces_get`, must be a value less than or equal to `50`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `list_workspaces_api_v2_experimental_workspaces_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
            query_params.append(('name', local_var_params['name']))  # noqa: E501
        if 'name_contains' in local_var_params and local_var_params['name_contains'] is not None:  # noqa: E501
            query_params.append(('name_contains', local_var_params['name_contains']))  # noqa: E501
        if 'creator_id' in local_var_params and local_var_params['creator_id'] is not None:  # noqa: E501
            query_params.append(('creator_id', local_var_params['creator_id']))  # noqa: E501
        if 'project_id' in local_var_params and local_var_params['project_id'] is not None:  # noqa: E501
            query_params.append(('project_id', local_var_params['project_id']))  # noqa: E501
        if 'cloud_id' in local_var_params and local_var_params['cloud_id'] is not None:  # noqa: E501
            query_params.append(('cloud_id', local_var_params['cloud_id']))  # noqa: E501
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/experimental_workspaces/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ExperimentalworkspaceListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def login_user_api_v2_users_login_post(self, login_user_params, **kwargs):  # noqa: E501
        """Login User  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.login_user_api_v2_users_login_post(login_user_params, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param LoginUserParams login_user_params: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.login_user_api_v2_users_login_post_with_http_info(login_user_params, **kwargs)  # noqa: E501

    def login_user_api_v2_users_login_post_with_http_info(self, login_user_params, **kwargs):  # noqa: E501
        """Login User  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.login_user_api_v2_users_login_post_with_http_info(login_user_params, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param LoginUserParams login_user_params: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'login_user_params'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method login_user_api_v2_users_login_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'login_user_params' is set
        if self.api_client.client_side_validation and ('login_user_params' not in local_var_params or  # noqa: E501
                                                        local_var_params['login_user_params'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `login_user_params` when calling `login_user_api_v2_users_login_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'login_user_params' in local_var_params:
            body_params = local_var_params['login_user_params']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/users/login', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def logout_user_api_v2_users_logout_post(self, **kwargs):  # noqa: E501
        """Logout User  # noqa: E501

        Log a user out.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.logout_user_api_v2_users_logout_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.logout_user_api_v2_users_logout_post_with_http_info(**kwargs)  # noqa: E501

    def logout_user_api_v2_users_logout_post_with_http_info(self, **kwargs):  # noqa: E501
        """Logout User  # noqa: E501

        Log a user out.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.logout_user_api_v2_users_logout_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method logout_user_api_v2_users_logout_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/users/logout', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def model_s3_mirror_credentials_api_v2_aica_endpoints_model_s3_credentials_post(self, model_id, **kwargs):  # noqa: E501
        """Model S3 Mirror Credentials  # noqa: E501

        create s3 credential for model weights  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.model_s3_mirror_credentials_api_v2_aica_endpoints_model_s3_credentials_post(model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str model_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AWSCredentials
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.model_s3_mirror_credentials_api_v2_aica_endpoints_model_s3_credentials_post_with_http_info(model_id, **kwargs)  # noqa: E501

    def model_s3_mirror_credentials_api_v2_aica_endpoints_model_s3_credentials_post_with_http_info(self, model_id, **kwargs):  # noqa: E501
        """Model S3 Mirror Credentials  # noqa: E501

        create s3 credential for model weights  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.model_s3_mirror_credentials_api_v2_aica_endpoints_model_s3_credentials_post_with_http_info(model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str model_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AWSCredentials, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'model_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method model_s3_mirror_credentials_api_v2_aica_endpoints_model_s3_credentials_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'model_id' is set
        if self.api_client.client_side_validation and ('model_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['model_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `model_id` when calling `model_s3_mirror_credentials_api_v2_aica_endpoints_model_s3_credentials_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'model_id' in local_var_params and local_var_params['model_id'] is not None:  # noqa: E501
            query_params.append(('model_id', local_var_params['model_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/aica_endpoints/model_s3_credentials', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AWSCredentials',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def organization_valid_for_migration_api_v2_access_controls_migration_organization_id_organization_valid_for_migration_get(self, organization_id, **kwargs):  # noqa: E501
        """Organization Valid For Migration  # noqa: E501

        Check if organization is valid for migration by ensuring there is at least one non deleted cloud if there are any non deleted projects. This API is only available to Anyscale internal employees.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.organization_valid_for_migration_api_v2_access_controls_migration_organization_id_organization_valid_for_migration_get(organization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str organization_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: VerifyresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.organization_valid_for_migration_api_v2_access_controls_migration_organization_id_organization_valid_for_migration_get_with_http_info(organization_id, **kwargs)  # noqa: E501

    def organization_valid_for_migration_api_v2_access_controls_migration_organization_id_organization_valid_for_migration_get_with_http_info(self, organization_id, **kwargs):  # noqa: E501
        """Organization Valid For Migration  # noqa: E501

        Check if organization is valid for migration by ensuring there is at least one non deleted cloud if there are any non deleted projects. This API is only available to Anyscale internal employees.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.organization_valid_for_migration_api_v2_access_controls_migration_organization_id_organization_valid_for_migration_get_with_http_info(organization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str organization_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(VerifyresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'organization_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method organization_valid_for_migration_api_v2_access_controls_migration_organization_id_organization_valid_for_migration_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_id' is set
        if self.api_client.client_side_validation and ('organization_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['organization_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_id` when calling `organization_valid_for_migration_api_v2_access_controls_migration_organization_id_organization_valid_for_migration_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_id' in local_var_params:
            path_params['organization_id'] = local_var_params['organization_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/access_controls_migration/{organization_id}/organization_valid_for_migration', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VerifyresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_project_api_v2_projects_project_id_patch(self, project_id, json_patch_operation, **kwargs):  # noqa: E501
        """Patch Project  # noqa: E501

        Updates a Project.  Only the description field can be modified.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_project_api_v2_projects_project_id_patch(project_id, json_patch_operation, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: (required)
        :param list[JsonPatchOperation] json_patch_operation: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.patch_project_api_v2_projects_project_id_patch_with_http_info(project_id, json_patch_operation, **kwargs)  # noqa: E501

    def patch_project_api_v2_projects_project_id_patch_with_http_info(self, project_id, json_patch_operation, **kwargs):  # noqa: E501
        """Patch Project  # noqa: E501

        Updates a Project.  Only the description field can be modified.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_project_api_v2_projects_project_id_patch_with_http_info(project_id, json_patch_operation, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str project_id: (required)
        :param list[JsonPatchOperation] json_patch_operation: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'project_id',
            'json_patch_operation'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_project_api_v2_projects_project_id_patch" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `patch_project_api_v2_projects_project_id_patch`")  # noqa: E501
        # verify the required parameter 'json_patch_operation' is set
        if self.api_client.client_side_validation and ('json_patch_operation' not in local_var_params or  # noqa: E501
                                                        local_var_params['json_patch_operation'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `json_patch_operation` when calling `patch_project_api_v2_projects_project_id_patch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in local_var_params:
            path_params['project_id'] = local_var_params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'json_patch_operation' in local_var_params:
            body_params = local_var_params['json_patch_operation']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/projects/{project_id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_session_api_v2_sessions_session_id_patch(self, session_id, json_patch_operation, **kwargs):  # noqa: E501
        """Patch Session  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_session_api_v2_sessions_session_id_patch(session_id, json_patch_operation, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param list[JsonPatchOperation] json_patch_operation: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.patch_session_api_v2_sessions_session_id_patch_with_http_info(session_id, json_patch_operation, **kwargs)  # noqa: E501

    def patch_session_api_v2_sessions_session_id_patch_with_http_info(self, session_id, json_patch_operation, **kwargs):  # noqa: E501
        """Patch Session  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_session_api_v2_sessions_session_id_patch_with_http_info(session_id, json_patch_operation, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param list[JsonPatchOperation] json_patch_operation: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'session_id',
            'json_patch_operation'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_session_api_v2_sessions_session_id_patch" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'session_id' is set
        if self.api_client.client_side_validation and ('session_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_id` when calling `patch_session_api_v2_sessions_session_id_patch`")  # noqa: E501
        # verify the required parameter 'json_patch_operation' is set
        if self.api_client.client_side_validation and ('json_patch_operation' not in local_var_params or  # noqa: E501
                                                        local_var_params['json_patch_operation'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `json_patch_operation` when calling `patch_session_api_v2_sessions_session_id_patch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'session_id' in local_var_params:
            path_params['session_id'] = local_var_params['session_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'json_patch_operation' in local_var_params:
            body_params = local_var_params['json_patch_operation']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/sessions/{session_id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_workspace_api_v2_experimental_workspaces_workspace_id_patch(self, workspace_id, json_patch_operation, **kwargs):  # noqa: E501
        """Patch Workspace  # noqa: E501

        Updates a workspace.  TODO: We may need to update fields of the underlying cluster as well in case the fields are duplicated between workspaces and clusters.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_workspace_api_v2_experimental_workspaces_workspace_id_patch(workspace_id, json_patch_operation, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str workspace_id: (required)
        :param list[JsonPatchOperation] json_patch_operation: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.patch_workspace_api_v2_experimental_workspaces_workspace_id_patch_with_http_info(workspace_id, json_patch_operation, **kwargs)  # noqa: E501

    def patch_workspace_api_v2_experimental_workspaces_workspace_id_patch_with_http_info(self, workspace_id, json_patch_operation, **kwargs):  # noqa: E501
        """Patch Workspace  # noqa: E501

        Updates a workspace.  TODO: We may need to update fields of the underlying cluster as well in case the fields are duplicated between workspaces and clusters.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_workspace_api_v2_experimental_workspaces_workspace_id_patch_with_http_info(workspace_id, json_patch_operation, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str workspace_id: (required)
        :param list[JsonPatchOperation] json_patch_operation: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'workspace_id',
            'json_patch_operation'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_workspace_api_v2_experimental_workspaces_workspace_id_patch" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'workspace_id' is set
        if self.api_client.client_side_validation and ('workspace_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_id` when calling `patch_workspace_api_v2_experimental_workspaces_workspace_id_patch`")  # noqa: E501
        # verify the required parameter 'json_patch_operation' is set
        if self.api_client.client_side_validation and ('json_patch_operation' not in local_var_params or  # noqa: E501
                                                        local_var_params['json_patch_operation'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `json_patch_operation` when calling `patch_workspace_api_v2_experimental_workspaces_workspace_id_patch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'workspace_id' in local_var_params:
            path_params['workspace_id'] = local_var_params['workspace_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'json_patch_operation' in local_var_params:
            body_params = local_var_params['json_patch_operation']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/experimental_workspaces/{workspace_id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pause_cron_job_api_v2_experimental_cron_jobs_cron_job_id_pause_post(self, cron_job_id, pause_schedule, **kwargs):  # noqa: E501
        """Pause Cron Job  # noqa: E501

        Pause a Cron Job  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pause_cron_job_api_v2_experimental_cron_jobs_cron_job_id_pause_post(cron_job_id, pause_schedule, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cron_job_id: (required)
        :param PauseSchedule pause_schedule: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedscheduleResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.pause_cron_job_api_v2_experimental_cron_jobs_cron_job_id_pause_post_with_http_info(cron_job_id, pause_schedule, **kwargs)  # noqa: E501

    def pause_cron_job_api_v2_experimental_cron_jobs_cron_job_id_pause_post_with_http_info(self, cron_job_id, pause_schedule, **kwargs):  # noqa: E501
        """Pause Cron Job  # noqa: E501

        Pause a Cron Job  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pause_cron_job_api_v2_experimental_cron_jobs_cron_job_id_pause_post_with_http_info(cron_job_id, pause_schedule, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cron_job_id: (required)
        :param PauseSchedule pause_schedule: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedscheduleResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cron_job_id',
            'pause_schedule'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pause_cron_job_api_v2_experimental_cron_jobs_cron_job_id_pause_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cron_job_id' is set
        if self.api_client.client_side_validation and ('cron_job_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cron_job_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cron_job_id` when calling `pause_cron_job_api_v2_experimental_cron_jobs_cron_job_id_pause_post`")  # noqa: E501
        # verify the required parameter 'pause_schedule' is set
        if self.api_client.client_side_validation and ('pause_schedule' not in local_var_params or  # noqa: E501
                                                        local_var_params['pause_schedule'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `pause_schedule` when calling `pause_cron_job_api_v2_experimental_cron_jobs_cron_job_id_pause_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cron_job_id' in local_var_params:
            path_params['cron_job_id'] = local_var_params['cron_job_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pause_schedule' in local_var_params:
            body_params = local_var_params['pause_schedule']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/experimental_cron_jobs/{cron_job_id}/pause', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedscheduleResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def produce_analytics_event_api_v2_analytics_post(self, create_analytics_event, **kwargs):  # noqa: E501
        """Produce Analytics Event  # noqa: E501

        Logs CLI events for analysis.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.produce_analytics_event_api_v2_analytics_post(create_analytics_event, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateAnalyticsEvent create_analytics_event: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.produce_analytics_event_api_v2_analytics_post_with_http_info(create_analytics_event, **kwargs)  # noqa: E501

    def produce_analytics_event_api_v2_analytics_post_with_http_info(self, create_analytics_event, **kwargs):  # noqa: E501
        """Produce Analytics Event  # noqa: E501

        Logs CLI events for analysis.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.produce_analytics_event_api_v2_analytics_post_with_http_info(create_analytics_event, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateAnalyticsEvent create_analytics_event: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'create_analytics_event'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method produce_analytics_event_api_v2_analytics_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'create_analytics_event' is set
        if self.api_client.client_side_validation and ('create_analytics_event' not in local_var_params or  # noqa: E501
                                                        local_var_params['create_analytics_event'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `create_analytics_event` when calling `produce_analytics_event_api_v2_analytics_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_analytics_event' in local_var_params:
            body_params = local_var_params['create_analytics_event']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/analytics/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def projects_violating_tree_hierarchy_api_v2_access_controls_migration_organization_id_projects_violating_tree_hierarchy_get(self, organization_id, **kwargs):  # noqa: E501
        """Projects Violating Tree Hierarchy  # noqa: E501

        Check projects violating tree hierarchy before migration. These projects will be split as part of the migration. This API is only available to Anyscale internal employees.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_violating_tree_hierarchy_api_v2_access_controls_migration_organization_id_projects_violating_tree_hierarchy_get(organization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str organization_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ProjectsviolatingtreehierarchyresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.projects_violating_tree_hierarchy_api_v2_access_controls_migration_organization_id_projects_violating_tree_hierarchy_get_with_http_info(organization_id, **kwargs)  # noqa: E501

    def projects_violating_tree_hierarchy_api_v2_access_controls_migration_organization_id_projects_violating_tree_hierarchy_get_with_http_info(self, organization_id, **kwargs):  # noqa: E501
        """Projects Violating Tree Hierarchy  # noqa: E501

        Check projects violating tree hierarchy before migration. These projects will be split as part of the migration. This API is only available to Anyscale internal employees.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_violating_tree_hierarchy_api_v2_access_controls_migration_organization_id_projects_violating_tree_hierarchy_get_with_http_info(organization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str organization_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ProjectsviolatingtreehierarchyresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'organization_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_violating_tree_hierarchy_api_v2_access_controls_migration_organization_id_projects_violating_tree_hierarchy_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_id' is set
        if self.api_client.client_side_validation and ('organization_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['organization_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_id` when calling `projects_violating_tree_hierarchy_api_v2_access_controls_migration_organization_id_projects_violating_tree_hierarchy_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_id' in local_var_params:
            path_params['organization_id'] = local_var_params['organization_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/access_controls_migration/{organization_id}/projects_violating_tree_hierarchy', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ProjectsviolatingtreehierarchyresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def publish_api_v2_streams_publish_post(self, stream_publish_request, **kwargs):  # noqa: E501
        """Publish  # noqa: E501

        This is an internal API used by components that are not exposed to the streaming backend to publish events to a stream. In reality, this is a lightweight Kafka REST Proxy.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.publish_api_v2_streams_publish_post(stream_publish_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param StreamPublishRequest stream_publish_request: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.publish_api_v2_streams_publish_post_with_http_info(stream_publish_request, **kwargs)  # noqa: E501

    def publish_api_v2_streams_publish_post_with_http_info(self, stream_publish_request, **kwargs):  # noqa: E501
        """Publish  # noqa: E501

        This is an internal API used by components that are not exposed to the streaming backend to publish events to a stream. In reality, this is a lightweight Kafka REST Proxy.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.publish_api_v2_streams_publish_post_with_http_info(stream_publish_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param StreamPublishRequest stream_publish_request: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'stream_publish_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method publish_api_v2_streams_publish_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'stream_publish_request' is set
        if self.api_client.client_side_validation and ('stream_publish_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['stream_publish_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `stream_publish_request` when calling `publish_api_v2_streams_publish_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'stream_publish_request' in local_var_params:
            body_params = local_var_params['stream_publish_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/streams/publish', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_job_wandb_run_details_api_v2_integrations_job_wandb_run_details_job_id_put(self, job_id, wand_b_run_details, **kwargs):  # noqa: E501
        """Put Job Wandb Run Details  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_job_wandb_run_details_api_v2_integrations_job_wandb_run_details_job_id_put(job_id, wand_b_run_details, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str job_id: (required)
        :param WandBRunDetails wand_b_run_details: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_job_wandb_run_details_api_v2_integrations_job_wandb_run_details_job_id_put_with_http_info(job_id, wand_b_run_details, **kwargs)  # noqa: E501

    def put_job_wandb_run_details_api_v2_integrations_job_wandb_run_details_job_id_put_with_http_info(self, job_id, wand_b_run_details, **kwargs):  # noqa: E501
        """Put Job Wandb Run Details  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_job_wandb_run_details_api_v2_integrations_job_wandb_run_details_job_id_put_with_http_info(job_id, wand_b_run_details, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str job_id: (required)
        :param WandBRunDetails wand_b_run_details: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'job_id',
            'wand_b_run_details'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_job_wandb_run_details_api_v2_integrations_job_wandb_run_details_job_id_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'job_id' is set
        if self.api_client.client_side_validation and ('job_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['job_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `job_id` when calling `put_job_wandb_run_details_api_v2_integrations_job_wandb_run_details_job_id_put`")  # noqa: E501
        # verify the required parameter 'wand_b_run_details' is set
        if self.api_client.client_side_validation and ('wand_b_run_details' not in local_var_params or  # noqa: E501
                                                        local_var_params['wand_b_run_details'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `wand_b_run_details` when calling `put_job_wandb_run_details_api_v2_integrations_job_wandb_run_details_job_id_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'job_id' in local_var_params:
            path_params['job_id'] = local_var_params['job_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'wand_b_run_details' in local_var_params:
            body_params = local_var_params['wand_b_run_details']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/integrations/job_wandb_run_details/{job_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_production_job_wandb_run_details_api_v2_integrations_production_job_wandb_run_details_production_job_id_put(self, production_job_id, wand_b_run_details, **kwargs):  # noqa: E501
        """Put Production Job Wandb Run Details  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_production_job_wandb_run_details_api_v2_integrations_production_job_wandb_run_details_production_job_id_put(production_job_id, wand_b_run_details, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str production_job_id: (required)
        :param WandBRunDetails wand_b_run_details: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_production_job_wandb_run_details_api_v2_integrations_production_job_wandb_run_details_production_job_id_put_with_http_info(production_job_id, wand_b_run_details, **kwargs)  # noqa: E501

    def put_production_job_wandb_run_details_api_v2_integrations_production_job_wandb_run_details_production_job_id_put_with_http_info(self, production_job_id, wand_b_run_details, **kwargs):  # noqa: E501
        """Put Production Job Wandb Run Details  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_production_job_wandb_run_details_api_v2_integrations_production_job_wandb_run_details_production_job_id_put_with_http_info(production_job_id, wand_b_run_details, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str production_job_id: (required)
        :param WandBRunDetails wand_b_run_details: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'production_job_id',
            'wand_b_run_details'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_production_job_wandb_run_details_api_v2_integrations_production_job_wandb_run_details_production_job_id_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'production_job_id' is set
        if self.api_client.client_side_validation and ('production_job_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['production_job_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `production_job_id` when calling `put_production_job_wandb_run_details_api_v2_integrations_production_job_wandb_run_details_production_job_id_put`")  # noqa: E501
        # verify the required parameter 'wand_b_run_details' is set
        if self.api_client.client_side_validation and ('wand_b_run_details' not in local_var_params or  # noqa: E501
                                                        local_var_params['wand_b_run_details'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `wand_b_run_details` when calling `put_production_job_wandb_run_details_api_v2_integrations_production_job_wandb_run_details_production_job_id_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'production_job_id' in local_var_params:
            path_params['production_job_id'] = local_var_params['production_job_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'wand_b_run_details' in local_var_params:
            body_params = local_var_params['wand_b_run_details']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/integrations/production_job_wandb_run_details/{production_job_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_session_cluster_config_with_session_idle_timeout_api_v2_sessions_session_id_cluster_config_with_session_idle_timeout_put(self, session_id, **kwargs):  # noqa: E501
        """Put Session Cluster Config With Session Idle Timeout  # noqa: E501

        Updates the cluster config and session idle timeout of a running session.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_session_cluster_config_with_session_idle_timeout_api_v2_sessions_session_id_cluster_config_with_session_idle_timeout_put(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param str build_id:
        :param str compute_template_id:
        :param int idle_timeout:
        :param bool allow_public_internet_traffic:
        :param WriteClusterConfig write_cluster_config:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_session_cluster_config_with_session_idle_timeout_api_v2_sessions_session_id_cluster_config_with_session_idle_timeout_put_with_http_info(session_id, **kwargs)  # noqa: E501

    def put_session_cluster_config_with_session_idle_timeout_api_v2_sessions_session_id_cluster_config_with_session_idle_timeout_put_with_http_info(self, session_id, **kwargs):  # noqa: E501
        """Put Session Cluster Config With Session Idle Timeout  # noqa: E501

        Updates the cluster config and session idle timeout of a running session.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_session_cluster_config_with_session_idle_timeout_api_v2_sessions_session_id_cluster_config_with_session_idle_timeout_put_with_http_info(session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param str build_id:
        :param str compute_template_id:
        :param int idle_timeout:
        :param bool allow_public_internet_traffic:
        :param WriteClusterConfig write_cluster_config:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'session_id',
            'build_id',
            'compute_template_id',
            'idle_timeout',
            'allow_public_internet_traffic',
            'write_cluster_config'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_session_cluster_config_with_session_idle_timeout_api_v2_sessions_session_id_cluster_config_with_session_idle_timeout_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'session_id' is set
        if self.api_client.client_side_validation and ('session_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_id` when calling `put_session_cluster_config_with_session_idle_timeout_api_v2_sessions_session_id_cluster_config_with_session_idle_timeout_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'session_id' in local_var_params:
            path_params['session_id'] = local_var_params['session_id']  # noqa: E501

        query_params = []
        if 'build_id' in local_var_params and local_var_params['build_id'] is not None:  # noqa: E501
            query_params.append(('build_id', local_var_params['build_id']))  # noqa: E501
        if 'compute_template_id' in local_var_params and local_var_params['compute_template_id'] is not None:  # noqa: E501
            query_params.append(('compute_template_id', local_var_params['compute_template_id']))  # noqa: E501
        if 'idle_timeout' in local_var_params and local_var_params['idle_timeout'] is not None:  # noqa: E501
            query_params.append(('idle_timeout', local_var_params['idle_timeout']))  # noqa: E501
        if 'allow_public_internet_traffic' in local_var_params and local_var_params['allow_public_internet_traffic'] is not None:  # noqa: E501
            query_params.append(('allow_public_internet_traffic', local_var_params['allow_public_internet_traffic']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'write_cluster_config' in local_var_params:
            body_params = local_var_params['write_cluster_config']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/sessions/{session_id}/cluster_config_with_session_idle_timeout', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_workspace_proxied_dataplane_artifacts_api_v2_experimental_workspaces_workspace_id_proxied_dataplane_artifacts_put(self, workspace_id, workspace_dataplane_proxied_artifacts, **kwargs):  # noqa: E501
        """Put Workspace Proxied Dataplane Artifacts  # noqa: E501

        Update workspace dataplane artifacts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_workspace_proxied_dataplane_artifacts_api_v2_experimental_workspaces_workspace_id_proxied_dataplane_artifacts_put(workspace_id, workspace_dataplane_proxied_artifacts, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str workspace_id: ID of the Workspace to update. (required)
        :param WorkspaceDataplaneProxiedArtifacts workspace_dataplane_proxied_artifacts: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_workspace_proxied_dataplane_artifacts_api_v2_experimental_workspaces_workspace_id_proxied_dataplane_artifacts_put_with_http_info(workspace_id, workspace_dataplane_proxied_artifacts, **kwargs)  # noqa: E501

    def put_workspace_proxied_dataplane_artifacts_api_v2_experimental_workspaces_workspace_id_proxied_dataplane_artifacts_put_with_http_info(self, workspace_id, workspace_dataplane_proxied_artifacts, **kwargs):  # noqa: E501
        """Put Workspace Proxied Dataplane Artifacts  # noqa: E501

        Update workspace dataplane artifacts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_workspace_proxied_dataplane_artifacts_api_v2_experimental_workspaces_workspace_id_proxied_dataplane_artifacts_put_with_http_info(workspace_id, workspace_dataplane_proxied_artifacts, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str workspace_id: ID of the Workspace to update. (required)
        :param WorkspaceDataplaneProxiedArtifacts workspace_dataplane_proxied_artifacts: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'workspace_id',
            'workspace_dataplane_proxied_artifacts'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_workspace_proxied_dataplane_artifacts_api_v2_experimental_workspaces_workspace_id_proxied_dataplane_artifacts_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'workspace_id' is set
        if self.api_client.client_side_validation and ('workspace_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_id` when calling `put_workspace_proxied_dataplane_artifacts_api_v2_experimental_workspaces_workspace_id_proxied_dataplane_artifacts_put`")  # noqa: E501
        # verify the required parameter 'workspace_dataplane_proxied_artifacts' is set
        if self.api_client.client_side_validation and ('workspace_dataplane_proxied_artifacts' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_dataplane_proxied_artifacts'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_dataplane_proxied_artifacts` when calling `put_workspace_proxied_dataplane_artifacts_api_v2_experimental_workspaces_workspace_id_proxied_dataplane_artifacts_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'workspace_id' in local_var_params:
            path_params['workspace_id'] = local_var_params['workspace_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'workspace_dataplane_proxied_artifacts' in local_var_params:
            body_params = local_var_params['workspace_dataplane_proxied_artifacts']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/experimental_workspaces/{workspace_id}/proxied_dataplane_artifacts', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_workspace_wandb_run_details_api_v2_integrations_workspace_wandb_run_details_workspace_id_put(self, workspace_id, wand_b_run_details, **kwargs):  # noqa: E501
        """Put Workspace Wandb Run Details  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_workspace_wandb_run_details_api_v2_integrations_workspace_wandb_run_details_workspace_id_put(workspace_id, wand_b_run_details, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str workspace_id: (required)
        :param WandBRunDetails wand_b_run_details: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_workspace_wandb_run_details_api_v2_integrations_workspace_wandb_run_details_workspace_id_put_with_http_info(workspace_id, wand_b_run_details, **kwargs)  # noqa: E501

    def put_workspace_wandb_run_details_api_v2_integrations_workspace_wandb_run_details_workspace_id_put_with_http_info(self, workspace_id, wand_b_run_details, **kwargs):  # noqa: E501
        """Put Workspace Wandb Run Details  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_workspace_wandb_run_details_api_v2_integrations_workspace_wandb_run_details_workspace_id_put_with_http_info(workspace_id, wand_b_run_details, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str workspace_id: (required)
        :param WandBRunDetails wand_b_run_details: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'workspace_id',
            'wand_b_run_details'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_workspace_wandb_run_details_api_v2_integrations_workspace_wandb_run_details_workspace_id_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'workspace_id' is set
        if self.api_client.client_side_validation and ('workspace_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['workspace_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_id` when calling `put_workspace_wandb_run_details_api_v2_integrations_workspace_wandb_run_details_workspace_id_put`")  # noqa: E501
        # verify the required parameter 'wand_b_run_details' is set
        if self.api_client.client_side_validation and ('wand_b_run_details' not in local_var_params or  # noqa: E501
                                                        local_var_params['wand_b_run_details'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `wand_b_run_details` when calling `put_workspace_wandb_run_details_api_v2_integrations_workspace_wandb_run_details_workspace_id_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'workspace_id' in local_var_params:
            path_params['workspace_id'] = local_var_params['workspace_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'wand_b_run_details' in local_var_params:
            body_params = local_var_params['wand_b_run_details']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/integrations/workspace_wandb_run_details/{workspace_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def query_aggregated_logs_api_v2_logs_query_aggregated_logs_get(self, **kwargs):  # noqa: E501
        """Query Aggregated Logs  # noqa: E501

        Fetching logs for customer aggregated logs.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.query_aggregated_logs_api_v2_logs_query_aggregated_logs_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: The cluster id used to fetch logs. Exactly one of cluster_id, workspace_id, ha_job_id, or service_id must be set.
        :param str workspace_id: The workspace id used to fetch logs. Exactly one of cluster_id, workspace_id, ha_job_id, or service_id must be set.
        :param str ha_job_id: The production job id used to fetch logs. Exactly one of cluster_id, workspace_id, ha_job_id, or service_id must be set.
        :param str service_id: The service id used to fetch logs. Exactly one of cluster_id, workspace_id, ha_job_id, ray_job_submission_id, ray_job_id, or service_id must be set.
        :param int page_size: Number of chunks to fetch. Defaults to 400. Max of 1000.
        :param int start_time: The start time for the query as a nanosecond Unix epoch. If not set, the query will use the time one hour ago.
        :param int end_time: The end time for the query as a nanosecond Unix epoch. If not set, the query will use the time now.
        :param str positive_search_filter: Positive search terms to filter in the logs. Defaults to no filter. This can be a regex and the search is case insensitive.
        :param str negative_search_filter: Negative search terms to filter out the logs. Defaults to no filter. This can be a regex and the search is case insensitive.
        :param str source: The source file (worker, raylet, dashboard, controller, proxy, replica, AUTOSCALER..) to filter the logs. Default to no filter.
        :param str filter_tags: The tags to filter the logs. Default to no filter. The format of this field is expected to be in json. The filer will apply to match each key of the object and do exact match on the value.
        :param bool reverse_sort: Whether the result should be sorted by descending timestamp. Also determines the query direction. When false, it will start to query from the start_time and return results until it reaches the page_size or the end_time. When true, it will start to query from the end_time and return results until it reaches the page_size or the start_time. Default to false.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: LogitembatchResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.query_aggregated_logs_api_v2_logs_query_aggregated_logs_get_with_http_info(**kwargs)  # noqa: E501

    def query_aggregated_logs_api_v2_logs_query_aggregated_logs_get_with_http_info(self, **kwargs):  # noqa: E501
        """Query Aggregated Logs  # noqa: E501

        Fetching logs for customer aggregated logs.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.query_aggregated_logs_api_v2_logs_query_aggregated_logs_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: The cluster id used to fetch logs. Exactly one of cluster_id, workspace_id, ha_job_id, or service_id must be set.
        :param str workspace_id: The workspace id used to fetch logs. Exactly one of cluster_id, workspace_id, ha_job_id, or service_id must be set.
        :param str ha_job_id: The production job id used to fetch logs. Exactly one of cluster_id, workspace_id, ha_job_id, or service_id must be set.
        :param str service_id: The service id used to fetch logs. Exactly one of cluster_id, workspace_id, ha_job_id, ray_job_submission_id, ray_job_id, or service_id must be set.
        :param int page_size: Number of chunks to fetch. Defaults to 400. Max of 1000.
        :param int start_time: The start time for the query as a nanosecond Unix epoch. If not set, the query will use the time one hour ago.
        :param int end_time: The end time for the query as a nanosecond Unix epoch. If not set, the query will use the time now.
        :param str positive_search_filter: Positive search terms to filter in the logs. Defaults to no filter. This can be a regex and the search is case insensitive.
        :param str negative_search_filter: Negative search terms to filter out the logs. Defaults to no filter. This can be a regex and the search is case insensitive.
        :param str source: The source file (worker, raylet, dashboard, controller, proxy, replica, AUTOSCALER..) to filter the logs. Default to no filter.
        :param str filter_tags: The tags to filter the logs. Default to no filter. The format of this field is expected to be in json. The filer will apply to match each key of the object and do exact match on the value.
        :param bool reverse_sort: Whether the result should be sorted by descending timestamp. Also determines the query direction. When false, it will start to query from the start_time and return results until it reaches the page_size or the end_time. When true, it will start to query from the end_time and return results until it reaches the page_size or the start_time. Default to false.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(LogitembatchResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cluster_id',
            'workspace_id',
            'ha_job_id',
            'service_id',
            'page_size',
            'start_time',
            'end_time',
            'positive_search_filter',
            'negative_search_filter',
            'source',
            'filter_tags',
            'reverse_sort'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method query_aggregated_logs_api_v2_logs_query_aggregated_logs_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        if self.api_client.client_side_validation and 'page_size' in local_var_params and local_var_params['page_size'] > 1000:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `page_size` when calling `query_aggregated_logs_api_v2_logs_query_aggregated_logs_get`, must be a value less than or equal to `1000`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cluster_id' in local_var_params and local_var_params['cluster_id'] is not None:  # noqa: E501
            query_params.append(('cluster_id', local_var_params['cluster_id']))  # noqa: E501
        if 'workspace_id' in local_var_params and local_var_params['workspace_id'] is not None:  # noqa: E501
            query_params.append(('workspace_id', local_var_params['workspace_id']))  # noqa: E501
        if 'ha_job_id' in local_var_params and local_var_params['ha_job_id'] is not None:  # noqa: E501
            query_params.append(('ha_job_id', local_var_params['ha_job_id']))  # noqa: E501
        if 'service_id' in local_var_params and local_var_params['service_id'] is not None:  # noqa: E501
            query_params.append(('service_id', local_var_params['service_id']))  # noqa: E501
        if 'page_size' in local_var_params and local_var_params['page_size'] is not None:  # noqa: E501
            query_params.append(('page_size', local_var_params['page_size']))  # noqa: E501
        if 'start_time' in local_var_params and local_var_params['start_time'] is not None:  # noqa: E501
            query_params.append(('start_time', local_var_params['start_time']))  # noqa: E501
        if 'end_time' in local_var_params and local_var_params['end_time'] is not None:  # noqa: E501
            query_params.append(('end_time', local_var_params['end_time']))  # noqa: E501
        if 'positive_search_filter' in local_var_params and local_var_params['positive_search_filter'] is not None:  # noqa: E501
            query_params.append(('positive_search_filter', local_var_params['positive_search_filter']))  # noqa: E501
        if 'negative_search_filter' in local_var_params and local_var_params['negative_search_filter'] is not None:  # noqa: E501
            query_params.append(('negative_search_filter', local_var_params['negative_search_filter']))  # noqa: E501
        if 'source' in local_var_params and local_var_params['source'] is not None:  # noqa: E501
            query_params.append(('source', local_var_params['source']))  # noqa: E501
        if 'filter_tags' in local_var_params and local_var_params['filter_tags'] is not None:  # noqa: E501
            query_params.append(('filter_tags', local_var_params['filter_tags']))  # noqa: E501
        if 'reverse_sort' in local_var_params and local_var_params['reverse_sort'] is not None:  # noqa: E501
            query_params.append(('reverse_sort', local_var_params['reverse_sort']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/logs/query_aggregated_logs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogitembatchResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def redirect_to_service_api_v2_sessions_cluster_id_services_get(self, cluster_id, redirect_to, **kwargs):  # noqa: E501
        """Redirect To Service  # noqa: E501

        Redirects to a cluster's dataplane services. Requires a user to be logged in.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.redirect_to_service_api_v2_sessions_cluster_id_services_get(cluster_id, redirect_to, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param DataplaneServices redirect_to: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.redirect_to_service_api_v2_sessions_cluster_id_services_get_with_http_info(cluster_id, redirect_to, **kwargs)  # noqa: E501

    def redirect_to_service_api_v2_sessions_cluster_id_services_get_with_http_info(self, cluster_id, redirect_to, **kwargs):  # noqa: E501
        """Redirect To Service  # noqa: E501

        Redirects to a cluster's dataplane services. Requires a user to be logged in.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.redirect_to_service_api_v2_sessions_cluster_id_services_get_with_http_info(cluster_id, redirect_to, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cluster_id: (required)
        :param DataplaneServices redirect_to: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cluster_id',
            'redirect_to'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method redirect_to_service_api_v2_sessions_cluster_id_services_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and ('cluster_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cluster_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `redirect_to_service_api_v2_sessions_cluster_id_services_get`")  # noqa: E501
        # verify the required parameter 'redirect_to' is set
        if self.api_client.client_side_validation and ('redirect_to' not in local_var_params or  # noqa: E501
                                                        local_var_params['redirect_to'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `redirect_to` when calling `redirect_to_service_api_v2_sessions_cluster_id_services_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in local_var_params:
            path_params['cluster_id'] = local_var_params['cluster_id']  # noqa: E501

        query_params = []
        if 'redirect_to' in local_var_params and local_var_params['redirect_to'] is not None:  # noqa: E501
            query_params.append(('redirect_to', local_var_params['redirect_to']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/sessions/{cluster_id}/services', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def redirect_to_tools_api_v2_services_v2_service_id_tools_get(self, service_id, tool, **kwargs):  # noqa: E501
        """Redirect To Tools  # noqa: E501

        Redirects to a service's tool with proper authentication. Requires a user to be logged in.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.redirect_to_tools_api_v2_services_v2_service_id_tools_get(service_id, tool, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str service_id: (required)
        :param Tool tool: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.redirect_to_tools_api_v2_services_v2_service_id_tools_get_with_http_info(service_id, tool, **kwargs)  # noqa: E501

    def redirect_to_tools_api_v2_services_v2_service_id_tools_get_with_http_info(self, service_id, tool, **kwargs):  # noqa: E501
        """Redirect To Tools  # noqa: E501

        Redirects to a service's tool with proper authentication. Requires a user to be logged in.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.redirect_to_tools_api_v2_services_v2_service_id_tools_get_with_http_info(service_id, tool, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str service_id: (required)
        :param Tool tool: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'service_id',
            'tool'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method redirect_to_tools_api_v2_services_v2_service_id_tools_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'service_id' is set
        if self.api_client.client_side_validation and ('service_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['service_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `service_id` when calling `redirect_to_tools_api_v2_services_v2_service_id_tools_get`")  # noqa: E501
        # verify the required parameter 'tool' is set
        if self.api_client.client_side_validation and ('tool' not in local_var_params or  # noqa: E501
                                                        local_var_params['tool'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `tool` when calling `redirect_to_tools_api_v2_services_v2_service_id_tools_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in local_var_params:
            path_params['service_id'] = local_var_params['service_id']  # noqa: E501

        query_params = []
        if 'tool' in local_var_params and local_var_params['tool'] is not None:  # noqa: E501
            query_params.append(('tool', local_var_params['tool']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/services-v2/{service_id}/tools', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def register_buffer_api_v2_anyscaled_register_buffer_post(self, buffer_registration, **kwargs):  # noqa: E501
        """Register Buffer  # noqa: E501

        Register a node to receive a per-buffer token.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.register_buffer_api_v2_anyscaled_register_buffer_post(buffer_registration, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param BufferRegistration buffer_registration: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AnyscaledcredentialresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.register_buffer_api_v2_anyscaled_register_buffer_post_with_http_info(buffer_registration, **kwargs)  # noqa: E501

    def register_buffer_api_v2_anyscaled_register_buffer_post_with_http_info(self, buffer_registration, **kwargs):  # noqa: E501
        """Register Buffer  # noqa: E501

        Register a node to receive a per-buffer token.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.register_buffer_api_v2_anyscaled_register_buffer_post_with_http_info(buffer_registration, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param BufferRegistration buffer_registration: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AnyscaledcredentialresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'buffer_registration'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method register_buffer_api_v2_anyscaled_register_buffer_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'buffer_registration' is set
        if self.api_client.client_side_validation and ('buffer_registration' not in local_var_params or  # noqa: E501
                                                        local_var_params['buffer_registration'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `buffer_registration` when calling `register_buffer_api_v2_anyscaled_register_buffer_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'buffer_registration' in local_var_params:
            body_params = local_var_params['buffer_registration']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/anyscaled/register_buffer', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AnyscaledcredentialresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def register_build_api_v2_anyscaled_register_build_post(self, build_registration, **kwargs):  # noqa: E501
        """Register Build  # noqa: E501

        Register a node to receive a per-build token.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.register_build_api_v2_anyscaled_register_build_post(build_registration, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param BuildRegistration build_registration: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AnyscaledcredentialresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.register_build_api_v2_anyscaled_register_build_post_with_http_info(build_registration, **kwargs)  # noqa: E501

    def register_build_api_v2_anyscaled_register_build_post_with_http_info(self, build_registration, **kwargs):  # noqa: E501
        """Register Build  # noqa: E501

        Register a node to receive a per-build token.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.register_build_api_v2_anyscaled_register_build_post_with_http_info(build_registration, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param BuildRegistration build_registration: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AnyscaledcredentialresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'build_registration'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method register_build_api_v2_anyscaled_register_build_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'build_registration' is set
        if self.api_client.client_side_validation and ('build_registration' not in local_var_params or  # noqa: E501
                                                        local_var_params['build_registration'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `build_registration` when calling `register_build_api_v2_anyscaled_register_build_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'build_registration' in local_var_params:
            body_params = local_var_params['build_registration']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/anyscaled/register_build', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AnyscaledcredentialresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def register_user_api_v2_users_post(self, create_user, **kwargs):  # noqa: E501
        """Register User  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.register_user_api_v2_users_post(create_user, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateUser create_user: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.register_user_api_v2_users_post_with_http_info(create_user, **kwargs)  # noqa: E501

    def register_user_api_v2_users_post_with_http_info(self, create_user, **kwargs):  # noqa: E501
        """Register User  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.register_user_api_v2_users_post_with_http_info(create_user, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateUser create_user: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'create_user'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method register_user_api_v2_users_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'create_user' is set
        if self.api_client.client_side_validation and ('create_user' not in local_var_params or  # noqa: E501
                                                        local_var_params['create_user'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `create_user` when calling `register_user_api_v2_users_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_user' in local_var_params:
            body_params = local_var_params['create_user']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/users/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def register_v2_api_v2_anyscaled_register_v2_post(self, node_registration_v2, **kwargs):  # noqa: E501
        """Register V2  # noqa: E501

        Register a node to receive a per-cluster token.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.register_v2_api_v2_anyscaled_register_v2_post(node_registration_v2, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param NodeRegistrationV2 node_registration_v2: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AnyscaledcredentialresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.register_v2_api_v2_anyscaled_register_v2_post_with_http_info(node_registration_v2, **kwargs)  # noqa: E501

    def register_v2_api_v2_anyscaled_register_v2_post_with_http_info(self, node_registration_v2, **kwargs):  # noqa: E501
        """Register V2  # noqa: E501

        Register a node to receive a per-cluster token.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.register_v2_api_v2_anyscaled_register_v2_post_with_http_info(node_registration_v2, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param NodeRegistrationV2 node_registration_v2: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AnyscaledcredentialresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'node_registration_v2'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method register_v2_api_v2_anyscaled_register_v2_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'node_registration_v2' is set
        if self.api_client.client_side_validation and ('node_registration_v2' not in local_var_params or  # noqa: E501
                                                        local_var_params['node_registration_v2'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `node_registration_v2` when calling `register_v2_api_v2_anyscaled_register_v2_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'node_registration_v2' in local_var_params:
            body_params = local_var_params['node_registration_v2']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/anyscaled/register_v2', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AnyscaledcredentialresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove_organization_collaborator_api_v2_organization_collaborators_identity_id_delete(self, identity_id, **kwargs):  # noqa: E501
        """Remove Organization Collaborator  # noqa: E501

        Removes a collaborator from the organization  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_organization_collaborator_api_v2_organization_collaborators_identity_id_delete(identity_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str identity_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.remove_organization_collaborator_api_v2_organization_collaborators_identity_id_delete_with_http_info(identity_id, **kwargs)  # noqa: E501

    def remove_organization_collaborator_api_v2_organization_collaborators_identity_id_delete_with_http_info(self, identity_id, **kwargs):  # noqa: E501
        """Remove Organization Collaborator  # noqa: E501

        Removes a collaborator from the organization  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_organization_collaborator_api_v2_organization_collaborators_identity_id_delete_with_http_info(identity_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str identity_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'identity_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_organization_collaborator_api_v2_organization_collaborators_identity_id_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'identity_id' is set
        if self.api_client.client_side_validation and ('identity_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['identity_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `identity_id` when calling `remove_organization_collaborator_api_v2_organization_collaborators_identity_id_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'identity_id' in local_var_params:
            path_params['identity_id'] = local_var_params['identity_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organization_collaborators/{identity_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def request_email_magic_link_api_v2_users_email_magic_link_post(self, email_address, **kwargs):  # noqa: E501
        """Request Email Magic Link  # noqa: E501

        Request a magic link to be sent to an email.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.request_email_magic_link_api_v2_users_email_magic_link_post(email_address, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str email_address: (required)
        :param str redirect_to: A path within Anyscale console to redirect to after the user logs in. This only supports paths and not full urls.
        :param bool no_sso: If true, do not use SSO to log in.
        :param bool force_send: If true, we always send a magic link. Even if there is only one org the user belongs to.
        :param bool is_oa: If true, we use to the OA registration flow, where self-service is enabled.
        :param UtmFields utm_fields:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: RequestemailmagiclinkresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.request_email_magic_link_api_v2_users_email_magic_link_post_with_http_info(email_address, **kwargs)  # noqa: E501

    def request_email_magic_link_api_v2_users_email_magic_link_post_with_http_info(self, email_address, **kwargs):  # noqa: E501
        """Request Email Magic Link  # noqa: E501

        Request a magic link to be sent to an email.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.request_email_magic_link_api_v2_users_email_magic_link_post_with_http_info(email_address, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str email_address: (required)
        :param str redirect_to: A path within Anyscale console to redirect to after the user logs in. This only supports paths and not full urls.
        :param bool no_sso: If true, do not use SSO to log in.
        :param bool force_send: If true, we always send a magic link. Even if there is only one org the user belongs to.
        :param bool is_oa: If true, we use to the OA registration flow, where self-service is enabled.
        :param UtmFields utm_fields:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(RequestemailmagiclinkresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'email_address',
            'redirect_to',
            'no_sso',
            'force_send',
            'is_oa',
            'utm_fields'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method request_email_magic_link_api_v2_users_email_magic_link_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'email_address' is set
        if self.api_client.client_side_validation and ('email_address' not in local_var_params or  # noqa: E501
                                                        local_var_params['email_address'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `email_address` when calling `request_email_magic_link_api_v2_users_email_magic_link_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'email_address' in local_var_params and local_var_params['email_address'] is not None:  # noqa: E501
            query_params.append(('email_address', local_var_params['email_address']))  # noqa: E501
        if 'redirect_to' in local_var_params and local_var_params['redirect_to'] is not None:  # noqa: E501
            query_params.append(('redirect_to', local_var_params['redirect_to']))  # noqa: E501
        if 'no_sso' in local_var_params and local_var_params['no_sso'] is not None:  # noqa: E501
            query_params.append(('no_sso', local_var_params['no_sso']))  # noqa: E501
        if 'force_send' in local_var_params and local_var_params['force_send'] is not None:  # noqa: E501
            query_params.append(('force_send', local_var_params['force_send']))  # noqa: E501
        if 'is_oa' in local_var_params and local_var_params['is_oa'] is not None:  # noqa: E501
            query_params.append(('is_oa', local_var_params['is_oa']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'utm_fields' in local_var_params:
            body_params = local_var_params['utm_fields']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/users/email_magic_link', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RequestemailmagiclinkresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def request_password_reset_api_v2_users_request_password_reset_post(self, request_password_reset_params, **kwargs):  # noqa: E501
        """Request Password Reset  # noqa: E501

        Send the user an email with a reset link for a forgotten password.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.request_password_reset_api_v2_users_request_password_reset_post(request_password_reset_params, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param RequestPasswordResetParams request_password_reset_params: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.request_password_reset_api_v2_users_request_password_reset_post_with_http_info(request_password_reset_params, **kwargs)  # noqa: E501

    def request_password_reset_api_v2_users_request_password_reset_post_with_http_info(self, request_password_reset_params, **kwargs):  # noqa: E501
        """Request Password Reset  # noqa: E501

        Send the user an email with a reset link for a forgotten password.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.request_password_reset_api_v2_users_request_password_reset_post_with_http_info(request_password_reset_params, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param RequestPasswordResetParams request_password_reset_params: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'request_password_reset_params'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method request_password_reset_api_v2_users_request_password_reset_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'request_password_reset_params' is set
        if self.api_client.client_side_validation and ('request_password_reset_params' not in local_var_params or  # noqa: E501
                                                        local_var_params['request_password_reset_params'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `request_password_reset_params` when calling `request_password_reset_api_v2_users_request_password_reset_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'request_password_reset_params' in local_var_params:
            body_params = local_var_params['request_password_reset_params']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/users/request_password_reset', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def reset_password_api_v2_users_reset_password_post(self, reset_password_params, **kwargs):  # noqa: E501
        """Reset Password  # noqa: E501

        Change the user's password to the new password  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.reset_password_api_v2_users_reset_password_post(reset_password_params, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ResetPasswordParams reset_password_params: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.reset_password_api_v2_users_reset_password_post_with_http_info(reset_password_params, **kwargs)  # noqa: E501

    def reset_password_api_v2_users_reset_password_post_with_http_info(self, reset_password_params, **kwargs):  # noqa: E501
        """Reset Password  # noqa: E501

        Change the user's password to the new password  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.reset_password_api_v2_users_reset_password_post_with_http_info(reset_password_params, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ResetPasswordParams reset_password_params: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'reset_password_params'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method reset_password_api_v2_users_reset_password_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'reset_password_params' is set
        if self.api_client.client_side_validation and ('reset_password_params' not in local_var_params or  # noqa: E501
                                                        local_var_params['reset_password_params'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `reset_password_params` when calling `reset_password_api_v2_users_reset_password_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'reset_password_params' in local_var_params:
            body_params = local_var_params['reset_password_params']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/users/reset_password', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def restart_service_api_v2_services_v2_service_id_restart_post(self, service_id, **kwargs):  # noqa: E501
        """Restart Service  # noqa: E501

        Restart an existing service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.restart_service_api_v2_services_v2_service_id_restart_post(service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str service_id: (required)
        :param str service_version_id: Service Version ID to restart Service
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Decoratedproductionservicev2ApimodelResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.restart_service_api_v2_services_v2_service_id_restart_post_with_http_info(service_id, **kwargs)  # noqa: E501

    def restart_service_api_v2_services_v2_service_id_restart_post_with_http_info(self, service_id, **kwargs):  # noqa: E501
        """Restart Service  # noqa: E501

        Restart an existing service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.restart_service_api_v2_services_v2_service_id_restart_post_with_http_info(service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str service_id: (required)
        :param str service_version_id: Service Version ID to restart Service
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Decoratedproductionservicev2ApimodelResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'service_id',
            'service_version_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method restart_service_api_v2_services_v2_service_id_restart_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'service_id' is set
        if self.api_client.client_side_validation and ('service_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['service_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `service_id` when calling `restart_service_api_v2_services_v2_service_id_restart_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in local_var_params:
            path_params['service_id'] = local_var_params['service_id']  # noqa: E501

        query_params = []
        if 'service_version_id' in local_var_params and local_var_params['service_version_id'] is not None:  # noqa: E501
            query_params.append(('service_version_id', local_var_params['service_version_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/services-v2/{service_id}/restart', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Decoratedproductionservicev2ApimodelResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def resubmit_fine_tuning_job_api_v2_fine_tuning_jobs_internal_resubmit_post(self, resubmit_ft_job_request, **kwargs):  # noqa: E501
        """Resubmit Fine Tuning Job  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.resubmit_fine_tuning_job_api_v2_fine_tuning_jobs_internal_resubmit_post(resubmit_ft_job_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ResubmitFTJobRequest resubmit_ft_job_request: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.resubmit_fine_tuning_job_api_v2_fine_tuning_jobs_internal_resubmit_post_with_http_info(resubmit_ft_job_request, **kwargs)  # noqa: E501

    def resubmit_fine_tuning_job_api_v2_fine_tuning_jobs_internal_resubmit_post_with_http_info(self, resubmit_ft_job_request, **kwargs):  # noqa: E501
        """Resubmit Fine Tuning Job  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.resubmit_fine_tuning_job_api_v2_fine_tuning_jobs_internal_resubmit_post_with_http_info(resubmit_ft_job_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ResubmitFTJobRequest resubmit_ft_job_request: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'resubmit_ft_job_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method resubmit_fine_tuning_job_api_v2_fine_tuning_jobs_internal_resubmit_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'resubmit_ft_job_request' is set
        if self.api_client.client_side_validation and ('resubmit_ft_job_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['resubmit_ft_job_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `resubmit_ft_job_request` when calling `resubmit_fine_tuning_job_api_v2_fine_tuning_jobs_internal_resubmit_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'resubmit_ft_job_request' in local_var_params:
            body_params = local_var_params['resubmit_ft_job_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/fine_tuning/jobs/internal/resubmit', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def rollback_service_api_v2_services_v2_service_id_rollback_post(self, service_id, **kwargs):  # noqa: E501
        """Rollback Service  # noqa: E501

        Rollback a Service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.rollback_service_api_v2_services_v2_service_id_rollback_post(service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str service_id: (required)
        :param RollbackServiceModel rollback_service_model:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Decoratedproductionservicev2ApimodelResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.rollback_service_api_v2_services_v2_service_id_rollback_post_with_http_info(service_id, **kwargs)  # noqa: E501

    def rollback_service_api_v2_services_v2_service_id_rollback_post_with_http_info(self, service_id, **kwargs):  # noqa: E501
        """Rollback Service  # noqa: E501

        Rollback a Service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.rollback_service_api_v2_services_v2_service_id_rollback_post_with_http_info(service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str service_id: (required)
        :param RollbackServiceModel rollback_service_model:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Decoratedproductionservicev2ApimodelResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'service_id',
            'rollback_service_model'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method rollback_service_api_v2_services_v2_service_id_rollback_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'service_id' is set
        if self.api_client.client_side_validation and ('service_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['service_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `service_id` when calling `rollback_service_api_v2_services_v2_service_id_rollback_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in local_var_params:
            path_params['service_id'] = local_var_params['service_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'rollback_service_model' in local_var_params:
            body_params = local_var_params['rollback_service_model']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/services-v2/{service_id}/rollback', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Decoratedproductionservicev2ApimodelResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def rotate_api_key_api_v2_users_rotate_api_key_get(self, **kwargs):  # noqa: E501
        """Rotate Api Key  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.rotate_api_key_api_v2_users_rotate_api_key_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ServersessiontokenResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.rotate_api_key_api_v2_users_rotate_api_key_get_with_http_info(**kwargs)  # noqa: E501

    def rotate_api_key_api_v2_users_rotate_api_key_get_with_http_info(self, **kwargs):  # noqa: E501
        """Rotate Api Key  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.rotate_api_key_api_v2_users_rotate_api_key_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ServersessiontokenResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method rotate_api_key_api_v2_users_rotate_api_key_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/users/rotate_api_key', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ServersessiontokenResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def rotate_api_key_for_user_api_v2_organization_collaborators_rotate_api_key_for_user_user_id_post(self, user_id, **kwargs):  # noqa: E501
        """Rotate Api Key For User  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.rotate_api_key_for_user_api_v2_organization_collaborators_rotate_api_key_for_user_user_id_post(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.rotate_api_key_for_user_api_v2_organization_collaborators_rotate_api_key_for_user_user_id_post_with_http_info(user_id, **kwargs)  # noqa: E501

    def rotate_api_key_for_user_api_v2_organization_collaborators_rotate_api_key_for_user_user_id_post_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Rotate Api Key For User  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.rotate_api_key_for_user_api_v2_organization_collaborators_rotate_api_key_for_user_user_id_post_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'user_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method rotate_api_key_for_user_api_v2_organization_collaborators_rotate_api_key_for_user_user_id_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['user_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `user_id` when calling `rotate_api_key_for_user_api_v2_organization_collaborators_rotate_api_key_for_user_user_id_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in local_var_params:
            path_params['user_id'] = local_var_params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organization_collaborators/rotate_api_key_for_user/{user_id}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def saml_acs_api_v2_organizations_organization_id_saml_acs_post(self, organization_id, **kwargs):  # noqa: E501
        """Saml Acs  # noqa: E501

        Authenticate the user for Single Sign On (SSO) using the SAML2 protocol. If successful, log the user in by setting the session cookie. Then redirect to the RelayState parameter if it's under the Anyscale domain, or otherwise just to the Anyscale landing page.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.saml_acs_api_v2_organizations_organization_id_saml_acs_post(organization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str organization_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.saml_acs_api_v2_organizations_organization_id_saml_acs_post_with_http_info(organization_id, **kwargs)  # noqa: E501

    def saml_acs_api_v2_organizations_organization_id_saml_acs_post_with_http_info(self, organization_id, **kwargs):  # noqa: E501
        """Saml Acs  # noqa: E501

        Authenticate the user for Single Sign On (SSO) using the SAML2 protocol. If successful, log the user in by setting the session cookie. Then redirect to the RelayState parameter if it's under the Anyscale domain, or otherwise just to the Anyscale landing page.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.saml_acs_api_v2_organizations_organization_id_saml_acs_post_with_http_info(organization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str organization_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'organization_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method saml_acs_api_v2_organizations_organization_id_saml_acs_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_id' is set
        if self.api_client.client_side_validation and ('organization_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['organization_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_id` when calling `saml_acs_api_v2_organizations_organization_id_saml_acs_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_id' in local_var_params:
            path_params['organization_id'] = local_var_params['organization_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organizations/{organization_id}/saml_acs', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_cloud_collaborators_api_v2_clouds_cloud_id_collaborators_users_search_post(self, cloud_id, cloud_collaborators_query, **kwargs):  # noqa: E501
        """Search Cloud Collaborators  # noqa: E501

        Create a search of collaborators for a given cloud  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_cloud_collaborators_api_v2_clouds_cloud_id_collaborators_users_search_post(cloud_id, cloud_collaborators_query, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param CloudCollaboratorsQuery cloud_collaborators_query: (required)
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CloudcollaboratorListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.search_cloud_collaborators_api_v2_clouds_cloud_id_collaborators_users_search_post_with_http_info(cloud_id, cloud_collaborators_query, **kwargs)  # noqa: E501

    def search_cloud_collaborators_api_v2_clouds_cloud_id_collaborators_users_search_post_with_http_info(self, cloud_id, cloud_collaborators_query, **kwargs):  # noqa: E501
        """Search Cloud Collaborators  # noqa: E501

        Create a search of collaborators for a given cloud  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_cloud_collaborators_api_v2_clouds_cloud_id_collaborators_users_search_post_with_http_info(cloud_id, cloud_collaborators_query, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param CloudCollaboratorsQuery cloud_collaborators_query: (required)
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CloudcollaboratorListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id',
            'cloud_collaborators_query',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_cloud_collaborators_api_v2_clouds_cloud_id_collaborators_users_search_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `search_cloud_collaborators_api_v2_clouds_cloud_id_collaborators_users_search_post`")  # noqa: E501
        # verify the required parameter 'cloud_collaborators_query' is set
        if self.api_client.client_side_validation and ('cloud_collaborators_query' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_collaborators_query'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_collaborators_query` when calling `search_cloud_collaborators_api_v2_clouds_cloud_id_collaborators_users_search_post`")  # noqa: E501

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 50:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `search_cloud_collaborators_api_v2_clouds_cloud_id_collaborators_users_search_post`, must be a value less than or equal to `50`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `search_cloud_collaborators_api_v2_clouds_cloud_id_collaborators_users_search_post`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501

        query_params = []
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'cloud_collaborators_query' in local_var_params:
            body_params = local_var_params['cloud_collaborators_query']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds/{cloud_id}/collaborators/users/search', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CloudcollaboratorListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_cluster_environments_api_v2_application_templates_search_post(self, cluster_environments_query, **kwargs):  # noqa: E501
        """Search Cluster Environments  # noqa: E501

        Lists all Cluster Environments that the logged in user has permissions to access.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_cluster_environments_api_v2_application_templates_search_post(cluster_environments_query, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ClusterEnvironmentsQuery cluster_environments_query: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AppconfigListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.search_cluster_environments_api_v2_application_templates_search_post_with_http_info(cluster_environments_query, **kwargs)  # noqa: E501

    def search_cluster_environments_api_v2_application_templates_search_post_with_http_info(self, cluster_environments_query, **kwargs):  # noqa: E501
        """Search Cluster Environments  # noqa: E501

        Lists all Cluster Environments that the logged in user has permissions to access.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_cluster_environments_api_v2_application_templates_search_post_with_http_info(cluster_environments_query, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ClusterEnvironmentsQuery cluster_environments_query: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AppconfigListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cluster_environments_query'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_cluster_environments_api_v2_application_templates_search_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_environments_query' is set
        if self.api_client.client_side_validation and ('cluster_environments_query' not in local_var_params or  # noqa: E501
                                                        local_var_params['cluster_environments_query'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_environments_query` when calling `search_cluster_environments_api_v2_application_templates_search_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'cluster_environments_query' in local_var_params:
            body_params = local_var_params['cluster_environments_query']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/application_templates/search', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AppconfigListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_compute_templates_api_v2_compute_templates_search_post(self, compute_template_query, **kwargs):  # noqa: E501
        """Search Compute Templates  # noqa: E501

        List all compute templates matching the search parameters. If no parameters are specified, lists all templates created by the user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_compute_templates_api_v2_compute_templates_search_post(compute_template_query, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ComputeTemplateQuery compute_template_query: (required)
        :param str paging_token:
        :param int count:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedcomputetemplateListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.search_compute_templates_api_v2_compute_templates_search_post_with_http_info(compute_template_query, **kwargs)  # noqa: E501

    def search_compute_templates_api_v2_compute_templates_search_post_with_http_info(self, compute_template_query, **kwargs):  # noqa: E501
        """Search Compute Templates  # noqa: E501

        List all compute templates matching the search parameters. If no parameters are specified, lists all templates created by the user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_compute_templates_api_v2_compute_templates_search_post_with_http_info(compute_template_query, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ComputeTemplateQuery compute_template_query: (required)
        :param str paging_token:
        :param int count:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedcomputetemplateListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'compute_template_query',
            'paging_token',
            'count'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_compute_templates_api_v2_compute_templates_search_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'compute_template_query' is set
        if self.api_client.client_side_validation and ('compute_template_query' not in local_var_params or  # noqa: E501
                                                        local_var_params['compute_template_query'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `compute_template_query` when calling `search_compute_templates_api_v2_compute_templates_search_post`")  # noqa: E501

        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] > 1000:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `search_compute_templates_api_v2_compute_templates_search_post`, must be a value less than or equal to `1000`")  # noqa: E501
        if self.api_client.client_side_validation and 'count' in local_var_params and local_var_params['count'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `count` when calling `search_compute_templates_api_v2_compute_templates_search_post`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'paging_token' in local_var_params and local_var_params['paging_token'] is not None:  # noqa: E501
            query_params.append(('paging_token', local_var_params['paging_token']))  # noqa: E501
        if 'count' in local_var_params and local_var_params['count'] is not None:  # noqa: E501
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'compute_template_query' in local_var_params:
            body_params = local_var_params['compute_template_query']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/compute_templates/search', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedcomputetemplateListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_invoices_api_v2_organization_billing_invoices_post(self, invoices_query, **kwargs):  # noqa: E501
        """Search Invoices  # noqa: E501

        List invoices for current organization.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_invoices_api_v2_organization_billing_invoices_post(invoices_query, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param InvoicesQuery invoices_query: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InvoiceListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.search_invoices_api_v2_organization_billing_invoices_post_with_http_info(invoices_query, **kwargs)  # noqa: E501

    def search_invoices_api_v2_organization_billing_invoices_post_with_http_info(self, invoices_query, **kwargs):  # noqa: E501
        """Search Invoices  # noqa: E501

        List invoices for current organization.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_invoices_api_v2_organization_billing_invoices_post_with_http_info(invoices_query, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param InvoicesQuery invoices_query: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InvoiceListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'invoices_query'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_invoices_api_v2_organization_billing_invoices_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'invoices_query' is set
        if self.api_client.client_side_validation and ('invoices_query' not in local_var_params or  # noqa: E501
                                                        local_var_params['invoices_query'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `invoices_query` when calling `search_invoices_api_v2_organization_billing_invoices_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'invoices_query' in local_var_params:
            body_params = local_var_params['invoices_query']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organization_billing/invoices', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InvoiceListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_support_requests_api_v2_support_requests_search_post(self, support_requests_query, **kwargs):  # noqa: E501
        """Search Support Requests  # noqa: E501

        List all decorated support requests matching the search parameters.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_support_requests_api_v2_support_requests_search_post(support_requests_query, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param SupportRequestsQuery support_requests_query: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DecoratedsupportrequestListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.search_support_requests_api_v2_support_requests_search_post_with_http_info(support_requests_query, **kwargs)  # noqa: E501

    def search_support_requests_api_v2_support_requests_search_post_with_http_info(self, support_requests_query, **kwargs):  # noqa: E501
        """Search Support Requests  # noqa: E501

        List all decorated support requests matching the search parameters.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_support_requests_api_v2_support_requests_search_post_with_http_info(support_requests_query, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param SupportRequestsQuery support_requests_query: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DecoratedsupportrequestListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'support_requests_query'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_support_requests_api_v2_support_requests_search_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'support_requests_query' is set
        if self.api_client.client_side_validation and ('support_requests_query' not in local_var_params or  # noqa: E501
                                                        local_var_params['support_requests_query'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `support_requests_query` when calling `search_support_requests_api_v2_support_requests_search_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'support_requests_query' in local_var_params:
            body_params = local_var_params['support_requests_query']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/support_requests/search', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DecoratedsupportrequestListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_user_cards_api_v2_onboarding_cards_search_post(self, onboarding_user_cards_query, **kwargs):  # noqa: E501
        """Search User Cards  # noqa: E501

        Lists all onboarding user cards that the logged in user has access to, matching the input query.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_user_cards_api_v2_onboarding_cards_search_post(onboarding_user_cards_query, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param OnboardingUserCardsQuery onboarding_user_cards_query: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CardListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.search_user_cards_api_v2_onboarding_cards_search_post_with_http_info(onboarding_user_cards_query, **kwargs)  # noqa: E501

    def search_user_cards_api_v2_onboarding_cards_search_post_with_http_info(self, onboarding_user_cards_query, **kwargs):  # noqa: E501
        """Search User Cards  # noqa: E501

        Lists all onboarding user cards that the logged in user has access to, matching the input query.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_user_cards_api_v2_onboarding_cards_search_post_with_http_info(onboarding_user_cards_query, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param OnboardingUserCardsQuery onboarding_user_cards_query: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CardListResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'onboarding_user_cards_query'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_user_cards_api_v2_onboarding_cards_search_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'onboarding_user_cards_query' is set
        if self.api_client.client_side_validation and ('onboarding_user_cards_query' not in local_var_params or  # noqa: E501
                                                        local_var_params['onboarding_user_cards_query'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `onboarding_user_cards_query` when calling `search_user_cards_api_v2_onboarding_cards_search_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'onboarding_user_cards_query' in local_var_params:
            body_params = local_var_params['onboarding_user_cards_query']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/onboarding_cards/search', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CardListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_organization_to_be_blocked_api_v2_organizations_block_post(self, **kwargs):  # noqa: E501
        """Set Organization To Be Blocked  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_organization_to_be_blocked_api_v2_organizations_block_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.set_organization_to_be_blocked_api_v2_organizations_block_post_with_http_info(**kwargs)  # noqa: E501

    def set_organization_to_be_blocked_api_v2_organizations_block_post_with_http_info(self, **kwargs):  # noqa: E501
        """Set Organization To Be Blocked  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_organization_to_be_blocked_api_v2_organizations_block_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_organization_to_be_blocked_api_v2_organizations_block_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organizations/block', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_organization_to_be_unblocked_api_v2_organizations_organization_id_unblock_post(self, organization_id, **kwargs):  # noqa: E501
        """Set Organization To Be Unblocked  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_organization_to_be_unblocked_api_v2_organizations_organization_id_unblock_post(organization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str organization_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.set_organization_to_be_unblocked_api_v2_organizations_organization_id_unblock_post_with_http_info(organization_id, **kwargs)  # noqa: E501

    def set_organization_to_be_unblocked_api_v2_organizations_organization_id_unblock_post_with_http_info(self, organization_id, **kwargs):  # noqa: E501
        """Set Organization To Be Unblocked  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_organization_to_be_unblocked_api_v2_organizations_organization_id_unblock_post_with_http_info(organization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str organization_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'organization_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_organization_to_be_unblocked_api_v2_organizations_organization_id_unblock_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_id' is set
        if self.api_client.client_side_validation and ('organization_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['organization_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_id` when calling `set_organization_to_be_unblocked_api_v2_organizations_organization_id_unblock_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_id' in local_var_params:
            path_params['organization_id'] = local_var_params['organization_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organizations/{organization_id}/unblock', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def setup_and_initialize_session_api_v2_sessions_session_id_setup_and_initialize_session_post(self, session_id, setup_initialize_session_options, **kwargs):  # noqa: E501
        """Setup And Initialize Session  # noqa: E501

        Updates the cluster when `anyscale up` is called. This should be called when /start_empty_session     returns second_update_required as True, and after the file mounts are synced with rsync     from the CLI. This endpoint runs the initialization/setup commands on the head node of     the cluster, and then updates the file mounts and workers in ~/ray_bootstrap_config.yaml.     File mounts are added to ~/ray_bootstrap_config.yaml as the last step so files from the     product server are not synced to the user cluster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.setup_and_initialize_session_api_v2_sessions_session_id_setup_and_initialize_session_post(session_id, setup_initialize_session_options, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param SetupInitializeSessionOptions setup_initialize_session_options: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.setup_and_initialize_session_api_v2_sessions_session_id_setup_and_initialize_session_post_with_http_info(session_id, setup_initialize_session_options, **kwargs)  # noqa: E501

    def setup_and_initialize_session_api_v2_sessions_session_id_setup_and_initialize_session_post_with_http_info(self, session_id, setup_initialize_session_options, **kwargs):  # noqa: E501
        """Setup And Initialize Session  # noqa: E501

        Updates the cluster when `anyscale up` is called. This should be called when /start_empty_session     returns second_update_required as True, and after the file mounts are synced with rsync     from the CLI. This endpoint runs the initialization/setup commands on the head node of     the cluster, and then updates the file mounts and workers in ~/ray_bootstrap_config.yaml.     File mounts are added to ~/ray_bootstrap_config.yaml as the last step so files from the     product server are not synced to the user cluster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.setup_and_initialize_session_api_v2_sessions_session_id_setup_and_initialize_session_post_with_http_info(session_id, setup_initialize_session_options, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param SetupInitializeSessionOptions setup_initialize_session_options: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'session_id',
            'setup_initialize_session_options'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method setup_and_initialize_session_api_v2_sessions_session_id_setup_and_initialize_session_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'session_id' is set
        if self.api_client.client_side_validation and ('session_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_id` when calling `setup_and_initialize_session_api_v2_sessions_session_id_setup_and_initialize_session_post`")  # noqa: E501
        # verify the required parameter 'setup_initialize_session_options' is set
        if self.api_client.client_side_validation and ('setup_initialize_session_options' not in local_var_params or  # noqa: E501
                                                        local_var_params['setup_initialize_session_options'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `setup_initialize_session_options` when calling `setup_and_initialize_session_api_v2_sessions_session_id_setup_and_initialize_session_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'session_id' in local_var_params:
            path_params['session_id'] = local_var_params['session_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'setup_initialize_session_options' in local_var_params:
            body_params = local_var_params['setup_initialize_session_options']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/sessions/{session_id}/setup_and_initialize_session', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def show_one_time_password_source_api_v2_users_show_otp_source_post(self, otp, **kwargs):  # noqa: E501
        """Show One Time Password Source  # noqa: E501

        Show the source of the one time password.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.show_one_time_password_source_api_v2_users_show_otp_source_post(otp, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str otp: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ShowotpsourcereturnapimodelResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.show_one_time_password_source_api_v2_users_show_otp_source_post_with_http_info(otp, **kwargs)  # noqa: E501

    def show_one_time_password_source_api_v2_users_show_otp_source_post_with_http_info(self, otp, **kwargs):  # noqa: E501
        """Show One Time Password Source  # noqa: E501

        Show the source of the one time password.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.show_one_time_password_source_api_v2_users_show_otp_source_post_with_http_info(otp, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str otp: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ShowotpsourcereturnapimodelResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'otp'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method show_one_time_password_source_api_v2_users_show_otp_source_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'otp' is set
        if self.api_client.client_side_validation and ('otp' not in local_var_params or  # noqa: E501
                                                        local_var_params['otp'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `otp` when calling `show_one_time_password_source_api_v2_users_show_otp_source_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'otp' in local_var_params and local_var_params['otp'] is not None:  # noqa: E501
            query_params.append(('otp', local_var_params['otp']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/users/show_otp_source', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ShowotpsourcereturnapimodelResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def sso_login_info_api_v2_users_sso_login_info_get(self, organization_id, **kwargs):  # noqa: E501
        """Sso Login Info  # noqa: E501

        Get the url for initiating SAML.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.sso_login_info_api_v2_users_sso_login_info_get(organization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str organization_id: (required)
        :param str magic_token:
        :param str return_to:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: SsologininfoResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.sso_login_info_api_v2_users_sso_login_info_get_with_http_info(organization_id, **kwargs)  # noqa: E501

    def sso_login_info_api_v2_users_sso_login_info_get_with_http_info(self, organization_id, **kwargs):  # noqa: E501
        """Sso Login Info  # noqa: E501

        Get the url for initiating SAML.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.sso_login_info_api_v2_users_sso_login_info_get_with_http_info(organization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str organization_id: (required)
        :param str magic_token:
        :param str return_to:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(SsologininfoResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'organization_id',
            'magic_token',
            'return_to'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sso_login_info_api_v2_users_sso_login_info_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_id' is set
        if self.api_client.client_side_validation and ('organization_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['organization_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_id` when calling `sso_login_info_api_v2_users_sso_login_info_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'organization_id' in local_var_params and local_var_params['organization_id'] is not None:  # noqa: E501
            query_params.append(('organization_id', local_var_params['organization_id']))  # noqa: E501
        if 'magic_token' in local_var_params and local_var_params['magic_token'] is not None:  # noqa: E501
            query_params.append(('magic_token', local_var_params['magic_token']))  # noqa: E501
        if 'return_to' in local_var_params and local_var_params['return_to'] is not None:  # noqa: E501
            query_params.append(('return_to', local_var_params['return_to']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/users/sso_login_info', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SsologininfoResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def sso_login_test_api_v2_users_sso_login_test_get(self, organization_id, **kwargs):  # noqa: E501
        """Sso Login Test  # noqa: E501

        Redirect to the url for testing SAML.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.sso_login_test_api_v2_users_sso_login_test_get(organization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str organization_id: (required)
        :param str return_to:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.sso_login_test_api_v2_users_sso_login_test_get_with_http_info(organization_id, **kwargs)  # noqa: E501

    def sso_login_test_api_v2_users_sso_login_test_get_with_http_info(self, organization_id, **kwargs):  # noqa: E501
        """Sso Login Test  # noqa: E501

        Redirect to the url for testing SAML.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.sso_login_test_api_v2_users_sso_login_test_get_with_http_info(organization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str organization_id: (required)
        :param str return_to:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'organization_id',
            'return_to'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sso_login_test_api_v2_users_sso_login_test_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_id' is set
        if self.api_client.client_side_validation and ('organization_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['organization_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_id` when calling `sso_login_test_api_v2_users_sso_login_test_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'organization_id' in local_var_params and local_var_params['organization_id'] is not None:  # noqa: E501
            query_params.append(('organization_id', local_var_params['organization_id']))  # noqa: E501
        if 'return_to' in local_var_params and local_var_params['return_to'] is not None:  # noqa: E501
            query_params.append(('return_to', local_var_params['return_to']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/users/sso_login_test', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def start_endpoint_api_v2_aica_endpoints_endpoint_id_start_post(self, endpoint_id, **kwargs):  # noqa: E501
        """Start Endpoint  # noqa: E501

        Start an endpoint  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.start_endpoint_api_v2_aica_endpoints_endpoint_id_start_post(endpoint_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str endpoint_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.start_endpoint_api_v2_aica_endpoints_endpoint_id_start_post_with_http_info(endpoint_id, **kwargs)  # noqa: E501

    def start_endpoint_api_v2_aica_endpoints_endpoint_id_start_post_with_http_info(self, endpoint_id, **kwargs):  # noqa: E501
        """Start Endpoint  # noqa: E501

        Start an endpoint  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.start_endpoint_api_v2_aica_endpoints_endpoint_id_start_post_with_http_info(endpoint_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str endpoint_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'endpoint_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method start_endpoint_api_v2_aica_endpoints_endpoint_id_start_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'endpoint_id' is set
        if self.api_client.client_side_validation and ('endpoint_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['endpoint_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `endpoint_id` when calling `start_endpoint_api_v2_aica_endpoints_endpoint_id_start_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'endpoint_id' in local_var_params:
            path_params['endpoint_id'] = local_var_params['endpoint_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/aica_endpoints/{endpoint_id}/start', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def start_session_api_v2_sessions_session_id_start_post(self, session_id, start_session_options, **kwargs):  # noqa: E501
        """Start Session  # noqa: E501

        Start a (previously stopped) session.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.start_session_api_v2_sessions_session_id_start_post(session_id, start_session_options, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param StartSessionOptions start_session_options: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.start_session_api_v2_sessions_session_id_start_post_with_http_info(session_id, start_session_options, **kwargs)  # noqa: E501

    def start_session_api_v2_sessions_session_id_start_post_with_http_info(self, session_id, start_session_options, **kwargs):  # noqa: E501
        """Start Session  # noqa: E501

        Start a (previously stopped) session.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.start_session_api_v2_sessions_session_id_start_post_with_http_info(session_id, start_session_options, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param StartSessionOptions start_session_options: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'session_id',
            'start_session_options'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method start_session_api_v2_sessions_session_id_start_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'session_id' is set
        if self.api_client.client_side_validation and ('session_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_id` when calling `start_session_api_v2_sessions_session_id_start_post`")  # noqa: E501
        # verify the required parameter 'start_session_options' is set
        if self.api_client.client_side_validation and ('start_session_options' not in local_var_params or  # noqa: E501
                                                        local_var_params['start_session_options'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `start_session_options` when calling `start_session_api_v2_sessions_session_id_start_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'session_id' in local_var_params:
            path_params['session_id'] = local_var_params['session_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'start_session_options' in local_var_params:
            body_params = local_var_params['start_session_options']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/sessions/{session_id}/start', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def stop_session_api_v2_sessions_session_id_stop_post(self, session_id, stop_session_options, **kwargs):  # noqa: E501
        """Stop Session  # noqa: E501

        Terminate an active session of a project.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.stop_session_api_v2_sessions_session_id_stop_post(session_id, stop_session_options, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param StopSessionOptions stop_session_options: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.stop_session_api_v2_sessions_session_id_stop_post_with_http_info(session_id, stop_session_options, **kwargs)  # noqa: E501

    def stop_session_api_v2_sessions_session_id_stop_post_with_http_info(self, session_id, stop_session_options, **kwargs):  # noqa: E501
        """Stop Session  # noqa: E501

        Terminate an active session of a project.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.stop_session_api_v2_sessions_session_id_stop_post_with_http_info(session_id, stop_session_options, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_id: (required)
        :param StopSessionOptions stop_session_options: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'session_id',
            'stop_session_options'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stop_session_api_v2_sessions_session_id_stop_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'session_id' is set
        if self.api_client.client_side_validation and ('session_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_id` when calling `stop_session_api_v2_sessions_session_id_stop_post`")  # noqa: E501
        # verify the required parameter 'stop_session_options' is set
        if self.api_client.client_side_validation and ('stop_session_options' not in local_var_params or  # noqa: E501
                                                        local_var_params['stop_session_options'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `stop_session_options` when calling `stop_session_api_v2_sessions_session_id_stop_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'session_id' in local_var_params:
            path_params['session_id'] = local_var_params['session_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'stop_session_options' in local_var_params:
            body_params = local_var_params['stop_session_options']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/sessions/{session_id}/stop', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def terminate_job_api_v2_decorated_ha_jobs_production_job_id_terminate_post(self, production_job_id, **kwargs):  # noqa: E501
        """Terminate Job  # noqa: E501

        Terminate an HA Job  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.terminate_job_api_v2_decorated_ha_jobs_production_job_id_terminate_post(production_job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str production_job_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InternalproductionjobResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.terminate_job_api_v2_decorated_ha_jobs_production_job_id_terminate_post_with_http_info(production_job_id, **kwargs)  # noqa: E501

    def terminate_job_api_v2_decorated_ha_jobs_production_job_id_terminate_post_with_http_info(self, production_job_id, **kwargs):  # noqa: E501
        """Terminate Job  # noqa: E501

        Terminate an HA Job  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.terminate_job_api_v2_decorated_ha_jobs_production_job_id_terminate_post_with_http_info(production_job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str production_job_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InternalproductionjobResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'production_job_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method terminate_job_api_v2_decorated_ha_jobs_production_job_id_terminate_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'production_job_id' is set
        if self.api_client.client_side_validation and ('production_job_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['production_job_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `production_job_id` when calling `terminate_job_api_v2_decorated_ha_jobs_production_job_id_terminate_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'production_job_id' in local_var_params:
            path_params['production_job_id'] = local_var_params['production_job_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/decorated_ha_jobs/{production_job_id}/terminate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InternalproductionjobResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def terminate_service_api_v2_services_v2_service_id_terminate_post(self, service_id, **kwargs):  # noqa: E501
        """Terminate Service  # noqa: E501

        Terminate a Service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.terminate_service_api_v2_services_v2_service_id_terminate_post(service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str service_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Decoratedproductionservicev2ApimodelResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.terminate_service_api_v2_services_v2_service_id_terminate_post_with_http_info(service_id, **kwargs)  # noqa: E501

    def terminate_service_api_v2_services_v2_service_id_terminate_post_with_http_info(self, service_id, **kwargs):  # noqa: E501
        """Terminate Service  # noqa: E501

        Terminate a Service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.terminate_service_api_v2_services_v2_service_id_terminate_post_with_http_info(service_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str service_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Decoratedproductionservicev2ApimodelResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'service_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method terminate_service_api_v2_services_v2_service_id_terminate_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'service_id' is set
        if self.api_client.client_side_validation and ('service_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['service_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `service_id` when calling `terminate_service_api_v2_services_v2_service_id_terminate_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'service_id' in local_var_params:
            path_params['service_id'] = local_var_params['service_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/services-v2/{service_id}/terminate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Decoratedproductionservicev2ApimodelResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def test_saml_acs_api_v2_organizations_organization_id_test_saml_acs_post(self, organization_id, **kwargs):  # noqa: E501
        """Test Saml Acs  # noqa: E501

        Use this organization's Single Sign On (SSO) test config with the SAML2 protocol as a test. This will return a 2xx status code if authentication was successful, or a 4xx or 5xx code if not. Either way, we will not create an authenticated session and the caller will not be logged in.  Use this endpoint to test out a new sso_config without setting it as the only way to log into your organization.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.test_saml_acs_api_v2_organizations_organization_id_test_saml_acs_post(organization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str organization_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.test_saml_acs_api_v2_organizations_organization_id_test_saml_acs_post_with_http_info(organization_id, **kwargs)  # noqa: E501

    def test_saml_acs_api_v2_organizations_organization_id_test_saml_acs_post_with_http_info(self, organization_id, **kwargs):  # noqa: E501
        """Test Saml Acs  # noqa: E501

        Use this organization's Single Sign On (SSO) test config with the SAML2 protocol as a test. This will return a 2xx status code if authentication was successful, or a 4xx or 5xx code if not. Either way, we will not create an authenticated session and the caller will not be logged in.  Use this endpoint to test out a new sso_config without setting it as the only way to log into your organization.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.test_saml_acs_api_v2_organizations_organization_id_test_saml_acs_post_with_http_info(organization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str organization_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'organization_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method test_saml_acs_api_v2_organizations_organization_id_test_saml_acs_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_id' is set
        if self.api_client.client_side_validation and ('organization_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['organization_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_id` when calling `test_saml_acs_api_v2_organizations_organization_id_test_saml_acs_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_id' in local_var_params:
            path_params['organization_id'] = local_var_params['organization_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organizations/{organization_id}/test_saml_acs', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def trigger_cron_job_api_v2_experimental_cron_jobs_cron_job_id_trigger_post(self, cron_job_id, **kwargs):  # noqa: E501
        """Trigger Cron Job  # noqa: E501

        Trigger CRON Job  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.trigger_cron_job_api_v2_experimental_cron_jobs_cron_job_id_trigger_post(cron_job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cron_job_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ProductionjobResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.trigger_cron_job_api_v2_experimental_cron_jobs_cron_job_id_trigger_post_with_http_info(cron_job_id, **kwargs)  # noqa: E501

    def trigger_cron_job_api_v2_experimental_cron_jobs_cron_job_id_trigger_post_with_http_info(self, cron_job_id, **kwargs):  # noqa: E501
        """Trigger Cron Job  # noqa: E501

        Trigger CRON Job  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.trigger_cron_job_api_v2_experimental_cron_jobs_cron_job_id_trigger_post_with_http_info(cron_job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cron_job_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ProductionjobResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cron_job_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method trigger_cron_job_api_v2_experimental_cron_jobs_cron_job_id_trigger_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cron_job_id' is set
        if self.api_client.client_side_validation and ('cron_job_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cron_job_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cron_job_id` when calling `trigger_cron_job_api_v2_experimental_cron_jobs_cron_job_id_trigger_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cron_job_id' in local_var_params:
            path_params['cron_job_id'] = local_var_params['cron_job_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/experimental_cron_jobs/{cron_job_id}/trigger', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ProductionjobResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def try_login_api_v2_users_try_login_post(self, otp_token, **kwargs):  # noqa: E501
        """Try Login  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.try_login_api_v2_users_try_login_post(otp_token, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str otp_token: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: TryloginemailresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.try_login_api_v2_users_try_login_post_with_http_info(otp_token, **kwargs)  # noqa: E501

    def try_login_api_v2_users_try_login_post_with_http_info(self, otp_token, **kwargs):  # noqa: E501
        """Try Login  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.try_login_api_v2_users_try_login_post_with_http_info(otp_token, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str otp_token: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(TryloginemailresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'otp_token'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method try_login_api_v2_users_try_login_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'otp_token' is set
        if self.api_client.client_side_validation and ('otp_token' not in local_var_params or  # noqa: E501
                                                        local_var_params['otp_token'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `otp_token` when calling `try_login_api_v2_users_try_login_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'otp_token' in local_var_params and local_var_params['otp_token'] is not None:  # noqa: E501
            query_params.append(('otp_token', local_var_params['otp_token']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/users/try-login', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TryloginemailresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def undismiss_user_card_api_v2_onboarding_cards_card_id_undismiss_post(self, card_id, **kwargs):  # noqa: E501
        """Undismiss User Card  # noqa: E501

        For Internal Debugging: undismiss given card_id for logged in user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.undismiss_user_card_api_v2_onboarding_cards_card_id_undismiss_post(card_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CardId card_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.undismiss_user_card_api_v2_onboarding_cards_card_id_undismiss_post_with_http_info(card_id, **kwargs)  # noqa: E501

    def undismiss_user_card_api_v2_onboarding_cards_card_id_undismiss_post_with_http_info(self, card_id, **kwargs):  # noqa: E501
        """Undismiss User Card  # noqa: E501

        For Internal Debugging: undismiss given card_id for logged in user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.undismiss_user_card_api_v2_onboarding_cards_card_id_undismiss_post_with_http_info(card_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CardId card_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'card_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method undismiss_user_card_api_v2_onboarding_cards_card_id_undismiss_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'card_id' is set
        if self.api_client.client_side_validation and ('card_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['card_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `card_id` when calling `undismiss_user_card_api_v2_onboarding_cards_card_id_undismiss_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'card_id' in local_var_params:
            path_params['card_id'] = local_var_params['card_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/onboarding_cards/{card_id}/undismiss', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_aica_endpoint_api_v2_aica_endpoints_put(self, update_endpoint, **kwargs):  # noqa: E501
        """Update Aica Endpoint  # noqa: E501

        Updates an AICA endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_aica_endpoint_api_v2_aica_endpoints_put(update_endpoint, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param UpdateEndpoint update_endpoint: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AicaendpointResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_aica_endpoint_api_v2_aica_endpoints_put_with_http_info(update_endpoint, **kwargs)  # noqa: E501

    def update_aica_endpoint_api_v2_aica_endpoints_put_with_http_info(self, update_endpoint, **kwargs):  # noqa: E501
        """Update Aica Endpoint  # noqa: E501

        Updates an AICA endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_aica_endpoint_api_v2_aica_endpoints_put_with_http_info(update_endpoint, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param UpdateEndpoint update_endpoint: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AicaendpointResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'update_endpoint'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_aica_endpoint_api_v2_aica_endpoints_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'update_endpoint' is set
        if self.api_client.client_side_validation and ('update_endpoint' not in local_var_params or  # noqa: E501
                                                        local_var_params['update_endpoint'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `update_endpoint` when calling `update_aica_endpoint_api_v2_aica_endpoints_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'update_endpoint' in local_var_params:
            body_params = local_var_params['update_endpoint']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/aica_endpoints/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AicaendpointResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_cloud_auto_add_user_api_v2_clouds_cloud_id_auto_add_user_put(self, cloud_id, auto_add_user, **kwargs):  # noqa: E501
        """Update Cloud Auto Add User  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_cloud_auto_add_user_api_v2_clouds_cloud_id_auto_add_user_put(cloud_id, auto_add_user, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param bool auto_add_user: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_cloud_auto_add_user_api_v2_clouds_cloud_id_auto_add_user_put_with_http_info(cloud_id, auto_add_user, **kwargs)  # noqa: E501

    def update_cloud_auto_add_user_api_v2_clouds_cloud_id_auto_add_user_put_with_http_info(self, cloud_id, auto_add_user, **kwargs):  # noqa: E501
        """Update Cloud Auto Add User  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_cloud_auto_add_user_api_v2_clouds_cloud_id_auto_add_user_put_with_http_info(cloud_id, auto_add_user, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param bool auto_add_user: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id',
            'auto_add_user'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_cloud_auto_add_user_api_v2_clouds_cloud_id_auto_add_user_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `update_cloud_auto_add_user_api_v2_clouds_cloud_id_auto_add_user_put`")  # noqa: E501
        # verify the required parameter 'auto_add_user' is set
        if self.api_client.client_side_validation and ('auto_add_user' not in local_var_params or  # noqa: E501
                                                        local_var_params['auto_add_user'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `auto_add_user` when calling `update_cloud_auto_add_user_api_v2_clouds_cloud_id_auto_add_user_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501

        query_params = []
        if 'auto_add_user' in local_var_params and local_var_params['auto_add_user'] is not None:  # noqa: E501
            query_params.append(('auto_add_user', local_var_params['auto_add_user']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds/{cloud_id}/auto_add_user', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_cloud_config_api_v2_clouds_cloud_id_config_put(self, cloud_id, cloud_config, **kwargs):  # noqa: E501
        """Update Cloud Config  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_cloud_config_api_v2_clouds_cloud_id_config_put(cloud_id, cloud_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param CloudConfig cloud_config: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_cloud_config_api_v2_clouds_cloud_id_config_put_with_http_info(cloud_id, cloud_config, **kwargs)  # noqa: E501

    def update_cloud_config_api_v2_clouds_cloud_id_config_put_with_http_info(self, cloud_id, cloud_config, **kwargs):  # noqa: E501
        """Update Cloud Config  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_cloud_config_api_v2_clouds_cloud_id_config_put_with_http_info(cloud_id, cloud_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param CloudConfig cloud_config: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id',
            'cloud_config'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_cloud_config_api_v2_clouds_cloud_id_config_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `update_cloud_config_api_v2_clouds_cloud_id_config_put`")  # noqa: E501
        # verify the required parameter 'cloud_config' is set
        if self.api_client.client_side_validation and ('cloud_config' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_config'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_config` when calling `update_cloud_config_api_v2_clouds_cloud_id_config_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'cloud_config' in local_var_params:
            body_params = local_var_params['cloud_config']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds/{cloud_id}/config', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_gcp_router_cloud_id_put(self, cloud_id, update_cloud_with_cloud_resource_gcp, **kwargs):  # noqa: E501
        """Update Cloud With Cloud Resource  # noqa: E501

        Updates a Cloud with CloudResource.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_gcp_router_cloud_id_put(cloud_id, update_cloud_with_cloud_resource_gcp, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param UpdateCloudWithCloudResourceGCP update_cloud_with_cloud_resource_gcp: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CloudwithcloudresourcegcpResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_gcp_router_cloud_id_put_with_http_info(cloud_id, update_cloud_with_cloud_resource_gcp, **kwargs)  # noqa: E501

    def update_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_gcp_router_cloud_id_put_with_http_info(self, cloud_id, update_cloud_with_cloud_resource_gcp, **kwargs):  # noqa: E501
        """Update Cloud With Cloud Resource  # noqa: E501

        Updates a Cloud with CloudResource.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_gcp_router_cloud_id_put_with_http_info(cloud_id, update_cloud_with_cloud_resource_gcp, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param UpdateCloudWithCloudResourceGCP update_cloud_with_cloud_resource_gcp: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CloudwithcloudresourcegcpResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id',
            'update_cloud_with_cloud_resource_gcp'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_gcp_router_cloud_id_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `update_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_gcp_router_cloud_id_put`")  # noqa: E501
        # verify the required parameter 'update_cloud_with_cloud_resource_gcp' is set
        if self.api_client.client_side_validation and ('update_cloud_with_cloud_resource_gcp' not in local_var_params or  # noqa: E501
                                                        local_var_params['update_cloud_with_cloud_resource_gcp'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `update_cloud_with_cloud_resource_gcp` when calling `update_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_gcp_router_cloud_id_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'update_cloud_with_cloud_resource_gcp' in local_var_params:
            body_params = local_var_params['update_cloud_with_cloud_resource_gcp']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds_with_cloud_resource_gcp_router/{cloud_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CloudwithcloudresourcegcpResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_router_cloud_id_put(self, cloud_id, update_cloud_with_cloud_resource, **kwargs):  # noqa: E501
        """Update Cloud With Cloud Resource  # noqa: E501

        Updates a Cloud with CloudResource.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_router_cloud_id_put(cloud_id, update_cloud_with_cloud_resource, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param UpdateCloudWithCloudResource update_cloud_with_cloud_resource: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CloudwithcloudresourceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_router_cloud_id_put_with_http_info(cloud_id, update_cloud_with_cloud_resource, **kwargs)  # noqa: E501

    def update_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_router_cloud_id_put_with_http_info(self, cloud_id, update_cloud_with_cloud_resource, **kwargs):  # noqa: E501
        """Update Cloud With Cloud Resource  # noqa: E501

        Updates a Cloud with CloudResource.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_router_cloud_id_put_with_http_info(cloud_id, update_cloud_with_cloud_resource, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param UpdateCloudWithCloudResource update_cloud_with_cloud_resource: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CloudwithcloudresourceResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id',
            'update_cloud_with_cloud_resource'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_router_cloud_id_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `update_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_router_cloud_id_put`")  # noqa: E501
        # verify the required parameter 'update_cloud_with_cloud_resource' is set
        if self.api_client.client_side_validation and ('update_cloud_with_cloud_resource' not in local_var_params or  # noqa: E501
                                                        local_var_params['update_cloud_with_cloud_resource'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `update_cloud_with_cloud_resource` when calling `update_cloud_with_cloud_resource_api_v2_clouds_with_cloud_resource_router_cloud_id_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'update_cloud_with_cloud_resource' in local_var_params:
            body_params = local_var_params['update_cloud_with_cloud_resource']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds_with_cloud_resource_router/{cloud_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CloudwithcloudresourceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_compute_template_api_v2_compute_templates_compute_template_id_put(self, compute_template_id, update_compute_template, **kwargs):  # noqa: E501
        """Update Compute Template  # noqa: E501

        Updates a compute template. DEPRECATED: Compute templates will be immutable. Please create a new one instead of updating existing ones.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_compute_template_api_v2_compute_templates_compute_template_id_put(compute_template_id, update_compute_template, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str compute_template_id: (required)
        :param UpdateComputeTemplate update_compute_template: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ComputetemplateResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_compute_template_api_v2_compute_templates_compute_template_id_put_with_http_info(compute_template_id, update_compute_template, **kwargs)  # noqa: E501

    def update_compute_template_api_v2_compute_templates_compute_template_id_put_with_http_info(self, compute_template_id, update_compute_template, **kwargs):  # noqa: E501
        """Update Compute Template  # noqa: E501

        Updates a compute template. DEPRECATED: Compute templates will be immutable. Please create a new one instead of updating existing ones.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_compute_template_api_v2_compute_templates_compute_template_id_put_with_http_info(compute_template_id, update_compute_template, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str compute_template_id: (required)
        :param UpdateComputeTemplate update_compute_template: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ComputetemplateResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'compute_template_id',
            'update_compute_template'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_compute_template_api_v2_compute_templates_compute_template_id_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'compute_template_id' is set
        if self.api_client.client_side_validation and ('compute_template_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['compute_template_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `compute_template_id` when calling `update_compute_template_api_v2_compute_templates_compute_template_id_put`")  # noqa: E501
        # verify the required parameter 'update_compute_template' is set
        if self.api_client.client_side_validation and ('update_compute_template' not in local_var_params or  # noqa: E501
                                                        local_var_params['update_compute_template'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `update_compute_template` when calling `update_compute_template_api_v2_compute_templates_compute_template_id_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'compute_template_id' in local_var_params:
            path_params['compute_template_id'] = local_var_params['compute_template_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'update_compute_template' in local_var_params:
            body_params = local_var_params['update_compute_template']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/compute_templates/{compute_template_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ComputetemplateResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_customer_aggregated_logs_config_api_v2_clouds_cloud_id_update_customer_aggregated_logs_config_put(self, cloud_id, is_enabled, **kwargs):  # noqa: E501
        """Update Customer Aggregated Logs Config  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_customer_aggregated_logs_config_api_v2_clouds_cloud_id_update_customer_aggregated_logs_config_put(cloud_id, is_enabled, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param bool is_enabled: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_customer_aggregated_logs_config_api_v2_clouds_cloud_id_update_customer_aggregated_logs_config_put_with_http_info(cloud_id, is_enabled, **kwargs)  # noqa: E501

    def update_customer_aggregated_logs_config_api_v2_clouds_cloud_id_update_customer_aggregated_logs_config_put_with_http_info(self, cloud_id, is_enabled, **kwargs):  # noqa: E501
        """Update Customer Aggregated Logs Config  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_customer_aggregated_logs_config_api_v2_clouds_cloud_id_update_customer_aggregated_logs_config_put_with_http_info(cloud_id, is_enabled, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param bool is_enabled: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id',
            'is_enabled'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_customer_aggregated_logs_config_api_v2_clouds_cloud_id_update_customer_aggregated_logs_config_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `update_customer_aggregated_logs_config_api_v2_clouds_cloud_id_update_customer_aggregated_logs_config_put`")  # noqa: E501
        # verify the required parameter 'is_enabled' is set
        if self.api_client.client_side_validation and ('is_enabled' not in local_var_params or  # noqa: E501
                                                        local_var_params['is_enabled'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `is_enabled` when calling `update_customer_aggregated_logs_config_api_v2_clouds_cloud_id_update_customer_aggregated_logs_config_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501

        query_params = []
        if 'is_enabled' in local_var_params and local_var_params['is_enabled'] is not None:  # noqa: E501
            query_params.append(('is_enabled', local_var_params['is_enabled']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/clouds/{cloud_id}/update_customer_aggregated_logs_config', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_default_cloud_api_v2_organizations_update_default_cloud_post(self, cloud_id, **kwargs):  # noqa: E501
        """Update Default Cloud  # noqa: E501

        Updates the default cloud for the request user's organization. Checks that the user is owner of organization and that the cloud has organization level permissions.  ** Note: If cloud isolation is enabled, the cloud doesn't have to be accessible to all members of the organization. The organization admin can choose to set a default cloud that not all collaborators have access to.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_default_cloud_api_v2_organizations_update_default_cloud_post(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_default_cloud_api_v2_organizations_update_default_cloud_post_with_http_info(cloud_id, **kwargs)  # noqa: E501

    def update_default_cloud_api_v2_organizations_update_default_cloud_post_with_http_info(self, cloud_id, **kwargs):  # noqa: E501
        """Update Default Cloud  # noqa: E501

        Updates the default cloud for the request user's organization. Checks that the user is owner of organization and that the cloud has organization level permissions.  ** Note: If cloud isolation is enabled, the cloud doesn't have to be accessible to all members of the organization. The organization admin can choose to set a default cloud that not all collaborators have access to.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_default_cloud_api_v2_organizations_update_default_cloud_post_with_http_info(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_default_cloud_api_v2_organizations_update_default_cloud_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `update_default_cloud_api_v2_organizations_update_default_cloud_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cloud_id' in local_var_params and local_var_params['cloud_id'] is not None:  # noqa: E501
            query_params.append(('cloud_id', local_var_params['cloud_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organizations/update_default_cloud', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_dns_api_v2_dns_post(self, update_cluster_dns, **kwargs):  # noqa: E501
        """Update Dns  # noqa: E501

        Update head node ip in the database and dns.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_dns_api_v2_dns_post(update_cluster_dns, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param UpdateClusterDns update_cluster_dns: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_dns_api_v2_dns_post_with_http_info(update_cluster_dns, **kwargs)  # noqa: E501

    def update_dns_api_v2_dns_post_with_http_info(self, update_cluster_dns, **kwargs):  # noqa: E501
        """Update Dns  # noqa: E501

        Update head node ip in the database and dns.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_dns_api_v2_dns_post_with_http_info(update_cluster_dns, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param UpdateClusterDns update_cluster_dns: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'update_cluster_dns'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_dns_api_v2_dns_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'update_cluster_dns' is set
        if self.api_client.client_side_validation and ('update_cluster_dns' not in local_var_params or  # noqa: E501
                                                        local_var_params['update_cluster_dns'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `update_cluster_dns` when calling `update_dns_api_v2_dns_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'update_cluster_dns' in local_var_params:
            body_params = local_var_params['update_cluster_dns']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/dns/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def upload_file_api_v2_files_post(self, file, cloud_id, **kwargs):  # noqa: E501
        """Upload File  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upload_file_api_v2_files_post(file, cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param file file: (required)
        :param str cloud_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: FilemodelResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.upload_file_api_v2_files_post_with_http_info(file, cloud_id, **kwargs)  # noqa: E501

    def upload_file_api_v2_files_post_with_http_info(self, file, cloud_id, **kwargs):  # noqa: E501
        """Upload File  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upload_file_api_v2_files_post_with_http_info(file, cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param file file: (required)
        :param str cloud_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(FilemodelResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'file',
            'cloud_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upload_file_api_v2_files_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'file' is set
        if self.api_client.client_side_validation and ('file' not in local_var_params or  # noqa: E501
                                                        local_var_params['file'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `file` when calling `upload_file_api_v2_files_post`")  # noqa: E501
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `upload_file_api_v2_files_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in local_var_params:
            local_var_files['file'] = local_var_params['file']  # noqa: E501
        if 'cloud_id' in local_var_params:
            form_params.append(('cloud_id', local_var_params['cloud_id']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/files', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FilemodelResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def upload_session_command_logs_api_v2_session_commands_session_command_id_upload_logs_post(self, session_command_id, **kwargs):  # noqa: E501
        """Upload Session Command Logs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upload_session_command_logs_api_v2_session_commands_session_command_id_upload_logs_post(session_command_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_command_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: UploadsessioncommandlogslocationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.upload_session_command_logs_api_v2_session_commands_session_command_id_upload_logs_post_with_http_info(session_command_id, **kwargs)  # noqa: E501

    def upload_session_command_logs_api_v2_session_commands_session_command_id_upload_logs_post_with_http_info(self, session_command_id, **kwargs):  # noqa: E501
        """Upload Session Command Logs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upload_session_command_logs_api_v2_session_commands_session_command_id_upload_logs_post_with_http_info(session_command_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str session_command_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(UploadsessioncommandlogslocationsResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'session_command_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upload_session_command_logs_api_v2_session_commands_session_command_id_upload_logs_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'session_command_id' is set
        if self.api_client.client_side_validation and ('session_command_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_command_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_command_id` when calling `upload_session_command_logs_api_v2_session_commands_session_command_id_upload_logs_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'session_command_id' in local_var_params:
            path_params['session_command_id'] = local_var_params['session_command_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/session_commands/{session_command_id}/upload_logs', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UploadsessioncommandlogslocationsResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def upsert_billing_version_api_v2_organization_billing_billing_versions_put(self, create_billing_version, **kwargs):  # noqa: E501
        """Upsert Billing Version  # noqa: E501

        Upsert a billing version record for the organization.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upsert_billing_version_api_v2_organization_billing_billing_versions_put(create_billing_version, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateBillingVersion create_billing_version: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.upsert_billing_version_api_v2_organization_billing_billing_versions_put_with_http_info(create_billing_version, **kwargs)  # noqa: E501

    def upsert_billing_version_api_v2_organization_billing_billing_versions_put_with_http_info(self, create_billing_version, **kwargs):  # noqa: E501
        """Upsert Billing Version  # noqa: E501

        Upsert a billing version record for the organization.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upsert_billing_version_api_v2_organization_billing_billing_versions_put_with_http_info(create_billing_version, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateBillingVersion create_billing_version: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'create_billing_version'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upsert_billing_version_api_v2_organization_billing_billing_versions_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'create_billing_version' is set
        if self.api_client.client_side_validation and ('create_billing_version' not in local_var_params or  # noqa: E501
                                                        local_var_params['create_billing_version'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `create_billing_version` when calling `upsert_billing_version_api_v2_organization_billing_billing_versions_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_billing_version' in local_var_params:
            body_params = local_var_params['create_billing_version']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/organization_billing/billing_versions', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def upsert_support_request_for_user_organization_api_v2_support_requests_support_request_put(self, write_support_request, **kwargs):  # noqa: E501
        """Upsert Support Request For User Organization  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upsert_support_request_for_user_organization_api_v2_support_requests_support_request_put(write_support_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param WriteSupportRequest write_support_request: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.upsert_support_request_for_user_organization_api_v2_support_requests_support_request_put_with_http_info(write_support_request, **kwargs)  # noqa: E501

    def upsert_support_request_for_user_organization_api_v2_support_requests_support_request_put_with_http_info(self, write_support_request, **kwargs):  # noqa: E501
        """Upsert Support Request For User Organization  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upsert_support_request_for_user_organization_api_v2_support_requests_support_request_put_with_http_info(write_support_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param WriteSupportRequest write_support_request: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'write_support_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upsert_support_request_for_user_organization_api_v2_support_requests_support_request_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'write_support_request' is set
        if self.api_client.client_side_validation and ('write_support_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['write_support_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `write_support_request` when calling `upsert_support_request_for_user_organization_api_v2_support_requests_support_request_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'write_support_request' in local_var_params:
            body_params = local_var_params['write_support_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/support_requests/support_request', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def user_resend_email_api_v2_users_resend_email_post(self, user_resend_email_options, **kwargs):  # noqa: E501
        """User Resend Email  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.user_resend_email_api_v2_users_resend_email_post(user_resend_email_options, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param UserResendEmailOptions user_resend_email_options: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.user_resend_email_api_v2_users_resend_email_post_with_http_info(user_resend_email_options, **kwargs)  # noqa: E501

    def user_resend_email_api_v2_users_resend_email_post_with_http_info(self, user_resend_email_options, **kwargs):  # noqa: E501
        """User Resend Email  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.user_resend_email_api_v2_users_resend_email_post_with_http_info(user_resend_email_options, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param UserResendEmailOptions user_resend_email_options: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'user_resend_email_options'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_resend_email_api_v2_users_resend_email_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user_resend_email_options' is set
        if self.api_client.client_side_validation and ('user_resend_email_options' not in local_var_params or  # noqa: E501
                                                        local_var_params['user_resend_email_options'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `user_resend_email_options` when calling `user_resend_email_api_v2_users_resend_email_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'user_resend_email_options' in local_var_params:
            body_params = local_var_params['user_resend_email_options']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/users/resend_email', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def user_verify_api_v2_users_verify_token_get(self, token, **kwargs):  # noqa: E501
        """User Verify  # noqa: E501

        Endpoint for verifying user emails.  This API response will contain appropriate cookies to log in the user if the user was previously unverified (first time logging in). Note: This endpoint is not meant to replace the login endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.user_verify_api_v2_users_verify_token_get(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str token: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.user_verify_api_v2_users_verify_token_get_with_http_info(token, **kwargs)  # noqa: E501

    def user_verify_api_v2_users_verify_token_get_with_http_info(self, token, **kwargs):  # noqa: E501
        """User Verify  # noqa: E501

        Endpoint for verifying user emails.  This API response will contain appropriate cookies to log in the user if the user was previously unverified (first time logging in). Note: This endpoint is not meant to replace the login endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.user_verify_api_v2_users_verify_token_get_with_http_info(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str token: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'token'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_verify_api_v2_users_verify_token_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'token' is set
        if self.api_client.client_side_validation and ('token' not in local_var_params or  # noqa: E501
                                                        local_var_params['token'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `token` when calling `user_verify_api_v2_users_verify_token_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'token' in local_var_params:
            path_params['token'] = local_var_params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/users/verify/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def validate_cluster_api_v2_sessions_validate_cluster_post(self, body, **kwargs):  # noqa: E501
        """Validate Cluster  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.validate_cluster_api_v2_sessions_validate_cluster_post(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param object body: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.validate_cluster_api_v2_sessions_validate_cluster_post_with_http_info(body, **kwargs)  # noqa: E501

    def validate_cluster_api_v2_sessions_validate_cluster_post_with_http_info(self, body, **kwargs):  # noqa: E501
        """Validate Cluster  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.validate_cluster_api_v2_sessions_validate_cluster_post_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param object body: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method validate_cluster_api_v2_sessions_validate_cluster_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in local_var_params or  # noqa: E501
                                                        local_var_params['body'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `validate_cluster_api_v2_sessions_validate_cluster_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/sessions/validate_cluster', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def validate_invite_code_api_v2_users_validate_invite_code_invite_code_post(self, invite_code, **kwargs):  # noqa: E501
        """Validate Invite Code  # noqa: E501

        Endpoint for verifying user invite codes. Successful if the invite code is valid or if invite codes are not required.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.validate_invite_code_api_v2_users_validate_invite_code_invite_code_post(invite_code, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str invite_code: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.validate_invite_code_api_v2_users_validate_invite_code_invite_code_post_with_http_info(invite_code, **kwargs)  # noqa: E501

    def validate_invite_code_api_v2_users_validate_invite_code_invite_code_post_with_http_info(self, invite_code, **kwargs):  # noqa: E501
        """Validate Invite Code  # noqa: E501

        Endpoint for verifying user invite codes. Successful if the invite code is valid or if invite codes are not required.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.validate_invite_code_api_v2_users_validate_invite_code_invite_code_post_with_http_info(invite_code, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str invite_code: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'invite_code'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method validate_invite_code_api_v2_users_validate_invite_code_invite_code_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'invite_code' is set
        if self.api_client.client_side_validation and ('invite_code' not in local_var_params or  # noqa: E501
                                                        local_var_params['invite_code'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `invite_code` when calling `validate_invite_code_api_v2_users_validate_invite_code_invite_code_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'invite_code' in local_var_params:
            path_params['invite_code'] = local_var_params['invite_code']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/users/validate_invite_code/{invite_code}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def validate_one_time_password_api_v2_users_validate_otp_token_post(self, validate_otp_params_api_model, **kwargs):  # noqa: E501
        """Validate One Time Password  # noqa: E501

        Validate the one-time password  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.validate_one_time_password_api_v2_users_validate_otp_token_post(validate_otp_params_api_model, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ValidateOTPParamsApiModel validate_otp_params_api_model: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.validate_one_time_password_api_v2_users_validate_otp_token_post_with_http_info(validate_otp_params_api_model, **kwargs)  # noqa: E501

    def validate_one_time_password_api_v2_users_validate_otp_token_post_with_http_info(self, validate_otp_params_api_model, **kwargs):  # noqa: E501
        """Validate One Time Password  # noqa: E501

        Validate the one-time password  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.validate_one_time_password_api_v2_users_validate_otp_token_post_with_http_info(validate_otp_params_api_model, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ValidateOTPParamsApiModel validate_otp_params_api_model: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'validate_otp_params_api_model'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method validate_one_time_password_api_v2_users_validate_otp_token_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'validate_otp_params_api_model' is set
        if self.api_client.client_side_validation and ('validate_otp_params_api_model' not in local_var_params or  # noqa: E501
                                                        local_var_params['validate_otp_params_api_model'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `validate_otp_params_api_model` when calling `validate_one_time_password_api_v2_users_validate_otp_token_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'validate_otp_params_api_model' in local_var_params:
            body_params = local_var_params['validate_otp_params_api_model']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/users/validate_otp_token', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def verify_access_api_v2_cloudsverify_access_cloud_id_get(self, cloud_id, **kwargs):  # noqa: E501
        """Verify Access  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.verify_access_api_v2_cloudsverify_access_cloud_id_get(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.verify_access_api_v2_cloudsverify_access_cloud_id_get_with_http_info(cloud_id, **kwargs)  # noqa: E501

    def verify_access_api_v2_cloudsverify_access_cloud_id_get_with_http_info(self, cloud_id, **kwargs):  # noqa: E501
        """Verify Access  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.verify_access_api_v2_cloudsverify_access_cloud_id_get_with_http_info(cloud_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str cloud_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'cloud_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method verify_access_api_v2_cloudsverify_access_cloud_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cloud_id' is set
        if self.api_client.client_side_validation and ('cloud_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['cloud_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `cloud_id` when calling `verify_access_api_v2_cloudsverify_access_cloud_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cloud_id' in local_var_params:
            path_params['cloud_id'] = local_var_params['cloud_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/cloudsverify_access/{cloud_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def verify_migration_complete_api_v2_access_controls_migration_organization_id_verify_migration_complete_get(self, organization_id, **kwargs):  # noqa: E501
        """Verify Migration Complete  # noqa: E501

        Verify migration was completed successfully. This API is only available to Anyscale internal employees.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.verify_migration_complete_api_v2_access_controls_migration_organization_id_verify_migration_complete_get(organization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str organization_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: VerifyresponseResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.verify_migration_complete_api_v2_access_controls_migration_organization_id_verify_migration_complete_get_with_http_info(organization_id, **kwargs)  # noqa: E501

    def verify_migration_complete_api_v2_access_controls_migration_organization_id_verify_migration_complete_get_with_http_info(self, organization_id, **kwargs):  # noqa: E501
        """Verify Migration Complete  # noqa: E501

        Verify migration was completed successfully. This API is only available to Anyscale internal employees.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.verify_migration_complete_api_v2_access_controls_migration_organization_id_verify_migration_complete_get_with_http_info(organization_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str organization_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(VerifyresponseResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'organization_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method verify_migration_complete_api_v2_access_controls_migration_organization_id_verify_migration_complete_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_id' is set
        if self.api_client.client_side_validation and ('organization_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['organization_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_id` when calling `verify_migration_complete_api_v2_access_controls_migration_organization_id_verify_migration_complete_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_id' in local_var_params:
            path_params['organization_id'] = local_var_params['organization_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/access_controls_migration/{organization_id}/verify_migration_complete', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VerifyresponseResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def verify_reset_password_token_api_v2_users_reset_password_token_get(self, token, **kwargs):  # noqa: E501
        """Verify Reset Password Token  # noqa: E501

        Verifies that the specified token is a valid, non-expired password reset token.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.verify_reset_password_token_api_v2_users_reset_password_token_get(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str token: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.verify_reset_password_token_api_v2_users_reset_password_token_get_with_http_info(token, **kwargs)  # noqa: E501

    def verify_reset_password_token_api_v2_users_reset_password_token_get_with_http_info(self, token, **kwargs):  # noqa: E501
        """Verify Reset Password Token  # noqa: E501

        Verifies that the specified token is a valid, non-expired password reset token.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.verify_reset_password_token_api_v2_users_reset_password_token_get_with_http_info(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str token: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'token'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method verify_reset_password_token_api_v2_users_reset_password_token_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'token' is set
        if self.api_client.client_side_validation and ('token' not in local_var_params or  # noqa: E501
                                                        local_var_params['token'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `token` when calling `verify_reset_password_token_api_v2_users_reset_password_token_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'token' in local_var_params:
            path_params['token'] = local_var_params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/users/reset_password/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)
