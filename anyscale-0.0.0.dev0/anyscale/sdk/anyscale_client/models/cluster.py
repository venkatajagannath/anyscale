# coding: utf-8

"""
    Anyscale API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)  # noqa: E501

    The version of the OpenAPI document: 0.1.0
    Generated by: https://openapi-generator.tech
"""


import pprint
import re  # noqa: F401

import six

from anyscale_client.configuration import Configuration


class Cluster(object):
    """NOTE: This class is auto generated by OpenAPI Generator.
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    """
    Attributes:
      openapi_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    openapi_types = {
        'name': 'str',
        'project_id': 'str',
        'cluster_environment_build_id': 'str',
        'cluster_compute_id': 'str',
        'cluster_compute_config': 'CreateClusterComputeConfig',
        'idle_timeout_minutes': 'int',
        'allow_public_internet_traffic': 'bool',
        'user_service_access': 'UserServiceAccessTypes',
        'user_service_token': 'str',
        'ha_job_id': 'str',
        'id': 'str',
        'state': 'ClusterState',
        'goal_state': 'ClusterState',
        'creator_id': 'str',
        'created_at': 'datetime',
        'access_token': 'str',
        'services_urls': 'ClusterServicesUrls',
        'head_node_info': 'ClusterHeadNodeInfo',
        'ssh_authorized_keys': 'list[str]',
        'ssh_private_key': 'str',
        'ray_version': 'str',
        'ray_version_last_updated_at': 'datetime'
    }

    attribute_map = {
        'name': 'name',
        'project_id': 'project_id',
        'cluster_environment_build_id': 'cluster_environment_build_id',
        'cluster_compute_id': 'cluster_compute_id',
        'cluster_compute_config': 'cluster_compute_config',
        'idle_timeout_minutes': 'idle_timeout_minutes',
        'allow_public_internet_traffic': 'allow_public_internet_traffic',
        'user_service_access': 'user_service_access',
        'user_service_token': 'user_service_token',
        'ha_job_id': 'ha_job_id',
        'id': 'id',
        'state': 'state',
        'goal_state': 'goal_state',
        'creator_id': 'creator_id',
        'created_at': 'created_at',
        'access_token': 'access_token',
        'services_urls': 'services_urls',
        'head_node_info': 'head_node_info',
        'ssh_authorized_keys': 'ssh_authorized_keys',
        'ssh_private_key': 'ssh_private_key',
        'ray_version': 'ray_version',
        'ray_version_last_updated_at': 'ray_version_last_updated_at'
    }

    def __init__(self, name=None, project_id=None, cluster_environment_build_id=None, cluster_compute_id=None, cluster_compute_config=None, idle_timeout_minutes=120, allow_public_internet_traffic=False, user_service_access=None, user_service_token=None, ha_job_id=None, id=None, state=None, goal_state=None, creator_id=None, created_at=None, access_token=None, services_urls=None, head_node_info=None, ssh_authorized_keys=None, ssh_private_key=None, ray_version=None, ray_version_last_updated_at=None, local_vars_configuration=None):  # noqa: E501
        """Cluster - a model defined in OpenAPI"""  # noqa: E501
        if local_vars_configuration is None:
            local_vars_configuration = Configuration()
        self.local_vars_configuration = local_vars_configuration

        self._name = None
        self._project_id = None
        self._cluster_environment_build_id = None
        self._cluster_compute_id = None
        self._cluster_compute_config = None
        self._idle_timeout_minutes = None
        self._allow_public_internet_traffic = None
        self._user_service_access = None
        self._user_service_token = None
        self._ha_job_id = None
        self._id = None
        self._state = None
        self._goal_state = None
        self._creator_id = None
        self._created_at = None
        self._access_token = None
        self._services_urls = None
        self._head_node_info = None
        self._ssh_authorized_keys = None
        self._ssh_private_key = None
        self._ray_version = None
        self._ray_version_last_updated_at = None
        self.discriminator = None

        self.name = name
        if project_id is not None:
            self.project_id = project_id
        self.cluster_environment_build_id = cluster_environment_build_id
        self.cluster_compute_id = cluster_compute_id
        if cluster_compute_config is not None:
            self.cluster_compute_config = cluster_compute_config
        if idle_timeout_minutes is not None:
            self.idle_timeout_minutes = idle_timeout_minutes
        if allow_public_internet_traffic is not None:
            self.allow_public_internet_traffic = allow_public_internet_traffic
        if user_service_access is not None:
            self.user_service_access = user_service_access
        if user_service_token is not None:
            self.user_service_token = user_service_token
        if ha_job_id is not None:
            self.ha_job_id = ha_job_id
        self.id = id
        self.state = state
        if goal_state is not None:
            self.goal_state = goal_state
        self.creator_id = creator_id
        self.created_at = created_at
        self.access_token = access_token
        self.services_urls = services_urls
        if head_node_info is not None:
            self.head_node_info = head_node_info
        self.ssh_authorized_keys = ssh_authorized_keys
        self.ssh_private_key = ssh_private_key
        if ray_version is not None:
            self.ray_version = ray_version
        if ray_version_last_updated_at is not None:
            self.ray_version_last_updated_at = ray_version_last_updated_at

    @property
    def name(self):
        """Gets the name of this Cluster.  # noqa: E501

        Name of this Cluster.  # noqa: E501

        :return: The name of this Cluster.  # noqa: E501
        :rtype: str
        """
        return self._name

    @name.setter
    def name(self, name):
        """Sets the name of this Cluster.

        Name of this Cluster.  # noqa: E501

        :param name: The name of this Cluster.  # noqa: E501
        :type: str
        """
        if self.local_vars_configuration.client_side_validation and name is None:  # noqa: E501
            raise ValueError("Invalid value for `name`, must not be `None`")  # noqa: E501

        self._name = name

    @property
    def project_id(self):
        """Gets the project_id of this Cluster.  # noqa: E501

        Project that this Cluster belongs to. If none, this Cluster will use the default Project.  # noqa: E501

        :return: The project_id of this Cluster.  # noqa: E501
        :rtype: str
        """
        return self._project_id

    @project_id.setter
    def project_id(self, project_id):
        """Sets the project_id of this Cluster.

        Project that this Cluster belongs to. If none, this Cluster will use the default Project.  # noqa: E501

        :param project_id: The project_id of this Cluster.  # noqa: E501
        :type: str
        """

        self._project_id = project_id

    @property
    def cluster_environment_build_id(self):
        """Gets the cluster_environment_build_id of this Cluster.  # noqa: E501

        Cluster Environment Build that this Cluster is using.  # noqa: E501

        :return: The cluster_environment_build_id of this Cluster.  # noqa: E501
        :rtype: str
        """
        return self._cluster_environment_build_id

    @cluster_environment_build_id.setter
    def cluster_environment_build_id(self, cluster_environment_build_id):
        """Sets the cluster_environment_build_id of this Cluster.

        Cluster Environment Build that this Cluster is using.  # noqa: E501

        :param cluster_environment_build_id: The cluster_environment_build_id of this Cluster.  # noqa: E501
        :type: str
        """
        if self.local_vars_configuration.client_side_validation and cluster_environment_build_id is None:  # noqa: E501
            raise ValueError("Invalid value for `cluster_environment_build_id`, must not be `None`")  # noqa: E501

        self._cluster_environment_build_id = cluster_environment_build_id

    @property
    def cluster_compute_id(self):
        """Gets the cluster_compute_id of this Cluster.  # noqa: E501

        Cluster Compute that this Cluster is using.  # noqa: E501

        :return: The cluster_compute_id of this Cluster.  # noqa: E501
        :rtype: str
        """
        return self._cluster_compute_id

    @cluster_compute_id.setter
    def cluster_compute_id(self, cluster_compute_id):
        """Sets the cluster_compute_id of this Cluster.

        Cluster Compute that this Cluster is using.  # noqa: E501

        :param cluster_compute_id: The cluster_compute_id of this Cluster.  # noqa: E501
        :type: str
        """
        if self.local_vars_configuration.client_side_validation and cluster_compute_id is None:  # noqa: E501
            raise ValueError("Invalid value for `cluster_compute_id`, must not be `None`")  # noqa: E501

        self._cluster_compute_id = cluster_compute_id

    @property
    def cluster_compute_config(self):
        """Gets the cluster_compute_config of this Cluster.  # noqa: E501

        One-off cluster compute that this cluster is using.  # noqa: E501

        :return: The cluster_compute_config of this Cluster.  # noqa: E501
        :rtype: CreateClusterComputeConfig
        """
        return self._cluster_compute_config

    @cluster_compute_config.setter
    def cluster_compute_config(self, cluster_compute_config):
        """Sets the cluster_compute_config of this Cluster.

        One-off cluster compute that this cluster is using.  # noqa: E501

        :param cluster_compute_config: The cluster_compute_config of this Cluster.  # noqa: E501
        :type: CreateClusterComputeConfig
        """

        self._cluster_compute_config = cluster_compute_config

    @property
    def idle_timeout_minutes(self):
        """Gets the idle_timeout_minutes of this Cluster.  # noqa: E501

        Idle timeout (in minutes), after which the Cluster is terminated. Idle time is defined as the time during which a Cluster is not running a user command (through 'anyscale exec' or the Web UI), and does not have an attached driver. Time spent running Jupyter commands, or commands run through ssh, is still considered 'idle'.  # noqa: E501

        :return: The idle_timeout_minutes of this Cluster.  # noqa: E501
        :rtype: int
        """
        return self._idle_timeout_minutes

    @idle_timeout_minutes.setter
    def idle_timeout_minutes(self, idle_timeout_minutes):
        """Sets the idle_timeout_minutes of this Cluster.

        Idle timeout (in minutes), after which the Cluster is terminated. Idle time is defined as the time during which a Cluster is not running a user command (through 'anyscale exec' or the Web UI), and does not have an attached driver. Time spent running Jupyter commands, or commands run through ssh, is still considered 'idle'.  # noqa: E501

        :param idle_timeout_minutes: The idle_timeout_minutes of this Cluster.  # noqa: E501
        :type: int
        """

        self._idle_timeout_minutes = idle_timeout_minutes

    @property
    def allow_public_internet_traffic(self):
        """Gets the allow_public_internet_traffic of this Cluster.  # noqa: E501

        Whether public internet traffic can access Serve endpoints or if an authentication token is required.  # noqa: E501

        :return: The allow_public_internet_traffic of this Cluster.  # noqa: E501
        :rtype: bool
        """
        return self._allow_public_internet_traffic

    @allow_public_internet_traffic.setter
    def allow_public_internet_traffic(self, allow_public_internet_traffic):
        """Sets the allow_public_internet_traffic of this Cluster.

        Whether public internet traffic can access Serve endpoints or if an authentication token is required.  # noqa: E501

        :param allow_public_internet_traffic: The allow_public_internet_traffic of this Cluster.  # noqa: E501
        :type: bool
        """

        self._allow_public_internet_traffic = allow_public_internet_traffic

    @property
    def user_service_access(self):
        """Gets the user_service_access of this Cluster.  # noqa: E501

        Whether user service can be accessed by public internet traffic.  # noqa: E501

        :return: The user_service_access of this Cluster.  # noqa: E501
        :rtype: UserServiceAccessTypes
        """
        return self._user_service_access

    @user_service_access.setter
    def user_service_access(self, user_service_access):
        """Sets the user_service_access of this Cluster.

        Whether user service can be accessed by public internet traffic.  # noqa: E501

        :param user_service_access: The user_service_access of this Cluster.  # noqa: E501
        :type: UserServiceAccessTypes
        """

        self._user_service_access = user_service_access

    @property
    def user_service_token(self):
        """Gets the user_service_token of this Cluster.  # noqa: E501

        User service token that is used to authenticate access to public user services. This must be a valid 32 byte URL safe string and can be generated by calling `secrets.token_urlsafe(32))`. This is ignored if the user service has private access. If not specified for a public user service, a token is autogenerated.  # noqa: E501

        :return: The user_service_token of this Cluster.  # noqa: E501
        :rtype: str
        """
        return self._user_service_token

    @user_service_token.setter
    def user_service_token(self, user_service_token):
        """Sets the user_service_token of this Cluster.

        User service token that is used to authenticate access to public user services. This must be a valid 32 byte URL safe string and can be generated by calling `secrets.token_urlsafe(32))`. This is ignored if the user service has private access. If not specified for a public user service, a token is autogenerated.  # noqa: E501

        :param user_service_token: The user_service_token of this Cluster.  # noqa: E501
        :type: str
        """

        self._user_service_token = user_service_token

    @property
    def ha_job_id(self):
        """Gets the ha_job_id of this Cluster.  # noqa: E501

        This is used internally by Anyscale to associate clusters to a job. It is set automatically and should *not* be used directly.  # noqa: E501

        :return: The ha_job_id of this Cluster.  # noqa: E501
        :rtype: str
        """
        return self._ha_job_id

    @ha_job_id.setter
    def ha_job_id(self, ha_job_id):
        """Sets the ha_job_id of this Cluster.

        This is used internally by Anyscale to associate clusters to a job. It is set automatically and should *not* be used directly.  # noqa: E501

        :param ha_job_id: The ha_job_id of this Cluster.  # noqa: E501
        :type: str
        """

        self._ha_job_id = ha_job_id

    @property
    def id(self):
        """Gets the id of this Cluster.  # noqa: E501

        Server assigned unique identifier.  # noqa: E501

        :return: The id of this Cluster.  # noqa: E501
        :rtype: str
        """
        return self._id

    @id.setter
    def id(self, id):
        """Sets the id of this Cluster.

        Server assigned unique identifier.  # noqa: E501

        :param id: The id of this Cluster.  # noqa: E501
        :type: str
        """
        if self.local_vars_configuration.client_side_validation and id is None:  # noqa: E501
            raise ValueError("Invalid value for `id`, must not be `None`")  # noqa: E501

        self._id = id

    @property
    def state(self):
        """Gets the state of this Cluster.  # noqa: E501

        Current state of the Cluster.  # noqa: E501

        :return: The state of this Cluster.  # noqa: E501
        :rtype: ClusterState
        """
        return self._state

    @state.setter
    def state(self, state):
        """Sets the state of this Cluster.

        Current state of the Cluster.  # noqa: E501

        :param state: The state of this Cluster.  # noqa: E501
        :type: ClusterState
        """
        if self.local_vars_configuration.client_side_validation and state is None:  # noqa: E501
            raise ValueError("Invalid value for `state`, must not be `None`")  # noqa: E501

        self._state = state

    @property
    def goal_state(self):
        """Gets the goal_state of this Cluster.  # noqa: E501

        State that this Cluster will eventually transition to. This will not be populated if there are no pending transitions.  # noqa: E501

        :return: The goal_state of this Cluster.  # noqa: E501
        :rtype: ClusterState
        """
        return self._goal_state

    @goal_state.setter
    def goal_state(self, goal_state):
        """Sets the goal_state of this Cluster.

        State that this Cluster will eventually transition to. This will not be populated if there are no pending transitions.  # noqa: E501

        :param goal_state: The goal_state of this Cluster.  # noqa: E501
        :type: ClusterState
        """

        self._goal_state = goal_state

    @property
    def creator_id(self):
        """Gets the creator_id of this Cluster.  # noqa: E501

        User who created this Cluster.  # noqa: E501

        :return: The creator_id of this Cluster.  # noqa: E501
        :rtype: str
        """
        return self._creator_id

    @creator_id.setter
    def creator_id(self, creator_id):
        """Sets the creator_id of this Cluster.

        User who created this Cluster.  # noqa: E501

        :param creator_id: The creator_id of this Cluster.  # noqa: E501
        :type: str
        """
        if self.local_vars_configuration.client_side_validation and creator_id is None:  # noqa: E501
            raise ValueError("Invalid value for `creator_id`, must not be `None`")  # noqa: E501

        self._creator_id = creator_id

    @property
    def created_at(self):
        """Gets the created_at of this Cluster.  # noqa: E501

        Time at which this Cluster was created.  # noqa: E501

        :return: The created_at of this Cluster.  # noqa: E501
        :rtype: datetime
        """
        return self._created_at

    @created_at.setter
    def created_at(self, created_at):
        """Sets the created_at of this Cluster.

        Time at which this Cluster was created.  # noqa: E501

        :param created_at: The created_at of this Cluster.  # noqa: E501
        :type: datetime
        """
        if self.local_vars_configuration.client_side_validation and created_at is None:  # noqa: E501
            raise ValueError("Invalid value for `created_at`, must not be `None`")  # noqa: E501

        self._created_at = created_at

    @property
    def access_token(self):
        """Gets the access_token of this Cluster.  # noqa: E501

        Access token for web based services (e.g. jupyter, tensorboard, etc). This field will be populated when the web based services are available after the Cluster finishes starting.  # noqa: E501

        :return: The access_token of this Cluster.  # noqa: E501
        :rtype: str
        """
        return self._access_token

    @access_token.setter
    def access_token(self, access_token):
        """Sets the access_token of this Cluster.

        Access token for web based services (e.g. jupyter, tensorboard, etc). This field will be populated when the web based services are available after the Cluster finishes starting.  # noqa: E501

        :param access_token: The access_token of this Cluster.  # noqa: E501
        :type: str
        """
        if self.local_vars_configuration.client_side_validation and access_token is None:  # noqa: E501
            raise ValueError("Invalid value for `access_token`, must not be `None`")  # noqa: E501

        self._access_token = access_token

    @property
    def services_urls(self):
        """Gets the services_urls of this Cluster.  # noqa: E501

        URLs for additional services running on this Cluster (e.g. Jupyter, Ray Dashboard, etc.).  # noqa: E501

        :return: The services_urls of this Cluster.  # noqa: E501
        :rtype: ClusterServicesUrls
        """
        return self._services_urls

    @services_urls.setter
    def services_urls(self, services_urls):
        """Sets the services_urls of this Cluster.

        URLs for additional services running on this Cluster (e.g. Jupyter, Ray Dashboard, etc.).  # noqa: E501

        :param services_urls: The services_urls of this Cluster.  # noqa: E501
        :type: ClusterServicesUrls
        """
        if self.local_vars_configuration.client_side_validation and services_urls is None:  # noqa: E501
            raise ValueError("Invalid value for `services_urls`, must not be `None`")  # noqa: E501

        self._services_urls = services_urls

    @property
    def head_node_info(self):
        """Gets the head_node_info of this Cluster.  # noqa: E501

        Detailed information about this Cluster's head node. This will only be populated for Clusters that have finished starting.  # noqa: E501

        :return: The head_node_info of this Cluster.  # noqa: E501
        :rtype: ClusterHeadNodeInfo
        """
        return self._head_node_info

    @head_node_info.setter
    def head_node_info(self, head_node_info):
        """Sets the head_node_info of this Cluster.

        Detailed information about this Cluster's head node. This will only be populated for Clusters that have finished starting.  # noqa: E501

        :param head_node_info: The head_node_info of this Cluster.  # noqa: E501
        :type: ClusterHeadNodeInfo
        """

        self._head_node_info = head_node_info

    @property
    def ssh_authorized_keys(self):
        """Gets the ssh_authorized_keys of this Cluster.  # noqa: E501

        Serialized SSH Public Keys to be placed in the machine's authorized_keys.  # noqa: E501

        :return: The ssh_authorized_keys of this Cluster.  # noqa: E501
        :rtype: list[str]
        """
        return self._ssh_authorized_keys

    @ssh_authorized_keys.setter
    def ssh_authorized_keys(self, ssh_authorized_keys):
        """Sets the ssh_authorized_keys of this Cluster.

        Serialized SSH Public Keys to be placed in the machine's authorized_keys.  # noqa: E501

        :param ssh_authorized_keys: The ssh_authorized_keys of this Cluster.  # noqa: E501
        :type: list[str]
        """
        if self.local_vars_configuration.client_side_validation and ssh_authorized_keys is None:  # noqa: E501
            raise ValueError("Invalid value for `ssh_authorized_keys`, must not be `None`")  # noqa: E501

        self._ssh_authorized_keys = ssh_authorized_keys

    @property
    def ssh_private_key(self):
        """Gets the ssh_private_key of this Cluster.  # noqa: E501

        SSH Private key that can be used to access the Cluster's servers.  # noqa: E501

        :return: The ssh_private_key of this Cluster.  # noqa: E501
        :rtype: str
        """
        return self._ssh_private_key

    @ssh_private_key.setter
    def ssh_private_key(self, ssh_private_key):
        """Sets the ssh_private_key of this Cluster.

        SSH Private key that can be used to access the Cluster's servers.  # noqa: E501

        :param ssh_private_key: The ssh_private_key of this Cluster.  # noqa: E501
        :type: str
        """
        if self.local_vars_configuration.client_side_validation and ssh_private_key is None:  # noqa: E501
            raise ValueError("Invalid value for `ssh_private_key`, must not be `None`")  # noqa: E501

        self._ssh_private_key = ssh_private_key

    @property
    def ray_version(self):
        """Gets the ray_version of this Cluster.  # noqa: E501

        The last known ray version running on this cluster.  # noqa: E501

        :return: The ray_version of this Cluster.  # noqa: E501
        :rtype: str
        """
        return self._ray_version

    @ray_version.setter
    def ray_version(self, ray_version):
        """Sets the ray_version of this Cluster.

        The last known ray version running on this cluster.  # noqa: E501

        :param ray_version: The ray_version of this Cluster.  # noqa: E501
        :type: str
        """

        self._ray_version = ray_version

    @property
    def ray_version_last_updated_at(self):
        """Gets the ray_version_last_updated_at of this Cluster.  # noqa: E501

        The time in which the ray version of this cluster was updated.  # noqa: E501

        :return: The ray_version_last_updated_at of this Cluster.  # noqa: E501
        :rtype: datetime
        """
        return self._ray_version_last_updated_at

    @ray_version_last_updated_at.setter
    def ray_version_last_updated_at(self, ray_version_last_updated_at):
        """Sets the ray_version_last_updated_at of this Cluster.

        The time in which the ray version of this cluster was updated.  # noqa: E501

        :param ray_version_last_updated_at: The ray_version_last_updated_at of this Cluster.  # noqa: E501
        :type: datetime
        """

        self._ray_version_last_updated_at = ray_version_last_updated_at

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.openapi_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, Cluster):
            return False

        return self.to_dict() == other.to_dict()

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        if not isinstance(other, Cluster):
            return True

        return self.to_dict() != other.to_dict()
